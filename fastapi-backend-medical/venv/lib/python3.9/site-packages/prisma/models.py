# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template models.py.jinja --
import os
import logging
import inspect
import warnings
from collections import OrderedDict

from pydantic import BaseModel, Field

from . import types, enums, errors, fields, bases
from ._types import FuncType
from ._compat import model_rebuild, field_validator
from ._builder import serialize_base64
from .generator import partial_models_ctx, PartialModelField


log: logging.Logger = logging.getLogger(__name__)
_created_partial_types: Set[str] = set()

class active_medications(bases.Baseactive_medications):
    """Represents a active_medications record"""

    id: _int
    patient_id: _str
    name: _str
    dose: Optional[_int] = None
    dose_measurement: Optional[_str] = None
    frequency: Optional[_str] = None
    administration_route: Optional[_str] = None
    start_date: Optional[datetime.datetime] = None
    end_date: Optional[datetime.datetime] = None
    duration_of_treatment: Optional[_int] = None
    duration_of_treatment_measurement: Optional[_str] = None
    indications: Optional[_str] = None
    side_effects: Optional[_str] = None
    medication_status: Optional[_str] = None
    notes: Optional[_str] = None
    pacientes: Optional['models.pacientes'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.active_medicationsKeys']] = None,
        exclude: Optional[Iterable['types.active_medicationsKeys']] = None,
        required: Optional[Iterable['types.active_medicationsKeys']] = None,
        optional: Optional[Iterable['types.active_medicationsKeys']] = None,
        relations: Optional[Mapping['types.active_medicationsRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.active_medicationsKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _active_medications_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _active_medications_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _active_medications_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _active_medications_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _active_medications_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _active_medications_relational_fields:
                        raise errors.UnknownRelationalFieldError('active_medications', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid active_medications / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'active_medications',
            }
        )
        _created_partial_types.add(name)


class configs(bases.Baseconfigs):
    """Represents a configs record"""

    id: _int
    patient_id: _str
    user_id: _str
    stature: _int
    show_weight: _int
    show_body_mass: _int
    show_temperature: _int
    show_respiratory_rate: _int
    show_systolic: _int
    show_diastolic: _int
    show_heart_rate: _int
    show_body_fat_percentage: _int
    show_muscle_mass: _int
    show_head_circumference: _int
    show_oxygen_saturation: _int
    show_water_percentage: _int
    show_visceral_fat_percentage: _int
    show_bones: _int
    show_metabolism: _int
    show_protein_percentage: _int
    show_body_age: _int
    show_abdominal_perimeter: _int
    pacientes: Optional['models.pacientes'] = None
    users: Optional['models.users'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.configsKeys']] = None,
        exclude: Optional[Iterable['types.configsKeys']] = None,
        required: Optional[Iterable['types.configsKeys']] = None,
        optional: Optional[Iterable['types.configsKeys']] = None,
        relations: Optional[Mapping['types.configsRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.configsKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _configs_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _configs_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _configs_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _configs_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _configs_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _configs_relational_fields:
                        raise errors.UnknownRelationalFieldError('configs', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid configs / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'configs',
            }
        )
        _created_partial_types.add(name)


class hereditary_family_history(bases.Basehereditary_family_history):
    """Represents a hereditary_family_history record"""

    id: _int
    patient_id: _str
    diabetes: Optional[_bool] = None
    heart_disease: Optional[_bool] = None
    arterial_hypertension: Optional[_bool] = None
    thyroid_diseases: Optional[_bool] = None
    chronic_kidney_disease: Optional[_bool] = None
    others: Optional[_bool] = None
    pacientes: Optional['models.pacientes'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.hereditary_family_historyKeys']] = None,
        exclude: Optional[Iterable['types.hereditary_family_historyKeys']] = None,
        required: Optional[Iterable['types.hereditary_family_historyKeys']] = None,
        optional: Optional[Iterable['types.hereditary_family_historyKeys']] = None,
        relations: Optional[Mapping['types.hereditary_family_historyRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.hereditary_family_historyKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _hereditary_family_history_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _hereditary_family_history_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _hereditary_family_history_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _hereditary_family_history_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _hereditary_family_history_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _hereditary_family_history_relational_fields:
                        raise errors.UnknownRelationalFieldError('hereditary_family_history', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid hereditary_family_history / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'hereditary_family_history',
            }
        )
        _created_partial_types.add(name)


class lab_results(bases.Baselab_results):
    """Represents a lab_results record"""

    id: _int
    patient_id: _str
    erythrocytes: Optional[_float] = None
    hematocrit: Optional[_float] = None
    hemoglobin: Optional[_float] = None
    leukocytes: Optional[_float] = None
    platelets: Optional[_float] = None
    reticulocytes: Optional[_float] = None
    blood_urea_nitrogen: Optional[_float] = None
    co2: Optional[_float] = None
    serum_chloride: Optional[_float] = None
    serum_potassium: Optional[_float] = None
    serum_sodium: Optional[_float] = None
    creatinine: Optional[_float] = None
    calcium: Optional[_float] = None
    blood_glucose: Optional[_float] = None
    glucose_result_origin: Optional[_str] = None
    strips_for_diabetes_detection_in_healthy_pregnant_women: Optional[_str] = None
    total_cholesterol: Optional[_float] = None
    vldl_cholesterol: Optional[_float] = None
    ldl_cholesterol: Optional[_float] = None
    hdl_cholesterol: Optional[_float] = None
    triglycerides: Optional[_float] = None
    glycated_hemoglobin: Optional[_float] = None
    hiv_gen3: Optional[_str] = None
    hiv_gen4: Optional[_str] = None
    hepaA_IgG_IgM: Optional[_str] = None
    hepB_AS: Optional[_str] = None
    hepB_CoreAB: Optional[_str] = None
    syphilis_Ab: Optional[_str] = None
    h_pylori_b: Optional[_str] = None
    gonorrhea_Ab: Optional[_str] = None
    chlamydia_Ab: Optional[_str] = None
    elisa_gen3: Optional[_str] = None
    elisa_gen4: Optional[_str] = None
    hiv_viral_load: Optional[_float] = None
    tb_detection: Optional[_str] = None
    tb_rif_resistance: Optional[_str] = None
    hepB_viral_load: Optional[_float] = None
    hepC_viral_load: Optional[_float] = None
    hpv_pcr: Optional[_str] = None
    covid_19_test: Optional[_str] = None
    influenza_test: Optional[_str] = None
    prostate_specific_antigen: Optional[_str] = None
    ekg_kardias: Optional[_str] = None
    urine_leukocytes: Optional[_str] = None
    nitrites: Optional[_str] = None
    urobilinogen: Optional[_str] = None
    proteins: Optional[_str] = None
    ph: Optional[_str] = None
    blood: Optional[_str] = None
    specific_gravity: Optional[_str] = None
    ketones: Optional[_str] = None
    bilirubin: Optional[_str] = None
    glucose: Optional[_str] = None
    laboratory: Optional[_str] = None
    date: Optional[datetime.datetime] = None
    vdrl_quantity: Optional[_float] = None
    vdrl_test_result: Optional[_str] = None
    fasting_glucose_measurement: Optional[_str] = None
    reason: Optional[_str] = None
    pacientes: Optional['models.pacientes'] = None
    lab_results_by_medical_consultation: Optional[List['models.lab_results_by_medical_consultation']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.lab_resultsKeys']] = None,
        exclude: Optional[Iterable['types.lab_resultsKeys']] = None,
        required: Optional[Iterable['types.lab_resultsKeys']] = None,
        optional: Optional[Iterable['types.lab_resultsKeys']] = None,
        relations: Optional[Mapping['types.lab_resultsRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.lab_resultsKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _lab_results_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _lab_results_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _lab_results_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _lab_results_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _lab_results_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _lab_results_relational_fields:
                        raise errors.UnknownRelationalFieldError('lab_results', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid lab_results / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'lab_results',
            }
        )
        _created_partial_types.add(name)


class medical_consultation(bases.Basemedical_consultation):
    """Represents a medical_consultation record"""

    id: _str
    patient_id: _str
    date: datetime.datetime
    notes: Optional[_str] = None
    medical_instructions: Optional[_str] = None
    treatment_plan: Optional[_str] = None
    reason: Optional[_str] = None
    ketosis: Optional[List['models.ketosis']] = None
    lab_requests_and_image: Optional[List['models.lab_requests_and_image']] = None
    lab_results_by_medical_consultation: Optional[List['models.lab_results_by_medical_consultation']] = None
    pacientes: Optional['models.pacientes'] = None
    medical_diagnosis: Optional[List['models.medical_diagnosis']] = None
    medical_prescription: Optional[List['models.medical_prescription']] = None
    medical_procedure: Optional[List['models.medical_procedure']] = None
    phsycal_examination: Optional[List['models.phsycal_examination']] = None
    topographic_exploration: Optional[List['models.topographic_exploration']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.medical_consultationKeys']] = None,
        exclude: Optional[Iterable['types.medical_consultationKeys']] = None,
        required: Optional[Iterable['types.medical_consultationKeys']] = None,
        optional: Optional[Iterable['types.medical_consultationKeys']] = None,
        relations: Optional[Mapping['types.medical_consultationRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.medical_consultationKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _medical_consultation_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _medical_consultation_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _medical_consultation_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _medical_consultation_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _medical_consultation_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _medical_consultation_relational_fields:
                        raise errors.UnknownRelationalFieldError('medical_consultation', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid medical_consultation / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'medical_consultation',
            }
        )
        _created_partial_types.add(name)


class non_pathological_history(bases.Basenon_pathological_history):
    """Represents a non_pathological_history record"""

    id: _int
    patient_id: _str
    physical_activity: Optional[_bool] = None
    smoking: Optional[_bool] = None
    alcoholism: Optional[_bool] = None
    recent_vaccine_or_immunization: Optional[_bool] = None
    others: Optional[_bool] = None
    drugs: Optional[_bool] = None
    pacientes: Optional['models.pacientes'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.non_pathological_historyKeys']] = None,
        exclude: Optional[Iterable['types.non_pathological_historyKeys']] = None,
        required: Optional[Iterable['types.non_pathological_historyKeys']] = None,
        optional: Optional[Iterable['types.non_pathological_historyKeys']] = None,
        relations: Optional[Mapping['types.non_pathological_historyRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.non_pathological_historyKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _non_pathological_history_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _non_pathological_history_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _non_pathological_history_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _non_pathological_history_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _non_pathological_history_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _non_pathological_history_relational_fields:
                        raise errors.UnknownRelationalFieldError('non_pathological_history', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid non_pathological_history / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'non_pathological_history',
            }
        )
        _created_partial_types.add(name)


class nutritional_diet(bases.Basenutritional_diet):
    """Represents a nutritional_diet record"""

    id: _int
    patient_id: _str
    breakfast: Optional[_bool] = None
    snack_in_the_morning: Optional[_bool] = None
    meal: Optional[_bool] = None
    afternoon_snack: Optional[_bool] = None
    dinner: Optional[_bool] = None
    food_prepared_at_home: Optional[_bool] = None
    hunger_satiety: Optional[_bool] = None
    food_preference: Optional[_str] = None
    food_discomfort: Optional[_bool] = None
    medications_supplements: Optional[_bool] = None
    other_diets_carried_out: Optional[_bool] = None
    ideal_weight: Optional[_float] = None
    current_weight_related_condition: Optional[_bool] = None
    history_related_to_weight: Optional[_bool] = None
    liquid_consumption: Optional[_bool] = None
    nutrition_education: Optional[_bool] = None
    others: Optional[_bool] = None
    appetite_level: Optional[_str] = None
    water_glasses: Optional[_str] = None
    pacientes: Optional['models.pacientes'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.nutritional_dietKeys']] = None,
        exclude: Optional[Iterable['types.nutritional_dietKeys']] = None,
        required: Optional[Iterable['types.nutritional_dietKeys']] = None,
        optional: Optional[Iterable['types.nutritional_dietKeys']] = None,
        relations: Optional[Mapping['types.nutritional_dietRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.nutritional_dietKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _nutritional_diet_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _nutritional_diet_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _nutritional_diet_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _nutritional_diet_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _nutritional_diet_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _nutritional_diet_relational_fields:
                        raise errors.UnknownRelationalFieldError('nutritional_diet', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid nutritional_diet / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'nutritional_diet',
            }
        )
        _created_partial_types.add(name)


class obstetric_gynecological_history(bases.Baseobstetric_gynecological_history):
    """Represents a obstetric_gynecological_history record"""

    id: _int
    patient_id: _str
    first_menstruation: Optional[datetime.datetime] = None
    last_menstruation: Optional[datetime.datetime] = None
    menstruation_characteristics: Optional[_str] = None
    pregnancies: Optional[_bool] = None
    cervical_cancer: Optional[_bool] = None
    uterine_cancer: Optional[_bool] = None
    breast_cancer: Optional[_bool] = None
    patients_sexual_activity: Optional[_bool] = None
    hormone_replacement_therapy: Optional[_bool] = None
    others: Optional[_bool] = None
    family_planning_method: Optional[_str] = None
    last_pap_smear: Optional[datetime.datetime] = None
    last_mammography: Optional[datetime.datetime] = None
    pacientes: Optional['models.pacientes'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.obstetric_gynecological_historyKeys']] = None,
        exclude: Optional[Iterable['types.obstetric_gynecological_historyKeys']] = None,
        required: Optional[Iterable['types.obstetric_gynecological_historyKeys']] = None,
        optional: Optional[Iterable['types.obstetric_gynecological_historyKeys']] = None,
        relations: Optional[Mapping['types.obstetric_gynecological_historyRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.obstetric_gynecological_historyKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _obstetric_gynecological_history_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _obstetric_gynecological_history_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _obstetric_gynecological_history_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _obstetric_gynecological_history_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _obstetric_gynecological_history_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _obstetric_gynecological_history_relational_fields:
                        raise errors.UnknownRelationalFieldError('obstetric_gynecological_history', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid obstetric_gynecological_history / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'obstetric_gynecological_history',
            }
        )
        _created_partial_types.add(name)


class pacientes(bases.Basepacientes):
    """Represents a pacientes record"""

    id: _str
    name: _str
    last_name: _str
    birthday: datetime.datetime
    sex: _str
    email: Optional[_str] = None
    phone: Optional[_str] = None
    identification_type: _str
    identification_number: _str
    adress: Optional[_str] = None
    country: Optional[_str] = None
    province: Optional[_str] = None
    city: Optional[_str] = None
    zip_code: Optional[_str] = None
    outer_number: Optional[_str] = None
    internal_number: Optional[_str] = None
    active_medications: Optional[List['models.active_medications']] = None
    configs: Optional[List['models.configs']] = None
    event_patient: Optional[List['models.event_patient']] = None
    hereditary_family_history: Optional[List['models.hereditary_family_history']] = None
    lab_results: Optional[List['models.lab_results']] = None
    medical_consultation: Optional[List['models.medical_consultation']] = None
    non_pathological_history: Optional[List['models.non_pathological_history']] = None
    nutritional_diet: Optional[List['models.nutritional_diet']] = None
    obstetric_gynecological_history: Optional[List['models.obstetric_gynecological_history']] = None
    pathological_history: Optional[List['models.pathological_history']] = None
    patient_by_user: Optional[List['models.patient_by_user']] = None
    perinatal_history: Optional[List['models.perinatal_history']] = None
    postnatal_history: Optional[List['models.postnatal_history']] = None
    psychiatric_history: Optional[List['models.psychiatric_history']] = None
    vaccines: Optional[List['models.vaccines']] = None
    vital_signs: Optional[List['models.vital_signs']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.pacientesKeys']] = None,
        exclude: Optional[Iterable['types.pacientesKeys']] = None,
        required: Optional[Iterable['types.pacientesKeys']] = None,
        optional: Optional[Iterable['types.pacientesKeys']] = None,
        relations: Optional[Mapping['types.pacientesRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.pacientesKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _pacientes_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _pacientes_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _pacientes_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _pacientes_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _pacientes_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _pacientes_relational_fields:
                        raise errors.UnknownRelationalFieldError('pacientes', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid pacientes / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'pacientes',
            }
        )
        _created_partial_types.add(name)


class pathological_history(bases.Basepathological_history):
    """Represents a pathological_history record"""

    id: _int
    patient_id: _str
    previous_hospitalization: Optional[_bool] = None
    previous_surgeries: Optional[_bool] = None
    diabetes: Optional[_bool] = None
    thyroid_diseases: Optional[_bool] = None
    arterial_hypertension: Optional[_bool] = None
    cardiopary: Optional[_bool] = None
    trauma: Optional[_bool] = None
    cancer: Optional[_bool] = None
    tuberculosis: Optional[_bool] = None
    transfusions: Optional[_bool] = None
    respiratory_pathologies: Optional[_bool] = None
    gastrointestinal_pathologies: Optional[_bool] = None
    sexually_transmitted_diseases: Optional[_bool] = None
    chronic_kidney_disease: Optional[_bool] = None
    others: Optional[_bool] = None
    pacientes: Optional['models.pacientes'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.pathological_historyKeys']] = None,
        exclude: Optional[Iterable['types.pathological_historyKeys']] = None,
        required: Optional[Iterable['types.pathological_historyKeys']] = None,
        optional: Optional[Iterable['types.pathological_historyKeys']] = None,
        relations: Optional[Mapping['types.pathological_historyRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.pathological_historyKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _pathological_history_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _pathological_history_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _pathological_history_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _pathological_history_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _pathological_history_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _pathological_history_relational_fields:
                        raise errors.UnknownRelationalFieldError('pathological_history', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid pathological_history / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'pathological_history',
            }
        )
        _created_partial_types.add(name)


class patient_by_user(bases.Basepatient_by_user):
    """Represents a patient_by_user record"""

    id: _str
    user_id: _str
    patient_id: _str
    users: Optional['models.users'] = None
    pacientes: Optional['models.pacientes'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.patient_by_userKeys']] = None,
        exclude: Optional[Iterable['types.patient_by_userKeys']] = None,
        required: Optional[Iterable['types.patient_by_userKeys']] = None,
        optional: Optional[Iterable['types.patient_by_userKeys']] = None,
        relations: Optional[Mapping['types.patient_by_userRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.patient_by_userKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _patient_by_user_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _patient_by_user_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _patient_by_user_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _patient_by_user_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _patient_by_user_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _patient_by_user_relational_fields:
                        raise errors.UnknownRelationalFieldError('patient_by_user', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid patient_by_user / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'patient_by_user',
            }
        )
        _created_partial_types.add(name)


class perinatal_history(bases.Baseperinatal_history):
    """Represents a perinatal_history record"""

    id: _int
    patient_id: _str
    last_menstrual_cycle: Optional[datetime.datetime] = None
    cycle_duration: Optional[_int] = None
    last_contraceptive_method_used: Optional[_str] = None
    assisted_conception: Optional[_bool] = None
    estimated_due_date_based_on_LMP: Optional[datetime.datetime] = None
    EDD: Optional[_str] = None
    pregnancy_notes: Optional[_str] = None
    pacientes: Optional['models.pacientes'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.perinatal_historyKeys']] = None,
        exclude: Optional[Iterable['types.perinatal_historyKeys']] = None,
        required: Optional[Iterable['types.perinatal_historyKeys']] = None,
        optional: Optional[Iterable['types.perinatal_historyKeys']] = None,
        relations: Optional[Mapping['types.perinatal_historyRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.perinatal_historyKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _perinatal_history_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _perinatal_history_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _perinatal_history_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _perinatal_history_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _perinatal_history_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _perinatal_history_relational_fields:
                        raise errors.UnknownRelationalFieldError('perinatal_history', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid perinatal_history / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'perinatal_history',
            }
        )
        _created_partial_types.add(name)


class postnatal_history(bases.Basepostnatal_history):
    """Represents a postnatal_history record"""

    id: _int
    patient_id: _str
    birth_details: Optional[_str] = None
    babys_name: Optional[_str] = None
    birth_weight: Optional[_float] = None
    baby_health: Optional[_str] = None
    baby_feeding: Optional[_str] = None
    emotional_state: Optional[_str] = None
    pacientes: Optional['models.pacientes'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.postnatal_historyKeys']] = None,
        exclude: Optional[Iterable['types.postnatal_historyKeys']] = None,
        required: Optional[Iterable['types.postnatal_historyKeys']] = None,
        optional: Optional[Iterable['types.postnatal_historyKeys']] = None,
        relations: Optional[Mapping['types.postnatal_historyRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.postnatal_historyKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _postnatal_history_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _postnatal_history_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _postnatal_history_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _postnatal_history_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _postnatal_history_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _postnatal_history_relational_fields:
                        raise errors.UnknownRelationalFieldError('postnatal_history', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid postnatal_history / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'postnatal_history',
            }
        )
        _created_partial_types.add(name)


class psychiatric_history(bases.Basepsychiatric_history):
    """Represents a psychiatric_history record"""

    id: _int
    patient_id: _str
    family_history: Optional[_str] = None
    disease_awareness: Optional[_bool] = None
    areas_affected_by_the_disease: Optional[_str] = None
    past_and_current_treatments: Optional[_str] = None
    support_from_the_family_or_social_group: Optional[_bool] = None
    patients_family_group: Optional[_str] = None
    aspects_of_social_life: Optional[_str] = None
    aspects_of_working_life: Optional[_str] = None
    relationship_with_authority: Optional[_str] = None
    impulse_control: Optional[_bool] = None
    managing_frustration: Optional[_bool] = None
    pacientes: Optional['models.pacientes'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.psychiatric_historyKeys']] = None,
        exclude: Optional[Iterable['types.psychiatric_historyKeys']] = None,
        required: Optional[Iterable['types.psychiatric_historyKeys']] = None,
        optional: Optional[Iterable['types.psychiatric_historyKeys']] = None,
        relations: Optional[Mapping['types.psychiatric_historyRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.psychiatric_historyKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _psychiatric_history_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _psychiatric_history_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _psychiatric_history_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _psychiatric_history_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _psychiatric_history_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _psychiatric_history_relational_fields:
                        raise errors.UnknownRelationalFieldError('psychiatric_history', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid psychiatric_history / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'psychiatric_history',
            }
        )
        _created_partial_types.add(name)


class users(bases.Baseusers):
    """Represents a users record"""

    id: _str
    email: _str
    password: _str
    configs: Optional[List['models.configs']] = None
    events: Optional[List['models.events']] = None
    patient_by_user: Optional[List['models.patient_by_user']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.usersKeys']] = None,
        exclude: Optional[Iterable['types.usersKeys']] = None,
        required: Optional[Iterable['types.usersKeys']] = None,
        optional: Optional[Iterable['types.usersKeys']] = None,
        relations: Optional[Mapping['types.usersRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.usersKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _users_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _users_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _users_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _users_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _users_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _users_relational_fields:
                        raise errors.UnknownRelationalFieldError('users', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid users / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'users',
            }
        )
        _created_partial_types.add(name)


class vaccines(bases.Basevaccines):
    """Represents a vaccines record"""

    id: _int
    patient_id: _str
    application_date: Optional[datetime.datetime] = None
    next_dose: Optional[datetime.datetime] = None
    batch: Optional[_str] = None
    notes: Optional[_str] = None
    name: Optional[_str] = None
    pacientes: Optional['models.pacientes'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.vaccinesKeys']] = None,
        exclude: Optional[Iterable['types.vaccinesKeys']] = None,
        required: Optional[Iterable['types.vaccinesKeys']] = None,
        optional: Optional[Iterable['types.vaccinesKeys']] = None,
        relations: Optional[Mapping['types.vaccinesRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.vaccinesKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _vaccines_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _vaccines_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _vaccines_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _vaccines_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _vaccines_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _vaccines_relational_fields:
                        raise errors.UnknownRelationalFieldError('vaccines', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid vaccines / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'vaccines',
            }
        )
        _created_partial_types.add(name)


class vital_signs(bases.Basevital_signs):
    """Represents a vital_signs record"""

    id: _int
    patient_id: _str
    stature: Optional[_float] = None
    weight: Optional[_float] = None
    body_mass: Optional[_float] = None
    temperature: Optional[_float] = None
    respiratory_rate: Optional[_float] = None
    systolic: Optional[_float] = None
    diastolic: Optional[_float] = None
    heart_rate: Optional[_float] = None
    body_fat_percentage: Optional[_float] = None
    muscle_mass: Optional[_float] = None
    head_circumference: Optional[_float] = None
    oxygen_saturation: Optional[_float] = None
    water_percentage: Optional[_float] = None
    visceral_fat_percentage: Optional[_float] = None
    bones: Optional[_float] = None
    metabolism: Optional[_float] = None
    protein_percentage: Optional[_float] = None
    body_age: Optional[_float] = None
    abdominal_perimeter: Optional[_float] = None
    pacientes: Optional['models.pacientes'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.vital_signsKeys']] = None,
        exclude: Optional[Iterable['types.vital_signsKeys']] = None,
        required: Optional[Iterable['types.vital_signsKeys']] = None,
        optional: Optional[Iterable['types.vital_signsKeys']] = None,
        relations: Optional[Mapping['types.vital_signsRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.vital_signsKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _vital_signs_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _vital_signs_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _vital_signs_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _vital_signs_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _vital_signs_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _vital_signs_relational_fields:
                        raise errors.UnknownRelationalFieldError('vital_signs', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid vital_signs / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'vital_signs',
            }
        )
        _created_partial_types.add(name)


class ketosis(bases.Baseketosis):
    """This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
    """

    id: _int
    medical_consultation_id: _str
    satiety: Optional[_int] = None
    cramps: Optional[_int] = None
    diarrhea: Optional[_int] = None
    depressed: Optional[_int] = None
    tolerance: Optional[_int] = None
    constipation: Optional[_int] = None
    dizziness: Optional[_int] = None
    anxiety: Optional[_int] = None
    irritability: Optional[_int] = None
    impulse_control: Optional[_int] = None
    bad_breath: Optional[_int] = None
    hunger: Optional[_int] = None
    sleep_problems: Optional[_int] = None
    impatience: Optional[_int] = None
    need_for_stimulants: Optional[_int] = None
    migraine_or_headache: Optional[_int] = None
    fatigue: Optional[_int] = None
    concentration: Optional[_int] = None
    aggressiveness: Optional[_int] = None
    medical_consultation: Optional['models.medical_consultation'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.ketosisKeys']] = None,
        exclude: Optional[Iterable['types.ketosisKeys']] = None,
        required: Optional[Iterable['types.ketosisKeys']] = None,
        optional: Optional[Iterable['types.ketosisKeys']] = None,
        relations: Optional[Mapping['types.ketosisRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.ketosisKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _ketosis_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _ketosis_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _ketosis_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _ketosis_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _ketosis_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _ketosis_relational_fields:
                        raise errors.UnknownRelationalFieldError('ketosis', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid ketosis / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'ketosis',
            }
        )
        _created_partial_types.add(name)


class lab_requests_and_image(bases.Baselab_requests_and_image):
    """Represents a lab_requests_and_image record"""

    id: _int
    medical_consultation_id: _str
    name: _str
    notes: Optional[_str] = None
    medical_consultation: Optional['models.medical_consultation'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.lab_requests_and_imageKeys']] = None,
        exclude: Optional[Iterable['types.lab_requests_and_imageKeys']] = None,
        required: Optional[Iterable['types.lab_requests_and_imageKeys']] = None,
        optional: Optional[Iterable['types.lab_requests_and_imageKeys']] = None,
        relations: Optional[Mapping['types.lab_requests_and_imageRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.lab_requests_and_imageKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _lab_requests_and_image_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _lab_requests_and_image_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _lab_requests_and_image_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _lab_requests_and_image_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _lab_requests_and_image_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _lab_requests_and_image_relational_fields:
                        raise errors.UnknownRelationalFieldError('lab_requests_and_image', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid lab_requests_and_image / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'lab_requests_and_image',
            }
        )
        _created_partial_types.add(name)


class medical_diagnosis(bases.Basemedical_diagnosis):
    """Represents a medical_diagnosis record"""

    id: _int
    medical_consultation_id: _str
    code: Optional[_str] = None
    description: Optional[_str] = None
    notes: Optional[_str] = None
    medical_consultation: Optional['models.medical_consultation'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.medical_diagnosisKeys']] = None,
        exclude: Optional[Iterable['types.medical_diagnosisKeys']] = None,
        required: Optional[Iterable['types.medical_diagnosisKeys']] = None,
        optional: Optional[Iterable['types.medical_diagnosisKeys']] = None,
        relations: Optional[Mapping['types.medical_diagnosisRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.medical_diagnosisKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _medical_diagnosis_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _medical_diagnosis_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _medical_diagnosis_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _medical_diagnosis_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _medical_diagnosis_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _medical_diagnosis_relational_fields:
                        raise errors.UnknownRelationalFieldError('medical_diagnosis', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid medical_diagnosis / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'medical_diagnosis',
            }
        )
        _created_partial_types.add(name)


class medical_prescription(bases.Basemedical_prescription):
    """Represents a medical_prescription record"""

    id: _int
    medical_consultation_id: _str
    medical_instructions: Optional[_str] = None
    medical_consultation: Optional['models.medical_consultation'] = None
    medical_prescription_detail: Optional[List['models.medical_prescription_detail']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.medical_prescriptionKeys']] = None,
        exclude: Optional[Iterable['types.medical_prescriptionKeys']] = None,
        required: Optional[Iterable['types.medical_prescriptionKeys']] = None,
        optional: Optional[Iterable['types.medical_prescriptionKeys']] = None,
        relations: Optional[Mapping['types.medical_prescriptionRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.medical_prescriptionKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _medical_prescription_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _medical_prescription_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _medical_prescription_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _medical_prescription_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _medical_prescription_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _medical_prescription_relational_fields:
                        raise errors.UnknownRelationalFieldError('medical_prescription', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid medical_prescription / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'medical_prescription',
            }
        )
        _created_partial_types.add(name)


class medical_prescription_detail(bases.Basemedical_prescription_detail):
    """Represents a medical_prescription_detail record"""

    id: _int
    medical_prescription_id: _int
    name: _str
    dose: Optional[_str] = None
    frequency: Optional[_str] = None
    duration_of_treatment: Optional[_str] = None
    medical_prescription: Optional['models.medical_prescription'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.medical_prescription_detailKeys']] = None,
        exclude: Optional[Iterable['types.medical_prescription_detailKeys']] = None,
        required: Optional[Iterable['types.medical_prescription_detailKeys']] = None,
        optional: Optional[Iterable['types.medical_prescription_detailKeys']] = None,
        relations: Optional[Mapping['types.medical_prescription_detailRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.medical_prescription_detailKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _medical_prescription_detail_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _medical_prescription_detail_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _medical_prescription_detail_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _medical_prescription_detail_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _medical_prescription_detail_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _medical_prescription_detail_relational_fields:
                        raise errors.UnknownRelationalFieldError('medical_prescription_detail', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid medical_prescription_detail / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'medical_prescription_detail',
            }
        )
        _created_partial_types.add(name)


class medical_procedure(bases.Basemedical_procedure):
    """Represents a medical_procedure record"""

    id: _int
    medical_consultation_id: _str
    name: _str
    notes: Optional[_str] = None
    medical_consultation: Optional['models.medical_consultation'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.medical_procedureKeys']] = None,
        exclude: Optional[Iterable['types.medical_procedureKeys']] = None,
        required: Optional[Iterable['types.medical_procedureKeys']] = None,
        optional: Optional[Iterable['types.medical_procedureKeys']] = None,
        relations: Optional[Mapping['types.medical_procedureRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.medical_procedureKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _medical_procedure_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _medical_procedure_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _medical_procedure_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _medical_procedure_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _medical_procedure_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _medical_procedure_relational_fields:
                        raise errors.UnknownRelationalFieldError('medical_procedure', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid medical_procedure / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'medical_procedure',
            }
        )
        _created_partial_types.add(name)


class phsycal_examination(bases.Basephsycal_examination):
    """Represents a phsycal_examination record"""

    id: _int
    medical_consultation_id: _str
    digestive_system: Optional[_str] = None
    reproductive_system: Optional[_str] = None
    urinary_system: Optional[_str] = None
    cardiac_and_vascular: Optional[_str] = None
    dental: Optional[_str] = None
    dermatological: Optional[_str] = None
    neurological: Optional[_str] = None
    osteoarticular: Optional[_str] = None
    otolaryngologist: Optional[_str] = None
    psychiatric_and_psychological: Optional[_str] = None
    pulmonary_or_respiratory: Optional[_str] = None
    lymphatic_system: Optional[_str] = None
    medical_consultation: Optional['models.medical_consultation'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.phsycal_examinationKeys']] = None,
        exclude: Optional[Iterable['types.phsycal_examinationKeys']] = None,
        required: Optional[Iterable['types.phsycal_examinationKeys']] = None,
        optional: Optional[Iterable['types.phsycal_examinationKeys']] = None,
        relations: Optional[Mapping['types.phsycal_examinationRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.phsycal_examinationKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _phsycal_examination_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _phsycal_examination_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _phsycal_examination_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _phsycal_examination_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _phsycal_examination_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _phsycal_examination_relational_fields:
                        raise errors.UnknownRelationalFieldError('phsycal_examination', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid phsycal_examination / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'phsycal_examination',
            }
        )
        _created_partial_types.add(name)


class topographic_exploration(bases.Basetopographic_exploration):
    """Represents a topographic_exploration record"""

    id: _int
    medical_consultation_id: _str
    head_front_part: Optional[_str] = None
    head_back_part: Optional[_str] = None
    neck_front_part: Optional[_str] = None
    neck_back_part: Optional[_str] = None
    upper_limb_left_front_part: Optional[_str] = None
    upper_limb_left_back_part: Optional[_str] = None
    upper_limb_right_front_part: Optional[_str] = None
    upper_limb_right_back_part: Optional[_str] = None
    trunk_front_part: Optional[_str] = None
    trunk_back_part: Optional[_str] = None
    lower_limb_left_front_part: Optional[_str] = None
    lower_limb_left_back_part: Optional[_str] = None
    lower_limb_right_front_part: Optional[_str] = None
    lower_limb_right_back_part: Optional[_str] = None
    pelvic_area_front: Optional[_str] = None
    pelvic_area_back: Optional[_str] = None
    medical_consultation: Optional['models.medical_consultation'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.topographic_explorationKeys']] = None,
        exclude: Optional[Iterable['types.topographic_explorationKeys']] = None,
        required: Optional[Iterable['types.topographic_explorationKeys']] = None,
        optional: Optional[Iterable['types.topographic_explorationKeys']] = None,
        relations: Optional[Mapping['types.topographic_explorationRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.topographic_explorationKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _topographic_exploration_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _topographic_exploration_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _topographic_exploration_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _topographic_exploration_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _topographic_exploration_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _topographic_exploration_relational_fields:
                        raise errors.UnknownRelationalFieldError('topographic_exploration', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid topographic_exploration / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'topographic_exploration',
            }
        )
        _created_partial_types.add(name)


class lab_results_by_medical_consultation(bases.Baselab_results_by_medical_consultation):
    """Represents a lab_results_by_medical_consultation record"""

    id: _int
    lab_result_id: _int
    medical_consultation_id: _str
    lab_results: Optional['models.lab_results'] = None
    medical_consultation: Optional['models.medical_consultation'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.lab_results_by_medical_consultationKeys']] = None,
        exclude: Optional[Iterable['types.lab_results_by_medical_consultationKeys']] = None,
        required: Optional[Iterable['types.lab_results_by_medical_consultationKeys']] = None,
        optional: Optional[Iterable['types.lab_results_by_medical_consultationKeys']] = None,
        relations: Optional[Mapping['types.lab_results_by_medical_consultationRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.lab_results_by_medical_consultationKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _lab_results_by_medical_consultation_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _lab_results_by_medical_consultation_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _lab_results_by_medical_consultation_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _lab_results_by_medical_consultation_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _lab_results_by_medical_consultation_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _lab_results_by_medical_consultation_relational_fields:
                        raise errors.UnknownRelationalFieldError('lab_results_by_medical_consultation', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid lab_results_by_medical_consultation / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'lab_results_by_medical_consultation',
            }
        )
        _created_partial_types.add(name)


class event_patient(bases.Baseevent_patient):
    """Represents a event_patient record"""

    id: _int
    event_id: _str
    patient_id: _str
    events: Optional['models.events'] = None
    pacientes: Optional['models.pacientes'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.event_patientKeys']] = None,
        exclude: Optional[Iterable['types.event_patientKeys']] = None,
        required: Optional[Iterable['types.event_patientKeys']] = None,
        optional: Optional[Iterable['types.event_patientKeys']] = None,
        relations: Optional[Mapping['types.event_patientRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.event_patientKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _event_patient_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _event_patient_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _event_patient_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _event_patient_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _event_patient_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _event_patient_relational_fields:
                        raise errors.UnknownRelationalFieldError('event_patient', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid event_patient / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'event_patient',
            }
        )
        _created_partial_types.add(name)


class event_prospective_patient(bases.Baseevent_prospective_patient):
    """Represents a event_prospective_patient record"""

    id: _int
    event_id: _str
    prospective_patient_id: _int
    events: Optional['models.events'] = None
    prospective_patients: Optional['models.prospective_patients'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.event_prospective_patientKeys']] = None,
        exclude: Optional[Iterable['types.event_prospective_patientKeys']] = None,
        required: Optional[Iterable['types.event_prospective_patientKeys']] = None,
        optional: Optional[Iterable['types.event_prospective_patientKeys']] = None,
        relations: Optional[Mapping['types.event_prospective_patientRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.event_prospective_patientKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _event_prospective_patient_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _event_prospective_patient_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _event_prospective_patient_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _event_prospective_patient_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _event_prospective_patient_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _event_prospective_patient_relational_fields:
                        raise errors.UnknownRelationalFieldError('event_prospective_patient', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid event_prospective_patient / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'event_prospective_patient',
            }
        )
        _created_partial_types.add(name)


class events(bases.Baseevents):
    """Represents a events record"""

    id: _str
    user_id: _str
    asocciate_patient: Optional[_bool] = None
    date: datetime.datetime
    hour: Optional[datetime.datetime] = None
    event_patient: Optional[List['models.event_patient']] = None
    event_prospective_patient: Optional[List['models.event_prospective_patient']] = None
    users: Optional['models.users'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.eventsKeys']] = None,
        exclude: Optional[Iterable['types.eventsKeys']] = None,
        required: Optional[Iterable['types.eventsKeys']] = None,
        optional: Optional[Iterable['types.eventsKeys']] = None,
        relations: Optional[Mapping['types.eventsRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.eventsKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _events_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _events_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _events_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _events_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _events_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _events_relational_fields:
                        raise errors.UnknownRelationalFieldError('events', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid events / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'events',
            }
        )
        _created_partial_types.add(name)


class prospective_patients(bases.Baseprospective_patients):
    """Represents a prospective_patients record"""

    id: _int
    name: _str
    last_name: Optional[_str] = None
    contact_number: Optional[_str] = None
    email: Optional[_str] = None
    event_prospective_patient: Optional[List['models.event_prospective_patient']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.prospective_patientsKeys']] = None,
        exclude: Optional[Iterable['types.prospective_patientsKeys']] = None,
        required: Optional[Iterable['types.prospective_patientsKeys']] = None,
        optional: Optional[Iterable['types.prospective_patientsKeys']] = None,
        relations: Optional[Mapping['types.prospective_patientsRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.prospective_patientsKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _prospective_patients_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _prospective_patients_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _prospective_patients_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _prospective_patients_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _prospective_patients_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _prospective_patients_relational_fields:
                        raise errors.UnknownRelationalFieldError('prospective_patients', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid prospective_patients / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'prospective_patients',
            }
        )
        _created_partial_types.add(name)



_active_medications_relational_fields: Set[str] = {
        'pacientes',
    }
_active_medications_fields: Dict['types.active_medicationsKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('patient_id', {
            'name': 'patient_id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('dose', {
            'name': 'dose',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('dose_measurement', {
            'name': 'dose_measurement',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('frequency', {
            'name': 'frequency',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('administration_route', {
            'name': 'administration_route',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('start_date', {
            'name': 'start_date',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('end_date', {
            'name': 'end_date',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('duration_of_treatment', {
            'name': 'duration_of_treatment',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('duration_of_treatment_measurement', {
            'name': 'duration_of_treatment_measurement',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('indications', {
            'name': 'indications',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('side_effects', {
            'name': 'side_effects',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('medication_status', {
            'name': 'medication_status',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('notes', {
            'name': 'notes',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('pacientes', {
            'name': 'pacientes',
            'is_list': False,
            'optional': True,
            'type': 'models.pacientes',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_configs_relational_fields: Set[str] = {
        'pacientes',
        'users',
    }
_configs_fields: Dict['types.configsKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('patient_id', {
            'name': 'patient_id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('user_id', {
            'name': 'user_id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('stature', {
            'name': 'stature',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('show_weight', {
            'name': 'show_weight',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('show_body_mass', {
            'name': 'show_body_mass',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('show_temperature', {
            'name': 'show_temperature',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('show_respiratory_rate', {
            'name': 'show_respiratory_rate',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('show_systolic', {
            'name': 'show_systolic',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('show_diastolic', {
            'name': 'show_diastolic',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('show_heart_rate', {
            'name': 'show_heart_rate',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('show_body_fat_percentage', {
            'name': 'show_body_fat_percentage',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('show_muscle_mass', {
            'name': 'show_muscle_mass',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('show_head_circumference', {
            'name': 'show_head_circumference',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('show_oxygen_saturation', {
            'name': 'show_oxygen_saturation',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('show_water_percentage', {
            'name': 'show_water_percentage',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('show_visceral_fat_percentage', {
            'name': 'show_visceral_fat_percentage',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('show_bones', {
            'name': 'show_bones',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('show_metabolism', {
            'name': 'show_metabolism',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('show_protein_percentage', {
            'name': 'show_protein_percentage',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('show_body_age', {
            'name': 'show_body_age',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('show_abdominal_perimeter', {
            'name': 'show_abdominal_perimeter',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('pacientes', {
            'name': 'pacientes',
            'is_list': False,
            'optional': True,
            'type': 'models.pacientes',
            'is_relational': True,
            'documentation': None,
        }),
        ('users', {
            'name': 'users',
            'is_list': False,
            'optional': True,
            'type': 'models.users',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_hereditary_family_history_relational_fields: Set[str] = {
        'pacientes',
    }
_hereditary_family_history_fields: Dict['types.hereditary_family_historyKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('patient_id', {
            'name': 'patient_id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('diabetes', {
            'name': 'diabetes',
            'is_list': False,
            'optional': True,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('heart_disease', {
            'name': 'heart_disease',
            'is_list': False,
            'optional': True,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('arterial_hypertension', {
            'name': 'arterial_hypertension',
            'is_list': False,
            'optional': True,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('thyroid_diseases', {
            'name': 'thyroid_diseases',
            'is_list': False,
            'optional': True,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('chronic_kidney_disease', {
            'name': 'chronic_kidney_disease',
            'is_list': False,
            'optional': True,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('others', {
            'name': 'others',
            'is_list': False,
            'optional': True,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('pacientes', {
            'name': 'pacientes',
            'is_list': False,
            'optional': True,
            'type': 'models.pacientes',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_lab_results_relational_fields: Set[str] = {
        'pacientes',
        'lab_results_by_medical_consultation',
    }
_lab_results_fields: Dict['types.lab_resultsKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('patient_id', {
            'name': 'patient_id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('erythrocytes', {
            'name': 'erythrocytes',
            'is_list': False,
            'optional': True,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('hematocrit', {
            'name': 'hematocrit',
            'is_list': False,
            'optional': True,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('hemoglobin', {
            'name': 'hemoglobin',
            'is_list': False,
            'optional': True,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('leukocytes', {
            'name': 'leukocytes',
            'is_list': False,
            'optional': True,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('platelets', {
            'name': 'platelets',
            'is_list': False,
            'optional': True,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('reticulocytes', {
            'name': 'reticulocytes',
            'is_list': False,
            'optional': True,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('blood_urea_nitrogen', {
            'name': 'blood_urea_nitrogen',
            'is_list': False,
            'optional': True,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('co2', {
            'name': 'co2',
            'is_list': False,
            'optional': True,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('serum_chloride', {
            'name': 'serum_chloride',
            'is_list': False,
            'optional': True,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('serum_potassium', {
            'name': 'serum_potassium',
            'is_list': False,
            'optional': True,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('serum_sodium', {
            'name': 'serum_sodium',
            'is_list': False,
            'optional': True,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('creatinine', {
            'name': 'creatinine',
            'is_list': False,
            'optional': True,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('calcium', {
            'name': 'calcium',
            'is_list': False,
            'optional': True,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('blood_glucose', {
            'name': 'blood_glucose',
            'is_list': False,
            'optional': True,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('glucose_result_origin', {
            'name': 'glucose_result_origin',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('strips_for_diabetes_detection_in_healthy_pregnant_women', {
            'name': 'strips_for_diabetes_detection_in_healthy_pregnant_women',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('total_cholesterol', {
            'name': 'total_cholesterol',
            'is_list': False,
            'optional': True,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('vldl_cholesterol', {
            'name': 'vldl_cholesterol',
            'is_list': False,
            'optional': True,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('ldl_cholesterol', {
            'name': 'ldl_cholesterol',
            'is_list': False,
            'optional': True,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('hdl_cholesterol', {
            'name': 'hdl_cholesterol',
            'is_list': False,
            'optional': True,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('triglycerides', {
            'name': 'triglycerides',
            'is_list': False,
            'optional': True,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('glycated_hemoglobin', {
            'name': 'glycated_hemoglobin',
            'is_list': False,
            'optional': True,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('hiv_gen3', {
            'name': 'hiv_gen3',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('hiv_gen4', {
            'name': 'hiv_gen4',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('hepaA_IgG_IgM', {
            'name': 'hepaA_IgG_IgM',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('hepB_AS', {
            'name': 'hepB_AS',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('hepB_CoreAB', {
            'name': 'hepB_CoreAB',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('syphilis_Ab', {
            'name': 'syphilis_Ab',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('h_pylori_b', {
            'name': 'h_pylori_b',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('gonorrhea_Ab', {
            'name': 'gonorrhea_Ab',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('chlamydia_Ab', {
            'name': 'chlamydia_Ab',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('elisa_gen3', {
            'name': 'elisa_gen3',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('elisa_gen4', {
            'name': 'elisa_gen4',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('hiv_viral_load', {
            'name': 'hiv_viral_load',
            'is_list': False,
            'optional': True,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('tb_detection', {
            'name': 'tb_detection',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('tb_rif_resistance', {
            'name': 'tb_rif_resistance',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('hepB_viral_load', {
            'name': 'hepB_viral_load',
            'is_list': False,
            'optional': True,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('hepC_viral_load', {
            'name': 'hepC_viral_load',
            'is_list': False,
            'optional': True,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('hpv_pcr', {
            'name': 'hpv_pcr',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('covid_19_test', {
            'name': 'covid_19_test',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('influenza_test', {
            'name': 'influenza_test',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('prostate_specific_antigen', {
            'name': 'prostate_specific_antigen',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('ekg_kardias', {
            'name': 'ekg_kardias',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('urine_leukocytes', {
            'name': 'urine_leukocytes',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('nitrites', {
            'name': 'nitrites',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('urobilinogen', {
            'name': 'urobilinogen',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('proteins', {
            'name': 'proteins',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('ph', {
            'name': 'ph',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('blood', {
            'name': 'blood',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('specific_gravity', {
            'name': 'specific_gravity',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('ketones', {
            'name': 'ketones',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('bilirubin', {
            'name': 'bilirubin',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('glucose', {
            'name': 'glucose',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('laboratory', {
            'name': 'laboratory',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('date', {
            'name': 'date',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('vdrl_quantity', {
            'name': 'vdrl_quantity',
            'is_list': False,
            'optional': True,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('vdrl_test_result', {
            'name': 'vdrl_test_result',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('fasting_glucose_measurement', {
            'name': 'fasting_glucose_measurement',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('reason', {
            'name': 'reason',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('pacientes', {
            'name': 'pacientes',
            'is_list': False,
            'optional': True,
            'type': 'models.pacientes',
            'is_relational': True,
            'documentation': None,
        }),
        ('lab_results_by_medical_consultation', {
            'name': 'lab_results_by_medical_consultation',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.lab_results_by_medical_consultation\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_medical_consultation_relational_fields: Set[str] = {
        'ketosis',
        'lab_requests_and_image',
        'lab_results_by_medical_consultation',
        'pacientes',
        'medical_diagnosis',
        'medical_prescription',
        'medical_procedure',
        'phsycal_examination',
        'topographic_exploration',
    }
_medical_consultation_fields: Dict['types.medical_consultationKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('patient_id', {
            'name': 'patient_id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('date', {
            'name': 'date',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('notes', {
            'name': 'notes',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('medical_instructions', {
            'name': 'medical_instructions',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('treatment_plan', {
            'name': 'treatment_plan',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('reason', {
            'name': 'reason',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('ketosis', {
            'name': 'ketosis',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.ketosis\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('lab_requests_and_image', {
            'name': 'lab_requests_and_image',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.lab_requests_and_image\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('lab_results_by_medical_consultation', {
            'name': 'lab_results_by_medical_consultation',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.lab_results_by_medical_consultation\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('pacientes', {
            'name': 'pacientes',
            'is_list': False,
            'optional': True,
            'type': 'models.pacientes',
            'is_relational': True,
            'documentation': None,
        }),
        ('medical_diagnosis', {
            'name': 'medical_diagnosis',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.medical_diagnosis\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('medical_prescription', {
            'name': 'medical_prescription',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.medical_prescription\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('medical_procedure', {
            'name': 'medical_procedure',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.medical_procedure\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('phsycal_examination', {
            'name': 'phsycal_examination',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.phsycal_examination\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('topographic_exploration', {
            'name': 'topographic_exploration',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.topographic_exploration\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_non_pathological_history_relational_fields: Set[str] = {
        'pacientes',
    }
_non_pathological_history_fields: Dict['types.non_pathological_historyKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('patient_id', {
            'name': 'patient_id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('physical_activity', {
            'name': 'physical_activity',
            'is_list': False,
            'optional': True,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('smoking', {
            'name': 'smoking',
            'is_list': False,
            'optional': True,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('alcoholism', {
            'name': 'alcoholism',
            'is_list': False,
            'optional': True,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('recent_vaccine_or_immunization', {
            'name': 'recent_vaccine_or_immunization',
            'is_list': False,
            'optional': True,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('others', {
            'name': 'others',
            'is_list': False,
            'optional': True,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('drugs', {
            'name': 'drugs',
            'is_list': False,
            'optional': True,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('pacientes', {
            'name': 'pacientes',
            'is_list': False,
            'optional': True,
            'type': 'models.pacientes',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_nutritional_diet_relational_fields: Set[str] = {
        'pacientes',
    }
_nutritional_diet_fields: Dict['types.nutritional_dietKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('patient_id', {
            'name': 'patient_id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('breakfast', {
            'name': 'breakfast',
            'is_list': False,
            'optional': True,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('snack_in_the_morning', {
            'name': 'snack_in_the_morning',
            'is_list': False,
            'optional': True,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('meal', {
            'name': 'meal',
            'is_list': False,
            'optional': True,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('afternoon_snack', {
            'name': 'afternoon_snack',
            'is_list': False,
            'optional': True,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('dinner', {
            'name': 'dinner',
            'is_list': False,
            'optional': True,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('food_prepared_at_home', {
            'name': 'food_prepared_at_home',
            'is_list': False,
            'optional': True,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('hunger_satiety', {
            'name': 'hunger_satiety',
            'is_list': False,
            'optional': True,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('food_preference', {
            'name': 'food_preference',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('food_discomfort', {
            'name': 'food_discomfort',
            'is_list': False,
            'optional': True,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('medications_supplements', {
            'name': 'medications_supplements',
            'is_list': False,
            'optional': True,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('other_diets_carried_out', {
            'name': 'other_diets_carried_out',
            'is_list': False,
            'optional': True,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('ideal_weight', {
            'name': 'ideal_weight',
            'is_list': False,
            'optional': True,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('current_weight_related_condition', {
            'name': 'current_weight_related_condition',
            'is_list': False,
            'optional': True,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('history_related_to_weight', {
            'name': 'history_related_to_weight',
            'is_list': False,
            'optional': True,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('liquid_consumption', {
            'name': 'liquid_consumption',
            'is_list': False,
            'optional': True,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('nutrition_education', {
            'name': 'nutrition_education',
            'is_list': False,
            'optional': True,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('others', {
            'name': 'others',
            'is_list': False,
            'optional': True,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('appetite_level', {
            'name': 'appetite_level',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('water_glasses', {
            'name': 'water_glasses',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('pacientes', {
            'name': 'pacientes',
            'is_list': False,
            'optional': True,
            'type': 'models.pacientes',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_obstetric_gynecological_history_relational_fields: Set[str] = {
        'pacientes',
    }
_obstetric_gynecological_history_fields: Dict['types.obstetric_gynecological_historyKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('patient_id', {
            'name': 'patient_id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('first_menstruation', {
            'name': 'first_menstruation',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('last_menstruation', {
            'name': 'last_menstruation',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('menstruation_characteristics', {
            'name': 'menstruation_characteristics',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('pregnancies', {
            'name': 'pregnancies',
            'is_list': False,
            'optional': True,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('cervical_cancer', {
            'name': 'cervical_cancer',
            'is_list': False,
            'optional': True,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('uterine_cancer', {
            'name': 'uterine_cancer',
            'is_list': False,
            'optional': True,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('breast_cancer', {
            'name': 'breast_cancer',
            'is_list': False,
            'optional': True,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('patients_sexual_activity', {
            'name': 'patients_sexual_activity',
            'is_list': False,
            'optional': True,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('hormone_replacement_therapy', {
            'name': 'hormone_replacement_therapy',
            'is_list': False,
            'optional': True,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('others', {
            'name': 'others',
            'is_list': False,
            'optional': True,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('family_planning_method', {
            'name': 'family_planning_method',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('last_pap_smear', {
            'name': 'last_pap_smear',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('last_mammography', {
            'name': 'last_mammography',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('pacientes', {
            'name': 'pacientes',
            'is_list': False,
            'optional': True,
            'type': 'models.pacientes',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_pacientes_relational_fields: Set[str] = {
        'active_medications',
        'configs',
        'event_patient',
        'hereditary_family_history',
        'lab_results',
        'medical_consultation',
        'non_pathological_history',
        'nutritional_diet',
        'obstetric_gynecological_history',
        'pathological_history',
        'patient_by_user',
        'perinatal_history',
        'postnatal_history',
        'psychiatric_history',
        'vaccines',
        'vital_signs',
    }
_pacientes_fields: Dict['types.pacientesKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('last_name', {
            'name': 'last_name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('birthday', {
            'name': 'birthday',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('sex', {
            'name': 'sex',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('email', {
            'name': 'email',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('phone', {
            'name': 'phone',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('identification_type', {
            'name': 'identification_type',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('identification_number', {
            'name': 'identification_number',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('adress', {
            'name': 'adress',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('country', {
            'name': 'country',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('province', {
            'name': 'province',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('city', {
            'name': 'city',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('zip_code', {
            'name': 'zip_code',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('outer_number', {
            'name': 'outer_number',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('internal_number', {
            'name': 'internal_number',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('active_medications', {
            'name': 'active_medications',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.active_medications\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('configs', {
            'name': 'configs',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.configs\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('event_patient', {
            'name': 'event_patient',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.event_patient\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('hereditary_family_history', {
            'name': 'hereditary_family_history',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.hereditary_family_history\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('lab_results', {
            'name': 'lab_results',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.lab_results\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('medical_consultation', {
            'name': 'medical_consultation',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.medical_consultation\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('non_pathological_history', {
            'name': 'non_pathological_history',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.non_pathological_history\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('nutritional_diet', {
            'name': 'nutritional_diet',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.nutritional_diet\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('obstetric_gynecological_history', {
            'name': 'obstetric_gynecological_history',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.obstetric_gynecological_history\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('pathological_history', {
            'name': 'pathological_history',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.pathological_history\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('patient_by_user', {
            'name': 'patient_by_user',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.patient_by_user\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('perinatal_history', {
            'name': 'perinatal_history',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.perinatal_history\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('postnatal_history', {
            'name': 'postnatal_history',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.postnatal_history\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('psychiatric_history', {
            'name': 'psychiatric_history',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.psychiatric_history\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('vaccines', {
            'name': 'vaccines',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.vaccines\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('vital_signs', {
            'name': 'vital_signs',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.vital_signs\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_pathological_history_relational_fields: Set[str] = {
        'pacientes',
    }
_pathological_history_fields: Dict['types.pathological_historyKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('patient_id', {
            'name': 'patient_id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('previous_hospitalization', {
            'name': 'previous_hospitalization',
            'is_list': False,
            'optional': True,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('previous_surgeries', {
            'name': 'previous_surgeries',
            'is_list': False,
            'optional': True,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('diabetes', {
            'name': 'diabetes',
            'is_list': False,
            'optional': True,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('thyroid_diseases', {
            'name': 'thyroid_diseases',
            'is_list': False,
            'optional': True,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('arterial_hypertension', {
            'name': 'arterial_hypertension',
            'is_list': False,
            'optional': True,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('cardiopary', {
            'name': 'cardiopary',
            'is_list': False,
            'optional': True,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('trauma', {
            'name': 'trauma',
            'is_list': False,
            'optional': True,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('cancer', {
            'name': 'cancer',
            'is_list': False,
            'optional': True,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('tuberculosis', {
            'name': 'tuberculosis',
            'is_list': False,
            'optional': True,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('transfusions', {
            'name': 'transfusions',
            'is_list': False,
            'optional': True,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('respiratory_pathologies', {
            'name': 'respiratory_pathologies',
            'is_list': False,
            'optional': True,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('gastrointestinal_pathologies', {
            'name': 'gastrointestinal_pathologies',
            'is_list': False,
            'optional': True,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('sexually_transmitted_diseases', {
            'name': 'sexually_transmitted_diseases',
            'is_list': False,
            'optional': True,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('chronic_kidney_disease', {
            'name': 'chronic_kidney_disease',
            'is_list': False,
            'optional': True,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('others', {
            'name': 'others',
            'is_list': False,
            'optional': True,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('pacientes', {
            'name': 'pacientes',
            'is_list': False,
            'optional': True,
            'type': 'models.pacientes',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_patient_by_user_relational_fields: Set[str] = {
        'users',
        'pacientes',
    }
_patient_by_user_fields: Dict['types.patient_by_userKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('user_id', {
            'name': 'user_id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('patient_id', {
            'name': 'patient_id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('users', {
            'name': 'users',
            'is_list': False,
            'optional': True,
            'type': 'models.users',
            'is_relational': True,
            'documentation': None,
        }),
        ('pacientes', {
            'name': 'pacientes',
            'is_list': False,
            'optional': True,
            'type': 'models.pacientes',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_perinatal_history_relational_fields: Set[str] = {
        'pacientes',
    }
_perinatal_history_fields: Dict['types.perinatal_historyKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('patient_id', {
            'name': 'patient_id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('last_menstrual_cycle', {
            'name': 'last_menstrual_cycle',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('cycle_duration', {
            'name': 'cycle_duration',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('last_contraceptive_method_used', {
            'name': 'last_contraceptive_method_used',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('assisted_conception', {
            'name': 'assisted_conception',
            'is_list': False,
            'optional': True,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('estimated_due_date_based_on_LMP', {
            'name': 'estimated_due_date_based_on_LMP',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('EDD', {
            'name': 'EDD',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('pregnancy_notes', {
            'name': 'pregnancy_notes',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('pacientes', {
            'name': 'pacientes',
            'is_list': False,
            'optional': True,
            'type': 'models.pacientes',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_postnatal_history_relational_fields: Set[str] = {
        'pacientes',
    }
_postnatal_history_fields: Dict['types.postnatal_historyKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('patient_id', {
            'name': 'patient_id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('birth_details', {
            'name': 'birth_details',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('babys_name', {
            'name': 'babys_name',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('birth_weight', {
            'name': 'birth_weight',
            'is_list': False,
            'optional': True,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('baby_health', {
            'name': 'baby_health',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('baby_feeding', {
            'name': 'baby_feeding',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('emotional_state', {
            'name': 'emotional_state',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('pacientes', {
            'name': 'pacientes',
            'is_list': False,
            'optional': True,
            'type': 'models.pacientes',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_psychiatric_history_relational_fields: Set[str] = {
        'pacientes',
    }
_psychiatric_history_fields: Dict['types.psychiatric_historyKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('patient_id', {
            'name': 'patient_id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('family_history', {
            'name': 'family_history',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('disease_awareness', {
            'name': 'disease_awareness',
            'is_list': False,
            'optional': True,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('areas_affected_by_the_disease', {
            'name': 'areas_affected_by_the_disease',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('past_and_current_treatments', {
            'name': 'past_and_current_treatments',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('support_from_the_family_or_social_group', {
            'name': 'support_from_the_family_or_social_group',
            'is_list': False,
            'optional': True,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('patients_family_group', {
            'name': 'patients_family_group',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('aspects_of_social_life', {
            'name': 'aspects_of_social_life',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('aspects_of_working_life', {
            'name': 'aspects_of_working_life',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('relationship_with_authority', {
            'name': 'relationship_with_authority',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('impulse_control', {
            'name': 'impulse_control',
            'is_list': False,
            'optional': True,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('managing_frustration', {
            'name': 'managing_frustration',
            'is_list': False,
            'optional': True,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('pacientes', {
            'name': 'pacientes',
            'is_list': False,
            'optional': True,
            'type': 'models.pacientes',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_users_relational_fields: Set[str] = {
        'configs',
        'events',
        'patient_by_user',
    }
_users_fields: Dict['types.usersKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('email', {
            'name': 'email',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('password', {
            'name': 'password',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('configs', {
            'name': 'configs',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.configs\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('events', {
            'name': 'events',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.events\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('patient_by_user', {
            'name': 'patient_by_user',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.patient_by_user\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_vaccines_relational_fields: Set[str] = {
        'pacientes',
    }
_vaccines_fields: Dict['types.vaccinesKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('patient_id', {
            'name': 'patient_id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('application_date', {
            'name': 'application_date',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('next_dose', {
            'name': 'next_dose',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('batch', {
            'name': 'batch',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('notes', {
            'name': 'notes',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('pacientes', {
            'name': 'pacientes',
            'is_list': False,
            'optional': True,
            'type': 'models.pacientes',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_vital_signs_relational_fields: Set[str] = {
        'pacientes',
    }
_vital_signs_fields: Dict['types.vital_signsKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('patient_id', {
            'name': 'patient_id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('stature', {
            'name': 'stature',
            'is_list': False,
            'optional': True,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('weight', {
            'name': 'weight',
            'is_list': False,
            'optional': True,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('body_mass', {
            'name': 'body_mass',
            'is_list': False,
            'optional': True,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('temperature', {
            'name': 'temperature',
            'is_list': False,
            'optional': True,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('respiratory_rate', {
            'name': 'respiratory_rate',
            'is_list': False,
            'optional': True,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('systolic', {
            'name': 'systolic',
            'is_list': False,
            'optional': True,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('diastolic', {
            'name': 'diastolic',
            'is_list': False,
            'optional': True,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('heart_rate', {
            'name': 'heart_rate',
            'is_list': False,
            'optional': True,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('body_fat_percentage', {
            'name': 'body_fat_percentage',
            'is_list': False,
            'optional': True,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('muscle_mass', {
            'name': 'muscle_mass',
            'is_list': False,
            'optional': True,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('head_circumference', {
            'name': 'head_circumference',
            'is_list': False,
            'optional': True,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('oxygen_saturation', {
            'name': 'oxygen_saturation',
            'is_list': False,
            'optional': True,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('water_percentage', {
            'name': 'water_percentage',
            'is_list': False,
            'optional': True,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('visceral_fat_percentage', {
            'name': 'visceral_fat_percentage',
            'is_list': False,
            'optional': True,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('bones', {
            'name': 'bones',
            'is_list': False,
            'optional': True,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('metabolism', {
            'name': 'metabolism',
            'is_list': False,
            'optional': True,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('protein_percentage', {
            'name': 'protein_percentage',
            'is_list': False,
            'optional': True,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('body_age', {
            'name': 'body_age',
            'is_list': False,
            'optional': True,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('abdominal_perimeter', {
            'name': 'abdominal_perimeter',
            'is_list': False,
            'optional': True,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('pacientes', {
            'name': 'pacientes',
            'is_list': False,
            'optional': True,
            'type': 'models.pacientes',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_ketosis_relational_fields: Set[str] = {
        'medical_consultation',
    }
_ketosis_fields: Dict['types.ketosisKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('medical_consultation_id', {
            'name': 'medical_consultation_id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('satiety', {
            'name': 'satiety',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('cramps', {
            'name': 'cramps',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('diarrhea', {
            'name': 'diarrhea',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('depressed', {
            'name': 'depressed',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('tolerance', {
            'name': 'tolerance',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('constipation', {
            'name': 'constipation',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('dizziness', {
            'name': 'dizziness',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('anxiety', {
            'name': 'anxiety',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('irritability', {
            'name': 'irritability',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('impulse_control', {
            'name': 'impulse_control',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('bad_breath', {
            'name': 'bad_breath',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('hunger', {
            'name': 'hunger',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('sleep_problems', {
            'name': 'sleep_problems',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('impatience', {
            'name': 'impatience',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('need_for_stimulants', {
            'name': 'need_for_stimulants',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('migraine_or_headache', {
            'name': 'migraine_or_headache',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('fatigue', {
            'name': 'fatigue',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('concentration', {
            'name': 'concentration',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('aggressiveness', {
            'name': 'aggressiveness',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('medical_consultation', {
            'name': 'medical_consultation',
            'is_list': False,
            'optional': True,
            'type': 'models.medical_consultation',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_lab_requests_and_image_relational_fields: Set[str] = {
        'medical_consultation',
    }
_lab_requests_and_image_fields: Dict['types.lab_requests_and_imageKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('medical_consultation_id', {
            'name': 'medical_consultation_id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('notes', {
            'name': 'notes',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('medical_consultation', {
            'name': 'medical_consultation',
            'is_list': False,
            'optional': True,
            'type': 'models.medical_consultation',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_medical_diagnosis_relational_fields: Set[str] = {
        'medical_consultation',
    }
_medical_diagnosis_fields: Dict['types.medical_diagnosisKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('medical_consultation_id', {
            'name': 'medical_consultation_id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('code', {
            'name': 'code',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('description', {
            'name': 'description',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('notes', {
            'name': 'notes',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('medical_consultation', {
            'name': 'medical_consultation',
            'is_list': False,
            'optional': True,
            'type': 'models.medical_consultation',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_medical_prescription_relational_fields: Set[str] = {
        'medical_consultation',
        'medical_prescription_detail',
    }
_medical_prescription_fields: Dict['types.medical_prescriptionKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('medical_consultation_id', {
            'name': 'medical_consultation_id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('medical_instructions', {
            'name': 'medical_instructions',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('medical_consultation', {
            'name': 'medical_consultation',
            'is_list': False,
            'optional': True,
            'type': 'models.medical_consultation',
            'is_relational': True,
            'documentation': None,
        }),
        ('medical_prescription_detail', {
            'name': 'medical_prescription_detail',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.medical_prescription_detail\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_medical_prescription_detail_relational_fields: Set[str] = {
        'medical_prescription',
    }
_medical_prescription_detail_fields: Dict['types.medical_prescription_detailKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('medical_prescription_id', {
            'name': 'medical_prescription_id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('dose', {
            'name': 'dose',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('frequency', {
            'name': 'frequency',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('duration_of_treatment', {
            'name': 'duration_of_treatment',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('medical_prescription', {
            'name': 'medical_prescription',
            'is_list': False,
            'optional': True,
            'type': 'models.medical_prescription',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_medical_procedure_relational_fields: Set[str] = {
        'medical_consultation',
    }
_medical_procedure_fields: Dict['types.medical_procedureKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('medical_consultation_id', {
            'name': 'medical_consultation_id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('notes', {
            'name': 'notes',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('medical_consultation', {
            'name': 'medical_consultation',
            'is_list': False,
            'optional': True,
            'type': 'models.medical_consultation',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_phsycal_examination_relational_fields: Set[str] = {
        'medical_consultation',
    }
_phsycal_examination_fields: Dict['types.phsycal_examinationKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('medical_consultation_id', {
            'name': 'medical_consultation_id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('digestive_system', {
            'name': 'digestive_system',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('reproductive_system', {
            'name': 'reproductive_system',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('urinary_system', {
            'name': 'urinary_system',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('cardiac_and_vascular', {
            'name': 'cardiac_and_vascular',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('dental', {
            'name': 'dental',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('dermatological', {
            'name': 'dermatological',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('neurological', {
            'name': 'neurological',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('osteoarticular', {
            'name': 'osteoarticular',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('otolaryngologist', {
            'name': 'otolaryngologist',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('psychiatric_and_psychological', {
            'name': 'psychiatric_and_psychological',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('pulmonary_or_respiratory', {
            'name': 'pulmonary_or_respiratory',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('lymphatic_system', {
            'name': 'lymphatic_system',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('medical_consultation', {
            'name': 'medical_consultation',
            'is_list': False,
            'optional': True,
            'type': 'models.medical_consultation',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_topographic_exploration_relational_fields: Set[str] = {
        'medical_consultation',
    }
_topographic_exploration_fields: Dict['types.topographic_explorationKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('medical_consultation_id', {
            'name': 'medical_consultation_id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('head_front_part', {
            'name': 'head_front_part',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('head_back_part', {
            'name': 'head_back_part',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('neck_front_part', {
            'name': 'neck_front_part',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('neck_back_part', {
            'name': 'neck_back_part',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('upper_limb_left_front_part', {
            'name': 'upper_limb_left_front_part',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('upper_limb_left_back_part', {
            'name': 'upper_limb_left_back_part',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('upper_limb_right_front_part', {
            'name': 'upper_limb_right_front_part',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('upper_limb_right_back_part', {
            'name': 'upper_limb_right_back_part',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('trunk_front_part', {
            'name': 'trunk_front_part',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('trunk_back_part', {
            'name': 'trunk_back_part',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('lower_limb_left_front_part', {
            'name': 'lower_limb_left_front_part',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('lower_limb_left_back_part', {
            'name': 'lower_limb_left_back_part',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('lower_limb_right_front_part', {
            'name': 'lower_limb_right_front_part',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('lower_limb_right_back_part', {
            'name': 'lower_limb_right_back_part',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('pelvic_area_front', {
            'name': 'pelvic_area_front',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('pelvic_area_back', {
            'name': 'pelvic_area_back',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('medical_consultation', {
            'name': 'medical_consultation',
            'is_list': False,
            'optional': True,
            'type': 'models.medical_consultation',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_lab_results_by_medical_consultation_relational_fields: Set[str] = {
        'lab_results',
        'medical_consultation',
    }
_lab_results_by_medical_consultation_fields: Dict['types.lab_results_by_medical_consultationKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('lab_result_id', {
            'name': 'lab_result_id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('medical_consultation_id', {
            'name': 'medical_consultation_id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('lab_results', {
            'name': 'lab_results',
            'is_list': False,
            'optional': True,
            'type': 'models.lab_results',
            'is_relational': True,
            'documentation': None,
        }),
        ('medical_consultation', {
            'name': 'medical_consultation',
            'is_list': False,
            'optional': True,
            'type': 'models.medical_consultation',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_event_patient_relational_fields: Set[str] = {
        'events',
        'pacientes',
    }
_event_patient_fields: Dict['types.event_patientKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('event_id', {
            'name': 'event_id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('patient_id', {
            'name': 'patient_id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('events', {
            'name': 'events',
            'is_list': False,
            'optional': True,
            'type': 'models.events',
            'is_relational': True,
            'documentation': None,
        }),
        ('pacientes', {
            'name': 'pacientes',
            'is_list': False,
            'optional': True,
            'type': 'models.pacientes',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_event_prospective_patient_relational_fields: Set[str] = {
        'events',
        'prospective_patients',
    }
_event_prospective_patient_fields: Dict['types.event_prospective_patientKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('event_id', {
            'name': 'event_id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('prospective_patient_id', {
            'name': 'prospective_patient_id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('events', {
            'name': 'events',
            'is_list': False,
            'optional': True,
            'type': 'models.events',
            'is_relational': True,
            'documentation': None,
        }),
        ('prospective_patients', {
            'name': 'prospective_patients',
            'is_list': False,
            'optional': True,
            'type': 'models.prospective_patients',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_events_relational_fields: Set[str] = {
        'event_patient',
        'event_prospective_patient',
        'users',
    }
_events_fields: Dict['types.eventsKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('user_id', {
            'name': 'user_id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('asocciate_patient', {
            'name': 'asocciate_patient',
            'is_list': False,
            'optional': True,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('date', {
            'name': 'date',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('hour', {
            'name': 'hour',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('event_patient', {
            'name': 'event_patient',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.event_patient\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('event_prospective_patient', {
            'name': 'event_prospective_patient',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.event_prospective_patient\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('users', {
            'name': 'users',
            'is_list': False,
            'optional': True,
            'type': 'models.users',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_prospective_patients_relational_fields: Set[str] = {
        'event_prospective_patient',
    }
_prospective_patients_fields: Dict['types.prospective_patientsKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('last_name', {
            'name': 'last_name',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('contact_number', {
            'name': 'contact_number',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('email', {
            'name': 'email',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('event_prospective_patient', {
            'name': 'event_prospective_patient',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.event_prospective_patient\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)



# we have to import ourselves as relation types are namespaced to models
# e.g. models.Post
from . import models, actions

# required to support relationships between models
model_rebuild(active_medications)
model_rebuild(configs)
model_rebuild(hereditary_family_history)
model_rebuild(lab_results)
model_rebuild(medical_consultation)
model_rebuild(non_pathological_history)
model_rebuild(nutritional_diet)
model_rebuild(obstetric_gynecological_history)
model_rebuild(pacientes)
model_rebuild(pathological_history)
model_rebuild(patient_by_user)
model_rebuild(perinatal_history)
model_rebuild(postnatal_history)
model_rebuild(psychiatric_history)
model_rebuild(users)
model_rebuild(vaccines)
model_rebuild(vital_signs)
model_rebuild(ketosis)
model_rebuild(lab_requests_and_image)
model_rebuild(medical_diagnosis)
model_rebuild(medical_prescription)
model_rebuild(medical_prescription_detail)
model_rebuild(medical_procedure)
model_rebuild(phsycal_examination)
model_rebuild(topographic_exploration)
model_rebuild(lab_results_by_medical_consultation)
model_rebuild(event_patient)
model_rebuild(event_prospective_patient)
model_rebuild(events)
model_rebuild(prospective_patients)
