# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off
from __future__ import annotations

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template actions.py.jinja --
from typing import TypeVar
import warnings

from . import types, errors, bases
from ._compat import model_parse
from ._constants import CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED

if TYPE_CHECKING:
    from .client import Prisma
    from .bases import _PrismaModel


_PrismaModelT = TypeVar('_PrismaModelT', bound='_PrismaModel')


class active_medicationsActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.active_medications]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await active_medications.prisma().query_raw(
            'SELECT * FROM active_medications WHERE id = ?',
            1103527590,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.active_medications
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await active_medications.prisma().query_first(
            'SELECT * FROM active_medications WHERE patient_id = ?',
            'dhheabfhf',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.active_medicationsCreateInput,
        include: Optional[types.active_medicationsInclude] = None
    ) -> _PrismaModelT:
        """Create a new active_medications record.

        Parameters
        ----------
        data
            active_medications record data
        include
            Specifies which relations should be loaded on the returned active_medications model

        Returns
        -------
        prisma.models.active_medications
            The created active_medications record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a active_medications record from just the required fields
        active_medications = await active_medications.prisma().create(
            data={
                # data to create a active_medications record
                'patient_id': 'ggciceaie',
                'name': 'bbehjachib',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.active_medicationsCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple active_medications records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of active_medications record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await active_medications.prisma().create_many(
            data=[
                {
                    # data to create a active_medications record
                    'patient_id': 'cadfabfehe',
                    'name': 'dgiiaaijj',
                },
                {
                    # data to create a active_medications record
                    'patient_id': 'bfaiacjjfc',
                    'name': 'eigcfgbif',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.active_medicationsWhereUniqueInput,
        include: Optional[types.active_medicationsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single active_medications record.

        Parameters
        ----------
        where
            active_medications filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned active_medications model

        Returns
        -------
        prisma.models.active_medications
            The deleted active_medications record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        active_medications = await active_medications.prisma().delete(
            where={
                'id': 1062517886,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.active_medicationsWhereUniqueInput,
        include: Optional[types.active_medicationsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique active_medications record.

        Parameters
        ----------
        where
            active_medications filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned active_medications model

        Returns
        -------
        prisma.models.active_medications
            The found active_medications record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        active_medications = await active_medications.prisma().find_unique(
            where={
                'id': 267834847,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.active_medicationsWhereUniqueInput,
        include: Optional[types.active_medicationsInclude] = None
    ) -> _PrismaModelT:
        """Find a unique active_medications record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            active_medications filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned active_medications model

        Returns
        -------
        prisma.models.active_medications
            The found active_medications record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        active_medications = await active_medications.prisma().find_unique_or_raise(
            where={
                'id': 180171308,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.active_medicationsWhereInput] = None,
        cursor: Optional[types.active_medicationsWhereUniqueInput] = None,
        include: Optional[types.active_medicationsInclude] = None,
        order: Optional[Union[types.active_medicationsOrderByInput, List[types.active_medicationsOrderByInput]]] = None,
        distinct: Optional[List[types.active_medicationsScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple active_medications records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of active_medications records returned
        skip
            Ignore the first N results
        where
            active_medications filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned active_medications model
        order
            Order the returned active_medications records by any field
        distinct
            Filter active_medications records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.active_medications]
            The list of all active_medications records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 active_medications records
        active_medications = await active_medications.prisma().find_many(take=10)

        # find the first 5 active_medications records ordered by the name field
        active_medications = await active_medications.prisma().find_many(
            take=5,
            order={
                'name': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.active_medicationsWhereInput] = None,
        cursor: Optional[types.active_medicationsWhereUniqueInput] = None,
        include: Optional[types.active_medicationsInclude] = None,
        order: Optional[Union[types.active_medicationsOrderByInput, List[types.active_medicationsOrderByInput]]] = None,
        distinct: Optional[List[types.active_medicationsScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single active_medications record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            active_medications filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned active_medications model
        order
            Order the returned active_medications records by any field
        distinct
            Filter active_medications records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.active_medications
            The first active_medications record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second active_medications record ordered by the dose field
        active_medications = await active_medications.prisma().find_first(
            skip=1,
            order={
                'dose': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.active_medicationsWhereInput] = None,
        cursor: Optional[types.active_medicationsWhereUniqueInput] = None,
        include: Optional[types.active_medicationsInclude] = None,
        order: Optional[Union[types.active_medicationsOrderByInput, List[types.active_medicationsOrderByInput]]] = None,
        distinct: Optional[List[types.active_medicationsScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single active_medications record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            active_medications filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned active_medications model
        order
            Order the returned active_medications records by any field
        distinct
            Filter active_medications records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.active_medications
            The first active_medications record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second active_medications record ordered by the dose_measurement field
        active_medications = await active_medications.prisma().find_first_or_raise(
            skip=1,
            order={
                'dose_measurement': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.active_medicationsUpdateInput,
        where: types.active_medicationsWhereUniqueInput,
        include: Optional[types.active_medicationsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single active_medications record.

        Parameters
        ----------
        data
            active_medications record data specifying what to update
        where
            active_medications filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned active_medications model

        Returns
        -------
        prisma.models.active_medications
            The updated active_medications record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        active_medications = await active_medications.prisma().update(
            where={
                'id': 836760821,
            },
            data={
                # data to update the active_medications record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.active_medicationsWhereUniqueInput,
        data: types.active_medicationsUpsertInput,
        include: Optional[types.active_medicationsInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            active_medications filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned active_medications model

        Returns
        -------
        prisma.models.active_medications
            The created or updated active_medications record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        active_medications = await active_medications.prisma().upsert(
            where={
                'id': 595337866,
            },
            data={
                'create': {
                    'id': 595337866,
                    'patient_id': 'bfaiacjjfc',
                    'name': 'eigcfgbif',
                },
                'update': {
                    'patient_id': 'bfaiacjjfc',
                    'name': 'eigcfgbif',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.active_medicationsUpdateManyMutationInput,
        where: types.active_medicationsWhereInput,
    ) -> int:
        """Update multiple active_medications records

        Parameters
        ----------
        data
            active_medications data to update the selected active_medications records to
        where
            Filter to select the active_medications records to update

        Returns
        -------
        int
            The total number of active_medications records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all active_medications records
        total = await active_medications.prisma().update_many(
            data={
                'frequency': 'hjaecfifb'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.active_medicationsWhereInput] = None,
        cursor: Optional[types.active_medicationsWhereUniqueInput] = None,
    ) -> int:
        """Count the number of active_medications records present in the database

        Parameters
        ----------
        select
            Select the active_medications fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            active_medications filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.active_medicationsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await active_medications.prisma().count()

        # results: prisma.types.active_medicationsCountAggregateOutput
        results = await active_medications.prisma().count(
            select={
                '_all': True,
                'administration_route': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.active_medicationsCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.active_medicationsWhereInput] = None,
        cursor: Optional[types.active_medicationsWhereUniqueInput] = None,
    ) -> types.active_medicationsCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.active_medicationsCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.active_medicationsWhereInput] = None,
        cursor: Optional[types.active_medicationsWhereUniqueInput] = None,
    ) -> Union[int, types.active_medicationsCountAggregateOutput]:
        """Count the number of active_medications records present in the database

        Parameters
        ----------
        select
            Select the active_medications fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            active_medications filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.active_medicationsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await active_medications.prisma().count()

        # results: prisma.types.active_medicationsCountAggregateOutput
        results = await active_medications.prisma().count(
            select={
                '_all': True,
                'start_date': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.active_medicationsCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.active_medicationsWhereInput] = None
    ) -> int:
        """Delete multiple active_medications records.

        Parameters
        ----------
        where
            Optional active_medications filter to find the records to be deleted

        Returns
        -------
        int
            The total number of active_medications records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all active_medications records
        total = await active_medications.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.active_medicationsScalarFieldKeys'],
        *,
        where: Optional['types.active_medicationsWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.active_medicationsAvgAggregateInput'] = None,
        sum: Optional['types.active_medicationsSumAggregateInput'] = None,
        min: Optional['types.active_medicationsMinAggregateInput'] = None,
        max: Optional['types.active_medicationsMaxAggregateInput'] = None,
        having: Optional['types.active_medicationsScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.active_medicationsCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.active_medicationsScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.active_medicationsScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.active_medicationsGroupByOutput']:
        """Group active_medications records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar active_medications fields to group records by
        where
            active_medications filter to select records
        take
            Limit the maximum number of active_medications records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.active_medicationsGroupByOutput]
            A list of dictionaries representing the active_medications record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group active_medications records by end_date values
        # and count how many records are in each group
        results = await active_medications.prisma().group_by(
            ['end_date'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class configsActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.configs]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await configs.prisma().query_raw(
            'SELECT * FROM configs WHERE id = ?',
            2111915288,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.configs
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await configs.prisma().query_first(
            'SELECT * FROM configs WHERE patient_id = ?',
            'bbejhfidcb',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.configsCreateInput,
        include: Optional[types.configsInclude] = None
    ) -> _PrismaModelT:
        """Create a new configs record.

        Parameters
        ----------
        data
            configs record data
        include
            Specifies which relations should be loaded on the returned configs model

        Returns
        -------
        prisma.models.configs
            The created configs record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a configs record from just the required fields
        configs = await configs.prisma().create(
            data={
                # data to create a configs record
                'patient_id': 'bgeecijdgg',
                'user_id': 'bdiicjafbj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.configsCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple configs records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of configs record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await configs.prisma().create_many(
            data=[
                {
                    # data to create a configs record
                    'patient_id': 'bgehebiafc',
                    'user_id': 'bghffegacj',
                },
                {
                    # data to create a configs record
                    'patient_id': 'bhghchehcc',
                    'user_id': 'dcgchcbbf',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.configsWhereUniqueInput,
        include: Optional[types.configsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single configs record.

        Parameters
        ----------
        where
            configs filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned configs model

        Returns
        -------
        prisma.models.configs
            The deleted configs record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        configs = await configs.prisma().delete(
            where={
                'id': 1343201072,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.configsWhereUniqueInput,
        include: Optional[types.configsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique configs record.

        Parameters
        ----------
        where
            configs filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned configs model

        Returns
        -------
        prisma.models.configs
            The found configs record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        configs = await configs.prisma().find_unique(
            where={
                'id': 675780521,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.configsWhereUniqueInput,
        include: Optional[types.configsInclude] = None
    ) -> _PrismaModelT:
        """Find a unique configs record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            configs filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned configs model

        Returns
        -------
        prisma.models.configs
            The found configs record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        configs = await configs.prisma().find_unique_or_raise(
            where={
                'id': 744964398,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.configsWhereInput] = None,
        cursor: Optional[types.configsWhereUniqueInput] = None,
        include: Optional[types.configsInclude] = None,
        order: Optional[Union[types.configsOrderByInput, List[types.configsOrderByInput]]] = None,
        distinct: Optional[List[types.configsScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple configs records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of configs records returned
        skip
            Ignore the first N results
        where
            configs filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned configs model
        order
            Order the returned configs records by any field
        distinct
            Filter configs records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.configs]
            The list of all configs records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 configs records
        configs = await configs.prisma().find_many(take=10)

        # find the first 5 configs records ordered by the user_id field
        configs = await configs.prisma().find_many(
            take=5,
            order={
                'user_id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.configsWhereInput] = None,
        cursor: Optional[types.configsWhereUniqueInput] = None,
        include: Optional[types.configsInclude] = None,
        order: Optional[Union[types.configsOrderByInput, List[types.configsOrderByInput]]] = None,
        distinct: Optional[List[types.configsScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single configs record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            configs filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned configs model
        order
            Order the returned configs records by any field
        distinct
            Filter configs records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.configs
            The first configs record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second configs record ordered by the stature field
        configs = await configs.prisma().find_first(
            skip=1,
            order={
                'stature': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.configsWhereInput] = None,
        cursor: Optional[types.configsWhereUniqueInput] = None,
        include: Optional[types.configsInclude] = None,
        order: Optional[Union[types.configsOrderByInput, List[types.configsOrderByInput]]] = None,
        distinct: Optional[List[types.configsScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single configs record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            configs filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned configs model
        order
            Order the returned configs records by any field
        distinct
            Filter configs records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.configs
            The first configs record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second configs record ordered by the show_weight field
        configs = await configs.prisma().find_first_or_raise(
            skip=1,
            order={
                'show_weight': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.configsUpdateInput,
        where: types.configsWhereUniqueInput,
        include: Optional[types.configsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single configs record.

        Parameters
        ----------
        data
            configs record data specifying what to update
        where
            configs filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned configs model

        Returns
        -------
        prisma.models.configs
            The updated configs record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        configs = await configs.prisma().update(
            where={
                'id': 1969681615,
            },
            data={
                # data to update the configs record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.configsWhereUniqueInput,
        data: types.configsUpsertInput,
        include: Optional[types.configsInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            configs filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned configs model

        Returns
        -------
        prisma.models.configs
            The created or updated configs record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        configs = await configs.prisma().upsert(
            where={
                'id': 1116175964,
            },
            data={
                'create': {
                    'id': 1116175964,
                    'patient_id': 'bhghchehcc',
                    'user_id': 'dcgchcbbf',
                },
                'update': {
                    'patient_id': 'bhghchehcc',
                    'user_id': 'dcgchcbbf',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.configsUpdateManyMutationInput,
        where: types.configsWhereInput,
    ) -> int:
        """Update multiple configs records

        Parameters
        ----------
        data
            configs data to update the selected configs records to
        where
            Filter to select the configs records to update

        Returns
        -------
        int
            The total number of configs records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all configs records
        total = await configs.prisma().update_many(
            data={
                'show_body_mass': 861472101
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.configsWhereInput] = None,
        cursor: Optional[types.configsWhereUniqueInput] = None,
    ) -> int:
        """Count the number of configs records present in the database

        Parameters
        ----------
        select
            Select the configs fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            configs filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.configsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await configs.prisma().count()

        # results: prisma.types.configsCountAggregateOutput
        results = await configs.prisma().count(
            select={
                '_all': True,
                'show_temperature': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.configsCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.configsWhereInput] = None,
        cursor: Optional[types.configsWhereUniqueInput] = None,
    ) -> types.configsCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.configsCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.configsWhereInput] = None,
        cursor: Optional[types.configsWhereUniqueInput] = None,
    ) -> Union[int, types.configsCountAggregateOutput]:
        """Count the number of configs records present in the database

        Parameters
        ----------
        select
            Select the configs fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            configs filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.configsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await configs.prisma().count()

        # results: prisma.types.configsCountAggregateOutput
        results = await configs.prisma().count(
            select={
                '_all': True,
                'show_respiratory_rate': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.configsCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.configsWhereInput] = None
    ) -> int:
        """Delete multiple configs records.

        Parameters
        ----------
        where
            Optional configs filter to find the records to be deleted

        Returns
        -------
        int
            The total number of configs records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all configs records
        total = await configs.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.configsScalarFieldKeys'],
        *,
        where: Optional['types.configsWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.configsAvgAggregateInput'] = None,
        sum: Optional['types.configsSumAggregateInput'] = None,
        min: Optional['types.configsMinAggregateInput'] = None,
        max: Optional['types.configsMaxAggregateInput'] = None,
        having: Optional['types.configsScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.configsCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.configsScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.configsScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.configsGroupByOutput']:
        """Group configs records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar configs fields to group records by
        where
            configs filter to select records
        take
            Limit the maximum number of configs records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.configsGroupByOutput]
            A list of dictionaries representing the configs record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group configs records by show_systolic values
        # and count how many records are in each group
        results = await configs.prisma().group_by(
            ['show_systolic'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class hereditary_family_historyActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.hereditary_family_history]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await hereditary_family_history.prisma().query_raw(
            'SELECT * FROM hereditary_family_history WHERE id = ?',
            1303003706,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.hereditary_family_history
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await hereditary_family_history.prisma().query_first(
            'SELECT * FROM hereditary_family_history WHERE patient_id = ?',
            'bgiggdidbf',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.hereditary_family_historyCreateInput,
        include: Optional[types.hereditary_family_historyInclude] = None
    ) -> _PrismaModelT:
        """Create a new hereditary_family_history record.

        Parameters
        ----------
        data
            hereditary_family_history record data
        include
            Specifies which relations should be loaded on the returned hereditary_family_history model

        Returns
        -------
        prisma.models.hereditary_family_history
            The created hereditary_family_history record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a hereditary_family_history record from just the required fields
        hereditary_family_history = await hereditary_family_history.prisma().create(
            data={
                # data to create a hereditary_family_history record
                'patient_id': 'caaaedabfc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.hereditary_family_historyCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple hereditary_family_history records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of hereditary_family_history record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await hereditary_family_history.prisma().create_many(
            data=[
                {
                    # data to create a hereditary_family_history record
                    'patient_id': 'bigibebcib',
                },
                {
                    # data to create a hereditary_family_history record
                    'patient_id': 'bigaiehgcc',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.hereditary_family_historyWhereUniqueInput,
        include: Optional[types.hereditary_family_historyInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single hereditary_family_history record.

        Parameters
        ----------
        where
            hereditary_family_history filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned hereditary_family_history model

        Returns
        -------
        prisma.models.hereditary_family_history
            The deleted hereditary_family_history record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        hereditary_family_history = await hereditary_family_history.prisma().delete(
            where={
                'id': 1448521415,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.hereditary_family_historyWhereUniqueInput,
        include: Optional[types.hereditary_family_historyInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique hereditary_family_history record.

        Parameters
        ----------
        where
            hereditary_family_history filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned hereditary_family_history model

        Returns
        -------
        prisma.models.hereditary_family_history
            The found hereditary_family_history record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        hereditary_family_history = await hereditary_family_history.prisma().find_unique(
            where={
                'id': 1628650740,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.hereditary_family_historyWhereUniqueInput,
        include: Optional[types.hereditary_family_historyInclude] = None
    ) -> _PrismaModelT:
        """Find a unique hereditary_family_history record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            hereditary_family_history filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned hereditary_family_history model

        Returns
        -------
        prisma.models.hereditary_family_history
            The found hereditary_family_history record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        hereditary_family_history = await hereditary_family_history.prisma().find_unique_or_raise(
            where={
                'id': 1249606685,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.hereditary_family_historyWhereInput] = None,
        cursor: Optional[types.hereditary_family_historyWhereUniqueInput] = None,
        include: Optional[types.hereditary_family_historyInclude] = None,
        order: Optional[Union[types.hereditary_family_historyOrderByInput, List[types.hereditary_family_historyOrderByInput]]] = None,
        distinct: Optional[List[types.hereditary_family_historyScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple hereditary_family_history records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of hereditary_family_history records returned
        skip
            Ignore the first N results
        where
            hereditary_family_history filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned hereditary_family_history model
        order
            Order the returned hereditary_family_history records by any field
        distinct
            Filter hereditary_family_history records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.hereditary_family_history]
            The list of all hereditary_family_history records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 hereditary_family_history records
        hereditary_family_historys = await hereditary_family_history.prisma().find_many(take=10)

        # find the first 5 hereditary_family_history records ordered by the diabetes field
        hereditary_family_historys = await hereditary_family_history.prisma().find_many(
            take=5,
            order={
                'diabetes': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.hereditary_family_historyWhereInput] = None,
        cursor: Optional[types.hereditary_family_historyWhereUniqueInput] = None,
        include: Optional[types.hereditary_family_historyInclude] = None,
        order: Optional[Union[types.hereditary_family_historyOrderByInput, List[types.hereditary_family_historyOrderByInput]]] = None,
        distinct: Optional[List[types.hereditary_family_historyScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single hereditary_family_history record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            hereditary_family_history filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned hereditary_family_history model
        order
            Order the returned hereditary_family_history records by any field
        distinct
            Filter hereditary_family_history records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.hereditary_family_history
            The first hereditary_family_history record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second hereditary_family_history record ordered by the heart_disease field
        hereditary_family_history = await hereditary_family_history.prisma().find_first(
            skip=1,
            order={
                'heart_disease': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.hereditary_family_historyWhereInput] = None,
        cursor: Optional[types.hereditary_family_historyWhereUniqueInput] = None,
        include: Optional[types.hereditary_family_historyInclude] = None,
        order: Optional[Union[types.hereditary_family_historyOrderByInput, List[types.hereditary_family_historyOrderByInput]]] = None,
        distinct: Optional[List[types.hereditary_family_historyScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single hereditary_family_history record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            hereditary_family_history filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned hereditary_family_history model
        order
            Order the returned hereditary_family_history records by any field
        distinct
            Filter hereditary_family_history records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.hereditary_family_history
            The first hereditary_family_history record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second hereditary_family_history record ordered by the arterial_hypertension field
        hereditary_family_history = await hereditary_family_history.prisma().find_first_or_raise(
            skip=1,
            order={
                'arterial_hypertension': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.hereditary_family_historyUpdateInput,
        where: types.hereditary_family_historyWhereUniqueInput,
        include: Optional[types.hereditary_family_historyInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single hereditary_family_history record.

        Parameters
        ----------
        data
            hereditary_family_history record data specifying what to update
        where
            hereditary_family_history filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned hereditary_family_history model

        Returns
        -------
        prisma.models.hereditary_family_history
            The updated hereditary_family_history record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        hereditary_family_history = await hereditary_family_history.prisma().update(
            where={
                'id': 835903122,
            },
            data={
                # data to update the hereditary_family_history record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.hereditary_family_historyWhereUniqueInput,
        data: types.hereditary_family_historyUpsertInput,
        include: Optional[types.hereditary_family_historyInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            hereditary_family_history filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned hereditary_family_history model

        Returns
        -------
        prisma.models.hereditary_family_history
            The created or updated hereditary_family_history record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        hereditary_family_history = await hereditary_family_history.prisma().upsert(
            where={
                'id': 763719779,
            },
            data={
                'create': {
                    'id': 763719779,
                    'patient_id': 'bigaiehgcc',
                },
                'update': {
                    'patient_id': 'bigaiehgcc',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.hereditary_family_historyUpdateManyMutationInput,
        where: types.hereditary_family_historyWhereInput,
    ) -> int:
        """Update multiple hereditary_family_history records

        Parameters
        ----------
        data
            hereditary_family_history data to update the selected hereditary_family_history records to
        where
            Filter to select the hereditary_family_history records to update

        Returns
        -------
        int
            The total number of hereditary_family_history records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all hereditary_family_history records
        total = await hereditary_family_history.prisma().update_many(
            data={
                'thyroid_diseases': True
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.hereditary_family_historyWhereInput] = None,
        cursor: Optional[types.hereditary_family_historyWhereUniqueInput] = None,
    ) -> int:
        """Count the number of hereditary_family_history records present in the database

        Parameters
        ----------
        select
            Select the hereditary_family_history fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            hereditary_family_history filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.hereditary_family_historyCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await hereditary_family_history.prisma().count()

        # results: prisma.types.hereditary_family_historyCountAggregateOutput
        results = await hereditary_family_history.prisma().count(
            select={
                '_all': True,
                'chronic_kidney_disease': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.hereditary_family_historyCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.hereditary_family_historyWhereInput] = None,
        cursor: Optional[types.hereditary_family_historyWhereUniqueInput] = None,
    ) -> types.hereditary_family_historyCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.hereditary_family_historyCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.hereditary_family_historyWhereInput] = None,
        cursor: Optional[types.hereditary_family_historyWhereUniqueInput] = None,
    ) -> Union[int, types.hereditary_family_historyCountAggregateOutput]:
        """Count the number of hereditary_family_history records present in the database

        Parameters
        ----------
        select
            Select the hereditary_family_history fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            hereditary_family_history filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.hereditary_family_historyCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await hereditary_family_history.prisma().count()

        # results: prisma.types.hereditary_family_historyCountAggregateOutput
        results = await hereditary_family_history.prisma().count(
            select={
                '_all': True,
                'others': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.hereditary_family_historyCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.hereditary_family_historyWhereInput] = None
    ) -> int:
        """Delete multiple hereditary_family_history records.

        Parameters
        ----------
        where
            Optional hereditary_family_history filter to find the records to be deleted

        Returns
        -------
        int
            The total number of hereditary_family_history records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all hereditary_family_history records
        total = await hereditary_family_history.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.hereditary_family_historyScalarFieldKeys'],
        *,
        where: Optional['types.hereditary_family_historyWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.hereditary_family_historyAvgAggregateInput'] = None,
        sum: Optional['types.hereditary_family_historySumAggregateInput'] = None,
        min: Optional['types.hereditary_family_historyMinAggregateInput'] = None,
        max: Optional['types.hereditary_family_historyMaxAggregateInput'] = None,
        having: Optional['types.hereditary_family_historyScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.hereditary_family_historyCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.hereditary_family_historyScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.hereditary_family_historyScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.hereditary_family_historyGroupByOutput']:
        """Group hereditary_family_history records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar hereditary_family_history fields to group records by
        where
            hereditary_family_history filter to select records
        take
            Limit the maximum number of hereditary_family_history records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.hereditary_family_historyGroupByOutput]
            A list of dictionaries representing the hereditary_family_history record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group hereditary_family_history records by id values
        # and count how many records are in each group
        results = await hereditary_family_history.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class lab_resultsActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.lab_results]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await lab_results.prisma().query_raw(
            'SELECT * FROM lab_results WHERE id = ?',
            1775811865,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.lab_results
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await lab_results.prisma().query_first(
            'SELECT * FROM lab_results WHERE patient_id = ?',
            'ijdbeffgg',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.lab_resultsCreateInput,
        include: Optional[types.lab_resultsInclude] = None
    ) -> _PrismaModelT:
        """Create a new lab_results record.

        Parameters
        ----------
        data
            lab_results record data
        include
            Specifies which relations should be loaded on the returned lab_results model

        Returns
        -------
        prisma.models.lab_results
            The created lab_results record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a lab_results record from just the required fields
        lab_results = await lab_results.prisma().create(
            data={
                # data to create a lab_results record
                'patient_id': 'jjfeafhfj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.lab_resultsCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple lab_results records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of lab_results record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await lab_results.prisma().create_many(
            data=[
                {
                    # data to create a lab_results record
                    'patient_id': 'cbachdgfce',
                },
                {
                    # data to create a lab_results record
                    'patient_id': 'chbfcacbd',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.lab_resultsWhereUniqueInput,
        include: Optional[types.lab_resultsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single lab_results record.

        Parameters
        ----------
        where
            lab_results filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned lab_results model

        Returns
        -------
        prisma.models.lab_results
            The deleted lab_results record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        lab_results = await lab_results.prisma().delete(
            where={
                'id': 456633834,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.lab_resultsWhereUniqueInput,
        include: Optional[types.lab_resultsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique lab_results record.

        Parameters
        ----------
        where
            lab_results filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned lab_results model

        Returns
        -------
        prisma.models.lab_results
            The found lab_results record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        lab_results = await lab_results.prisma().find_unique(
            where={
                'id': 2058258651,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.lab_resultsWhereUniqueInput,
        include: Optional[types.lab_resultsInclude] = None
    ) -> _PrismaModelT:
        """Find a unique lab_results record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            lab_results filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned lab_results model

        Returns
        -------
        prisma.models.lab_results
            The found lab_results record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        lab_results = await lab_results.prisma().find_unique_or_raise(
            where={
                'id': 1583689592,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.lab_resultsWhereInput] = None,
        cursor: Optional[types.lab_resultsWhereUniqueInput] = None,
        include: Optional[types.lab_resultsInclude] = None,
        order: Optional[Union[types.lab_resultsOrderByInput, List[types.lab_resultsOrderByInput]]] = None,
        distinct: Optional[List[types.lab_resultsScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple lab_results records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of lab_results records returned
        skip
            Ignore the first N results
        where
            lab_results filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned lab_results model
        order
            Order the returned lab_results records by any field
        distinct
            Filter lab_results records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.lab_results]
            The list of all lab_results records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 lab_results records
        lab_results = await lab_results.prisma().find_many(take=10)

        # find the first 5 lab_results records ordered by the erythrocytes field
        lab_results = await lab_results.prisma().find_many(
            take=5,
            order={
                'erythrocytes': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.lab_resultsWhereInput] = None,
        cursor: Optional[types.lab_resultsWhereUniqueInput] = None,
        include: Optional[types.lab_resultsInclude] = None,
        order: Optional[Union[types.lab_resultsOrderByInput, List[types.lab_resultsOrderByInput]]] = None,
        distinct: Optional[List[types.lab_resultsScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single lab_results record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            lab_results filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned lab_results model
        order
            Order the returned lab_results records by any field
        distinct
            Filter lab_results records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.lab_results
            The first lab_results record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second lab_results record ordered by the hematocrit field
        lab_results = await lab_results.prisma().find_first(
            skip=1,
            order={
                'hematocrit': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.lab_resultsWhereInput] = None,
        cursor: Optional[types.lab_resultsWhereUniqueInput] = None,
        include: Optional[types.lab_resultsInclude] = None,
        order: Optional[Union[types.lab_resultsOrderByInput, List[types.lab_resultsOrderByInput]]] = None,
        distinct: Optional[List[types.lab_resultsScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single lab_results record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            lab_results filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned lab_results model
        order
            Order the returned lab_results records by any field
        distinct
            Filter lab_results records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.lab_results
            The first lab_results record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second lab_results record ordered by the hemoglobin field
        lab_results = await lab_results.prisma().find_first_or_raise(
            skip=1,
            order={
                'hemoglobin': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.lab_resultsUpdateInput,
        where: types.lab_resultsWhereUniqueInput,
        include: Optional[types.lab_resultsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single lab_results record.

        Parameters
        ----------
        data
            lab_results record data specifying what to update
        where
            lab_results filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned lab_results model

        Returns
        -------
        prisma.models.lab_results
            The updated lab_results record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        lab_results = await lab_results.prisma().update(
            where={
                'id': 878442065,
            },
            data={
                # data to update the lab_results record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.lab_resultsWhereUniqueInput,
        data: types.lab_resultsUpsertInput,
        include: Optional[types.lab_resultsInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            lab_results filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned lab_results model

        Returns
        -------
        prisma.models.lab_results
            The created or updated lab_results record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        lab_results = await lab_results.prisma().upsert(
            where={
                'id': 1675280054,
            },
            data={
                'create': {
                    'id': 1675280054,
                    'patient_id': 'chbfcacbd',
                },
                'update': {
                    'patient_id': 'chbfcacbd',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.lab_resultsUpdateManyMutationInput,
        where: types.lab_resultsWhereInput,
    ) -> int:
        """Update multiple lab_results records

        Parameters
        ----------
        data
            lab_results data to update the selected lab_results records to
        where
            Filter to select the lab_results records to update

        Returns
        -------
        int
            The total number of lab_results records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all lab_results records
        total = await lab_results.prisma().update_many(
            data={
                'leukocytes': 1627576247.205480
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.lab_resultsWhereInput] = None,
        cursor: Optional[types.lab_resultsWhereUniqueInput] = None,
    ) -> int:
        """Count the number of lab_results records present in the database

        Parameters
        ----------
        select
            Select the lab_results fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            lab_results filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.lab_resultsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await lab_results.prisma().count()

        # results: prisma.types.lab_resultsCountAggregateOutput
        results = await lab_results.prisma().count(
            select={
                '_all': True,
                'platelets': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.lab_resultsCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.lab_resultsWhereInput] = None,
        cursor: Optional[types.lab_resultsWhereUniqueInput] = None,
    ) -> types.lab_resultsCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.lab_resultsCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.lab_resultsWhereInput] = None,
        cursor: Optional[types.lab_resultsWhereUniqueInput] = None,
    ) -> Union[int, types.lab_resultsCountAggregateOutput]:
        """Count the number of lab_results records present in the database

        Parameters
        ----------
        select
            Select the lab_results fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            lab_results filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.lab_resultsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await lab_results.prisma().count()

        # results: prisma.types.lab_resultsCountAggregateOutput
        results = await lab_results.prisma().count(
            select={
                '_all': True,
                'reticulocytes': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.lab_resultsCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.lab_resultsWhereInput] = None
    ) -> int:
        """Delete multiple lab_results records.

        Parameters
        ----------
        where
            Optional lab_results filter to find the records to be deleted

        Returns
        -------
        int
            The total number of lab_results records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all lab_results records
        total = await lab_results.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.lab_resultsScalarFieldKeys'],
        *,
        where: Optional['types.lab_resultsWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.lab_resultsAvgAggregateInput'] = None,
        sum: Optional['types.lab_resultsSumAggregateInput'] = None,
        min: Optional['types.lab_resultsMinAggregateInput'] = None,
        max: Optional['types.lab_resultsMaxAggregateInput'] = None,
        having: Optional['types.lab_resultsScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.lab_resultsCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.lab_resultsScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.lab_resultsScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.lab_resultsGroupByOutput']:
        """Group lab_results records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar lab_results fields to group records by
        where
            lab_results filter to select records
        take
            Limit the maximum number of lab_results records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.lab_resultsGroupByOutput]
            A list of dictionaries representing the lab_results record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group lab_results records by blood_urea_nitrogen values
        # and count how many records are in each group
        results = await lab_results.prisma().group_by(
            ['blood_urea_nitrogen'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class medical_consultationActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.medical_consultation]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await medical_consultation.prisma().query_raw(
            'SELECT * FROM medical_consultation WHERE id = ?',
            'gaddfhfh',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.medical_consultation
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await medical_consultation.prisma().query_first(
            'SELECT * FROM medical_consultation WHERE patient_id = ?',
            'gieegcbeg',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.medical_consultationCreateInput,
        include: Optional[types.medical_consultationInclude] = None
    ) -> _PrismaModelT:
        """Create a new medical_consultation record.

        Parameters
        ----------
        data
            medical_consultation record data
        include
            Specifies which relations should be loaded on the returned medical_consultation model

        Returns
        -------
        prisma.models.medical_consultation
            The created medical_consultation record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a medical_consultation record from just the required fields
        medical_consultation = await medical_consultation.prisma().create(
            data={
                # data to create a medical_consultation record
                'id': 'bgcffadich',
                'patient_id': 'fcbichhci',
                'date': datetime.datetime.utcnow(),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.medical_consultationCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple medical_consultation records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of medical_consultation record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await medical_consultation.prisma().create_many(
            data=[
                {
                    # data to create a medical_consultation record
                    'id': 'bcggadccgf',
                    'patient_id': 'jdcfdcgc',
                    'date': datetime.datetime.utcnow(),
                },
                {
                    # data to create a medical_consultation record
                    'id': 'cafdaehjid',
                    'patient_id': 'gifdddbia',
                    'date': datetime.datetime.utcnow(),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.medical_consultationWhereUniqueInput,
        include: Optional[types.medical_consultationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single medical_consultation record.

        Parameters
        ----------
        where
            medical_consultation filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned medical_consultation model

        Returns
        -------
        prisma.models.medical_consultation
            The deleted medical_consultation record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        medical_consultation = await medical_consultation.prisma().delete(
            where={
                'id': 'bchehecef',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.medical_consultationWhereUniqueInput,
        include: Optional[types.medical_consultationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique medical_consultation record.

        Parameters
        ----------
        where
            medical_consultation filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned medical_consultation model

        Returns
        -------
        prisma.models.medical_consultation
            The found medical_consultation record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        medical_consultation = await medical_consultation.prisma().find_unique(
            where={
                'id': 'jeijcbhfe',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.medical_consultationWhereUniqueInput,
        include: Optional[types.medical_consultationInclude] = None
    ) -> _PrismaModelT:
        """Find a unique medical_consultation record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            medical_consultation filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned medical_consultation model

        Returns
        -------
        prisma.models.medical_consultation
            The found medical_consultation record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        medical_consultation = await medical_consultation.prisma().find_unique_or_raise(
            where={
                'id': 'bjgejjabff',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.medical_consultationWhereInput] = None,
        cursor: Optional[types.medical_consultationWhereUniqueInput] = None,
        include: Optional[types.medical_consultationInclude] = None,
        order: Optional[Union[types.medical_consultationOrderByInput, List[types.medical_consultationOrderByInput]]] = None,
        distinct: Optional[List[types.medical_consultationScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple medical_consultation records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of medical_consultation records returned
        skip
            Ignore the first N results
        where
            medical_consultation filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned medical_consultation model
        order
            Order the returned medical_consultation records by any field
        distinct
            Filter medical_consultation records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.medical_consultation]
            The list of all medical_consultation records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 medical_consultation records
        medical_consultations = await medical_consultation.prisma().find_many(take=10)

        # find the first 5 medical_consultation records ordered by the date field
        medical_consultations = await medical_consultation.prisma().find_many(
            take=5,
            order={
                'date': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.medical_consultationWhereInput] = None,
        cursor: Optional[types.medical_consultationWhereUniqueInput] = None,
        include: Optional[types.medical_consultationInclude] = None,
        order: Optional[Union[types.medical_consultationOrderByInput, List[types.medical_consultationOrderByInput]]] = None,
        distinct: Optional[List[types.medical_consultationScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single medical_consultation record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            medical_consultation filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned medical_consultation model
        order
            Order the returned medical_consultation records by any field
        distinct
            Filter medical_consultation records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.medical_consultation
            The first medical_consultation record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second medical_consultation record ordered by the notes field
        medical_consultation = await medical_consultation.prisma().find_first(
            skip=1,
            order={
                'notes': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.medical_consultationWhereInput] = None,
        cursor: Optional[types.medical_consultationWhereUniqueInput] = None,
        include: Optional[types.medical_consultationInclude] = None,
        order: Optional[Union[types.medical_consultationOrderByInput, List[types.medical_consultationOrderByInput]]] = None,
        distinct: Optional[List[types.medical_consultationScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single medical_consultation record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            medical_consultation filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned medical_consultation model
        order
            Order the returned medical_consultation records by any field
        distinct
            Filter medical_consultation records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.medical_consultation
            The first medical_consultation record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second medical_consultation record ordered by the medical_instructions field
        medical_consultation = await medical_consultation.prisma().find_first_or_raise(
            skip=1,
            order={
                'medical_instructions': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.medical_consultationUpdateInput,
        where: types.medical_consultationWhereUniqueInput,
        include: Optional[types.medical_consultationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single medical_consultation record.

        Parameters
        ----------
        data
            medical_consultation record data specifying what to update
        where
            medical_consultation filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned medical_consultation model

        Returns
        -------
        prisma.models.medical_consultation
            The updated medical_consultation record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        medical_consultation = await medical_consultation.prisma().update(
            where={
                'id': 'bcciijbibg',
            },
            data={
                # data to update the medical_consultation record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.medical_consultationWhereUniqueInput,
        data: types.medical_consultationUpsertInput,
        include: Optional[types.medical_consultationInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            medical_consultation filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned medical_consultation model

        Returns
        -------
        prisma.models.medical_consultation
            The created or updated medical_consultation record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        medical_consultation = await medical_consultation.prisma().upsert(
            where={
                'id': 'cffcachfd',
            },
            data={
                'create': {
                    'id': 'cffcachfd',
                    'patient_id': 'gifdddbia',
                    'date': datetime.datetime.utcnow(),
                },
                'update': {
                    'patient_id': 'gifdddbia',
                    'date': datetime.datetime.utcnow(),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.medical_consultationUpdateManyMutationInput,
        where: types.medical_consultationWhereInput,
    ) -> int:
        """Update multiple medical_consultation records

        Parameters
        ----------
        data
            medical_consultation data to update the selected medical_consultation records to
        where
            Filter to select the medical_consultation records to update

        Returns
        -------
        int
            The total number of medical_consultation records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all medical_consultation records
        total = await medical_consultation.prisma().update_many(
            data={
                'treatment_plan': 'bccdfhdigc'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.medical_consultationWhereInput] = None,
        cursor: Optional[types.medical_consultationWhereUniqueInput] = None,
    ) -> int:
        """Count the number of medical_consultation records present in the database

        Parameters
        ----------
        select
            Select the medical_consultation fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            medical_consultation filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.medical_consultationCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await medical_consultation.prisma().count()

        # results: prisma.types.medical_consultationCountAggregateOutput
        results = await medical_consultation.prisma().count(
            select={
                '_all': True,
                'reason': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.medical_consultationCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.medical_consultationWhereInput] = None,
        cursor: Optional[types.medical_consultationWhereUniqueInput] = None,
    ) -> types.medical_consultationCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.medical_consultationCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.medical_consultationWhereInput] = None,
        cursor: Optional[types.medical_consultationWhereUniqueInput] = None,
    ) -> Union[int, types.medical_consultationCountAggregateOutput]:
        """Count the number of medical_consultation records present in the database

        Parameters
        ----------
        select
            Select the medical_consultation fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            medical_consultation filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.medical_consultationCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await medical_consultation.prisma().count()

        # results: prisma.types.medical_consultationCountAggregateOutput
        results = await medical_consultation.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.medical_consultationCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.medical_consultationWhereInput] = None
    ) -> int:
        """Delete multiple medical_consultation records.

        Parameters
        ----------
        where
            Optional medical_consultation filter to find the records to be deleted

        Returns
        -------
        int
            The total number of medical_consultation records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all medical_consultation records
        total = await medical_consultation.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.medical_consultationScalarFieldKeys'],
        *,
        where: Optional['types.medical_consultationWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.medical_consultationAvgAggregateInput'] = None,
        sum: Optional['types.medical_consultationSumAggregateInput'] = None,
        min: Optional['types.medical_consultationMinAggregateInput'] = None,
        max: Optional['types.medical_consultationMaxAggregateInput'] = None,
        having: Optional['types.medical_consultationScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.medical_consultationCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.medical_consultationScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.medical_consultationScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.medical_consultationGroupByOutput']:
        """Group medical_consultation records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar medical_consultation fields to group records by
        where
            medical_consultation filter to select records
        take
            Limit the maximum number of medical_consultation records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.medical_consultationGroupByOutput]
            A list of dictionaries representing the medical_consultation record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group medical_consultation records by patient_id values
        # and count how many records are in each group
        results = await medical_consultation.prisma().group_by(
            ['patient_id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class non_pathological_historyActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.non_pathological_history]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await non_pathological_history.prisma().query_raw(
            'SELECT * FROM non_pathological_history WHERE id = ?',
            541269159,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.non_pathological_history
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await non_pathological_history.prisma().query_first(
            'SELECT * FROM non_pathological_history WHERE patient_id = ?',
            'bageiegghg',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.non_pathological_historyCreateInput,
        include: Optional[types.non_pathological_historyInclude] = None
    ) -> _PrismaModelT:
        """Create a new non_pathological_history record.

        Parameters
        ----------
        data
            non_pathological_history record data
        include
            Specifies which relations should be loaded on the returned non_pathological_history model

        Returns
        -------
        prisma.models.non_pathological_history
            The created non_pathological_history record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a non_pathological_history record from just the required fields
        non_pathological_history = await non_pathological_history.prisma().create(
            data={
                # data to create a non_pathological_history record
                'patient_id': 'faidicegb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.non_pathological_historyCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple non_pathological_history records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of non_pathological_history record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await non_pathological_history.prisma().create_many(
            data=[
                {
                    # data to create a non_pathological_history record
                    'patient_id': 'bacecgfhbe',
                },
                {
                    # data to create a non_pathological_history record
                    'patient_id': 'ihcahiead',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.non_pathological_historyWhereUniqueInput,
        include: Optional[types.non_pathological_historyInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single non_pathological_history record.

        Parameters
        ----------
        where
            non_pathological_history filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned non_pathological_history model

        Returns
        -------
        prisma.models.non_pathological_history
            The deleted non_pathological_history record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        non_pathological_history = await non_pathological_history.prisma().delete(
            where={
                'id': 1874748096,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.non_pathological_historyWhereUniqueInput,
        include: Optional[types.non_pathological_historyInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique non_pathological_history record.

        Parameters
        ----------
        where
            non_pathological_history filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned non_pathological_history model

        Returns
        -------
        prisma.models.non_pathological_history
            The found non_pathological_history record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        non_pathological_history = await non_pathological_history.prisma().find_unique(
            where={
                'id': 916896761,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.non_pathological_historyWhereUniqueInput,
        include: Optional[types.non_pathological_historyInclude] = None
    ) -> _PrismaModelT:
        """Find a unique non_pathological_history record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            non_pathological_history filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned non_pathological_history model

        Returns
        -------
        prisma.models.non_pathological_history
            The found non_pathological_history record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        non_pathological_history = await non_pathological_history.prisma().find_unique_or_raise(
            where={
                'id': 769267518,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.non_pathological_historyWhereInput] = None,
        cursor: Optional[types.non_pathological_historyWhereUniqueInput] = None,
        include: Optional[types.non_pathological_historyInclude] = None,
        order: Optional[Union[types.non_pathological_historyOrderByInput, List[types.non_pathological_historyOrderByInput]]] = None,
        distinct: Optional[List[types.non_pathological_historyScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple non_pathological_history records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of non_pathological_history records returned
        skip
            Ignore the first N results
        where
            non_pathological_history filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned non_pathological_history model
        order
            Order the returned non_pathological_history records by any field
        distinct
            Filter non_pathological_history records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.non_pathological_history]
            The list of all non_pathological_history records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 non_pathological_history records
        non_pathological_historys = await non_pathological_history.prisma().find_many(take=10)

        # find the first 5 non_pathological_history records ordered by the physical_activity field
        non_pathological_historys = await non_pathological_history.prisma().find_many(
            take=5,
            order={
                'physical_activity': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.non_pathological_historyWhereInput] = None,
        cursor: Optional[types.non_pathological_historyWhereUniqueInput] = None,
        include: Optional[types.non_pathological_historyInclude] = None,
        order: Optional[Union[types.non_pathological_historyOrderByInput, List[types.non_pathological_historyOrderByInput]]] = None,
        distinct: Optional[List[types.non_pathological_historyScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single non_pathological_history record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            non_pathological_history filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned non_pathological_history model
        order
            Order the returned non_pathological_history records by any field
        distinct
            Filter non_pathological_history records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.non_pathological_history
            The first non_pathological_history record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second non_pathological_history record ordered by the smoking field
        non_pathological_history = await non_pathological_history.prisma().find_first(
            skip=1,
            order={
                'smoking': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.non_pathological_historyWhereInput] = None,
        cursor: Optional[types.non_pathological_historyWhereUniqueInput] = None,
        include: Optional[types.non_pathological_historyInclude] = None,
        order: Optional[Union[types.non_pathological_historyOrderByInput, List[types.non_pathological_historyOrderByInput]]] = None,
        distinct: Optional[List[types.non_pathological_historyScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single non_pathological_history record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            non_pathological_history filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned non_pathological_history model
        order
            Order the returned non_pathological_history records by any field
        distinct
            Filter non_pathological_history records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.non_pathological_history
            The first non_pathological_history record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second non_pathological_history record ordered by the alcoholism field
        non_pathological_history = await non_pathological_history.prisma().find_first_or_raise(
            skip=1,
            order={
                'alcoholism': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.non_pathological_historyUpdateInput,
        where: types.non_pathological_historyWhereUniqueInput,
        include: Optional[types.non_pathological_historyInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single non_pathological_history record.

        Parameters
        ----------
        data
            non_pathological_history record data specifying what to update
        where
            non_pathological_history filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned non_pathological_history model

        Returns
        -------
        prisma.models.non_pathological_history
            The updated non_pathological_history record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        non_pathological_history = await non_pathological_history.prisma().update(
            where={
                'id': 820312479,
            },
            data={
                # data to update the non_pathological_history record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.non_pathological_historyWhereUniqueInput,
        data: types.non_pathological_historyUpsertInput,
        include: Optional[types.non_pathological_historyInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            non_pathological_history filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned non_pathological_history model

        Returns
        -------
        prisma.models.non_pathological_history
            The created or updated non_pathological_history record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        non_pathological_history = await non_pathological_history.prisma().upsert(
            where={
                'id': 92728044,
            },
            data={
                'create': {
                    'id': 92728044,
                    'patient_id': 'ihcahiead',
                },
                'update': {
                    'patient_id': 'ihcahiead',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.non_pathological_historyUpdateManyMutationInput,
        where: types.non_pathological_historyWhereInput,
    ) -> int:
        """Update multiple non_pathological_history records

        Parameters
        ----------
        data
            non_pathological_history data to update the selected non_pathological_history records to
        where
            Filter to select the non_pathological_history records to update

        Returns
        -------
        int
            The total number of non_pathological_history records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all non_pathological_history records
        total = await non_pathological_history.prisma().update_many(
            data={
                'recent_vaccine_or_immunization': False
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.non_pathological_historyWhereInput] = None,
        cursor: Optional[types.non_pathological_historyWhereUniqueInput] = None,
    ) -> int:
        """Count the number of non_pathological_history records present in the database

        Parameters
        ----------
        select
            Select the non_pathological_history fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            non_pathological_history filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.non_pathological_historyCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await non_pathological_history.prisma().count()

        # results: prisma.types.non_pathological_historyCountAggregateOutput
        results = await non_pathological_history.prisma().count(
            select={
                '_all': True,
                'others': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.non_pathological_historyCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.non_pathological_historyWhereInput] = None,
        cursor: Optional[types.non_pathological_historyWhereUniqueInput] = None,
    ) -> types.non_pathological_historyCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.non_pathological_historyCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.non_pathological_historyWhereInput] = None,
        cursor: Optional[types.non_pathological_historyWhereUniqueInput] = None,
    ) -> Union[int, types.non_pathological_historyCountAggregateOutput]:
        """Count the number of non_pathological_history records present in the database

        Parameters
        ----------
        select
            Select the non_pathological_history fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            non_pathological_history filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.non_pathological_historyCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await non_pathological_history.prisma().count()

        # results: prisma.types.non_pathological_historyCountAggregateOutput
        results = await non_pathological_history.prisma().count(
            select={
                '_all': True,
                'drugs': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.non_pathological_historyCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.non_pathological_historyWhereInput] = None
    ) -> int:
        """Delete multiple non_pathological_history records.

        Parameters
        ----------
        where
            Optional non_pathological_history filter to find the records to be deleted

        Returns
        -------
        int
            The total number of non_pathological_history records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all non_pathological_history records
        total = await non_pathological_history.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.non_pathological_historyScalarFieldKeys'],
        *,
        where: Optional['types.non_pathological_historyWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.non_pathological_historyAvgAggregateInput'] = None,
        sum: Optional['types.non_pathological_historySumAggregateInput'] = None,
        min: Optional['types.non_pathological_historyMinAggregateInput'] = None,
        max: Optional['types.non_pathological_historyMaxAggregateInput'] = None,
        having: Optional['types.non_pathological_historyScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.non_pathological_historyCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.non_pathological_historyScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.non_pathological_historyScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.non_pathological_historyGroupByOutput']:
        """Group non_pathological_history records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar non_pathological_history fields to group records by
        where
            non_pathological_history filter to select records
        take
            Limit the maximum number of non_pathological_history records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.non_pathological_historyGroupByOutput]
            A list of dictionaries representing the non_pathological_history record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group non_pathological_history records by id values
        # and count how many records are in each group
        results = await non_pathological_history.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class nutritional_dietActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.nutritional_diet]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await nutritional_diet.prisma().query_raw(
            'SELECT * FROM nutritional_diet WHERE id = ?',
            1121741130,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.nutritional_diet
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await nutritional_diet.prisma().query_first(
            'SELECT * FROM nutritional_diet WHERE patient_id = ?',
            'bejfijgcfb',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.nutritional_dietCreateInput,
        include: Optional[types.nutritional_dietInclude] = None
    ) -> _PrismaModelT:
        """Create a new nutritional_diet record.

        Parameters
        ----------
        data
            nutritional_diet record data
        include
            Specifies which relations should be loaded on the returned nutritional_diet model

        Returns
        -------
        prisma.models.nutritional_diet
            The created nutritional_diet record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a nutritional_diet record from just the required fields
        nutritional_diet = await nutritional_diet.prisma().create(
            data={
                # data to create a nutritional_diet record
                'patient_id': 'caifcbgii',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.nutritional_dietCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple nutritional_diet records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of nutritional_diet record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await nutritional_diet.prisma().create_many(
            data=[
                {
                    # data to create a nutritional_diet record
                    'patient_id': 'igaibbfgj',
                },
                {
                    # data to create a nutritional_diet record
                    'patient_id': 'bggajdcbbi',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.nutritional_dietWhereUniqueInput,
        include: Optional[types.nutritional_dietInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single nutritional_diet record.

        Parameters
        ----------
        where
            nutritional_diet filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned nutritional_diet model

        Returns
        -------
        prisma.models.nutritional_diet
            The deleted nutritional_diet record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        nutritional_diet = await nutritional_diet.prisma().delete(
            where={
                'id': 525761943,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.nutritional_dietWhereUniqueInput,
        include: Optional[types.nutritional_dietInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique nutritional_diet record.

        Parameters
        ----------
        where
            nutritional_diet filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned nutritional_diet model

        Returns
        -------
        prisma.models.nutritional_diet
            The found nutritional_diet record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        nutritional_diet = await nutritional_diet.prisma().find_unique(
            where={
                'id': 736209796,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.nutritional_dietWhereUniqueInput,
        include: Optional[types.nutritional_dietInclude] = None
    ) -> _PrismaModelT:
        """Find a unique nutritional_diet record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            nutritional_diet filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned nutritional_diet model

        Returns
        -------
        prisma.models.nutritional_diet
            The found nutritional_diet record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        nutritional_diet = await nutritional_diet.prisma().find_unique_or_raise(
            where={
                'id': 493907821,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.nutritional_dietWhereInput] = None,
        cursor: Optional[types.nutritional_dietWhereUniqueInput] = None,
        include: Optional[types.nutritional_dietInclude] = None,
        order: Optional[Union[types.nutritional_dietOrderByInput, List[types.nutritional_dietOrderByInput]]] = None,
        distinct: Optional[List[types.nutritional_dietScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple nutritional_diet records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of nutritional_diet records returned
        skip
            Ignore the first N results
        where
            nutritional_diet filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned nutritional_diet model
        order
            Order the returned nutritional_diet records by any field
        distinct
            Filter nutritional_diet records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.nutritional_diet]
            The list of all nutritional_diet records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 nutritional_diet records
        nutritional_diets = await nutritional_diet.prisma().find_many(take=10)

        # find the first 5 nutritional_diet records ordered by the breakfast field
        nutritional_diets = await nutritional_diet.prisma().find_many(
            take=5,
            order={
                'breakfast': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.nutritional_dietWhereInput] = None,
        cursor: Optional[types.nutritional_dietWhereUniqueInput] = None,
        include: Optional[types.nutritional_dietInclude] = None,
        order: Optional[Union[types.nutritional_dietOrderByInput, List[types.nutritional_dietOrderByInput]]] = None,
        distinct: Optional[List[types.nutritional_dietScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single nutritional_diet record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            nutritional_diet filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned nutritional_diet model
        order
            Order the returned nutritional_diet records by any field
        distinct
            Filter nutritional_diet records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.nutritional_diet
            The first nutritional_diet record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second nutritional_diet record ordered by the snack_in_the_morning field
        nutritional_diet = await nutritional_diet.prisma().find_first(
            skip=1,
            order={
                'snack_in_the_morning': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.nutritional_dietWhereInput] = None,
        cursor: Optional[types.nutritional_dietWhereUniqueInput] = None,
        include: Optional[types.nutritional_dietInclude] = None,
        order: Optional[Union[types.nutritional_dietOrderByInput, List[types.nutritional_dietOrderByInput]]] = None,
        distinct: Optional[List[types.nutritional_dietScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single nutritional_diet record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            nutritional_diet filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned nutritional_diet model
        order
            Order the returned nutritional_diet records by any field
        distinct
            Filter nutritional_diet records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.nutritional_diet
            The first nutritional_diet record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second nutritional_diet record ordered by the meal field
        nutritional_diet = await nutritional_diet.prisma().find_first_or_raise(
            skip=1,
            order={
                'meal': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.nutritional_dietUpdateInput,
        where: types.nutritional_dietWhereUniqueInput,
        include: Optional[types.nutritional_dietInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single nutritional_diet record.

        Parameters
        ----------
        data
            nutritional_diet record data specifying what to update
        where
            nutritional_diet filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned nutritional_diet model

        Returns
        -------
        prisma.models.nutritional_diet
            The updated nutritional_diet record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        nutritional_diet = await nutritional_diet.prisma().update(
            where={
                'id': 639686562,
            },
            data={
                # data to update the nutritional_diet record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.nutritional_dietWhereUniqueInput,
        data: types.nutritional_dietUpsertInput,
        include: Optional[types.nutritional_dietInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            nutritional_diet filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned nutritional_diet model

        Returns
        -------
        prisma.models.nutritional_diet
            The created or updated nutritional_diet record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        nutritional_diet = await nutritional_diet.prisma().upsert(
            where={
                'id': 654007347,
            },
            data={
                'create': {
                    'id': 654007347,
                    'patient_id': 'bggajdcbbi',
                },
                'update': {
                    'patient_id': 'bggajdcbbi',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.nutritional_dietUpdateManyMutationInput,
        where: types.nutritional_dietWhereInput,
    ) -> int:
        """Update multiple nutritional_diet records

        Parameters
        ----------
        data
            nutritional_diet data to update the selected nutritional_diet records to
        where
            Filter to select the nutritional_diet records to update

        Returns
        -------
        int
            The total number of nutritional_diet records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all nutritional_diet records
        total = await nutritional_diet.prisma().update_many(
            data={
                'afternoon_snack': True
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.nutritional_dietWhereInput] = None,
        cursor: Optional[types.nutritional_dietWhereUniqueInput] = None,
    ) -> int:
        """Count the number of nutritional_diet records present in the database

        Parameters
        ----------
        select
            Select the nutritional_diet fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            nutritional_diet filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.nutritional_dietCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await nutritional_diet.prisma().count()

        # results: prisma.types.nutritional_dietCountAggregateOutput
        results = await nutritional_diet.prisma().count(
            select={
                '_all': True,
                'dinner': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.nutritional_dietCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.nutritional_dietWhereInput] = None,
        cursor: Optional[types.nutritional_dietWhereUniqueInput] = None,
    ) -> types.nutritional_dietCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.nutritional_dietCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.nutritional_dietWhereInput] = None,
        cursor: Optional[types.nutritional_dietWhereUniqueInput] = None,
    ) -> Union[int, types.nutritional_dietCountAggregateOutput]:
        """Count the number of nutritional_diet records present in the database

        Parameters
        ----------
        select
            Select the nutritional_diet fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            nutritional_diet filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.nutritional_dietCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await nutritional_diet.prisma().count()

        # results: prisma.types.nutritional_dietCountAggregateOutput
        results = await nutritional_diet.prisma().count(
            select={
                '_all': True,
                'food_prepared_at_home': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.nutritional_dietCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.nutritional_dietWhereInput] = None
    ) -> int:
        """Delete multiple nutritional_diet records.

        Parameters
        ----------
        where
            Optional nutritional_diet filter to find the records to be deleted

        Returns
        -------
        int
            The total number of nutritional_diet records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all nutritional_diet records
        total = await nutritional_diet.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.nutritional_dietScalarFieldKeys'],
        *,
        where: Optional['types.nutritional_dietWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.nutritional_dietAvgAggregateInput'] = None,
        sum: Optional['types.nutritional_dietSumAggregateInput'] = None,
        min: Optional['types.nutritional_dietMinAggregateInput'] = None,
        max: Optional['types.nutritional_dietMaxAggregateInput'] = None,
        having: Optional['types.nutritional_dietScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.nutritional_dietCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.nutritional_dietScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.nutritional_dietScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.nutritional_dietGroupByOutput']:
        """Group nutritional_diet records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar nutritional_diet fields to group records by
        where
            nutritional_diet filter to select records
        take
            Limit the maximum number of nutritional_diet records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.nutritional_dietGroupByOutput]
            A list of dictionaries representing the nutritional_diet record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group nutritional_diet records by hunger_satiety values
        # and count how many records are in each group
        results = await nutritional_diet.prisma().group_by(
            ['hunger_satiety'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class obstetric_gynecological_historyActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.obstetric_gynecological_history]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await obstetric_gynecological_history.prisma().query_raw(
            'SELECT * FROM obstetric_gynecological_history WHERE id = ?',
            78746985,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.obstetric_gynecological_history
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await obstetric_gynecological_history.prisma().query_first(
            'SELECT * FROM obstetric_gynecological_history WHERE patient_id = ?',
            'bdjidcidac',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.obstetric_gynecological_historyCreateInput,
        include: Optional[types.obstetric_gynecological_historyInclude] = None
    ) -> _PrismaModelT:
        """Create a new obstetric_gynecological_history record.

        Parameters
        ----------
        data
            obstetric_gynecological_history record data
        include
            Specifies which relations should be loaded on the returned obstetric_gynecological_history model

        Returns
        -------
        prisma.models.obstetric_gynecological_history
            The created obstetric_gynecological_history record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a obstetric_gynecological_history record from just the required fields
        obstetric_gynecological_history = await obstetric_gynecological_history.prisma().create(
            data={
                # data to create a obstetric_gynecological_history record
                'patient_id': 'ifgaaagff',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.obstetric_gynecological_historyCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple obstetric_gynecological_history records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of obstetric_gynecological_history record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await obstetric_gynecological_history.prisma().create_many(
            data=[
                {
                    # data to create a obstetric_gynecological_history record
                    'patient_id': 'befcddgjce',
                },
                {
                    # data to create a obstetric_gynecological_history record
                    'patient_id': 'bfhdbjjgfd',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.obstetric_gynecological_historyWhereUniqueInput,
        include: Optional[types.obstetric_gynecological_historyInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single obstetric_gynecological_history record.

        Parameters
        ----------
        where
            obstetric_gynecological_history filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned obstetric_gynecological_history model

        Returns
        -------
        prisma.models.obstetric_gynecological_history
            The deleted obstetric_gynecological_history record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        obstetric_gynecological_history = await obstetric_gynecological_history.prisma().delete(
            where={
                'id': 2013903098,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.obstetric_gynecological_historyWhereUniqueInput,
        include: Optional[types.obstetric_gynecological_historyInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique obstetric_gynecological_history record.

        Parameters
        ----------
        where
            obstetric_gynecological_history filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned obstetric_gynecological_history model

        Returns
        -------
        prisma.models.obstetric_gynecological_history
            The found obstetric_gynecological_history record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        obstetric_gynecological_history = await obstetric_gynecological_history.prisma().find_unique(
            where={
                'id': 500965035,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.obstetric_gynecological_historyWhereUniqueInput,
        include: Optional[types.obstetric_gynecological_historyInclude] = None
    ) -> _PrismaModelT:
        """Find a unique obstetric_gynecological_history record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            obstetric_gynecological_history filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned obstetric_gynecological_history model

        Returns
        -------
        prisma.models.obstetric_gynecological_history
            The found obstetric_gynecological_history record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        obstetric_gynecological_history = await obstetric_gynecological_history.prisma().find_unique_or_raise(
            where={
                'id': 1800624392,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.obstetric_gynecological_historyWhereInput] = None,
        cursor: Optional[types.obstetric_gynecological_historyWhereUniqueInput] = None,
        include: Optional[types.obstetric_gynecological_historyInclude] = None,
        order: Optional[Union[types.obstetric_gynecological_historyOrderByInput, List[types.obstetric_gynecological_historyOrderByInput]]] = None,
        distinct: Optional[List[types.obstetric_gynecological_historyScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple obstetric_gynecological_history records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of obstetric_gynecological_history records returned
        skip
            Ignore the first N results
        where
            obstetric_gynecological_history filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned obstetric_gynecological_history model
        order
            Order the returned obstetric_gynecological_history records by any field
        distinct
            Filter obstetric_gynecological_history records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.obstetric_gynecological_history]
            The list of all obstetric_gynecological_history records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 obstetric_gynecological_history records
        obstetric_gynecological_historys = await obstetric_gynecological_history.prisma().find_many(take=10)

        # find the first 5 obstetric_gynecological_history records ordered by the first_menstruation field
        obstetric_gynecological_historys = await obstetric_gynecological_history.prisma().find_many(
            take=5,
            order={
                'first_menstruation': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.obstetric_gynecological_historyWhereInput] = None,
        cursor: Optional[types.obstetric_gynecological_historyWhereUniqueInput] = None,
        include: Optional[types.obstetric_gynecological_historyInclude] = None,
        order: Optional[Union[types.obstetric_gynecological_historyOrderByInput, List[types.obstetric_gynecological_historyOrderByInput]]] = None,
        distinct: Optional[List[types.obstetric_gynecological_historyScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single obstetric_gynecological_history record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            obstetric_gynecological_history filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned obstetric_gynecological_history model
        order
            Order the returned obstetric_gynecological_history records by any field
        distinct
            Filter obstetric_gynecological_history records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.obstetric_gynecological_history
            The first obstetric_gynecological_history record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second obstetric_gynecological_history record ordered by the last_menstruation field
        obstetric_gynecological_history = await obstetric_gynecological_history.prisma().find_first(
            skip=1,
            order={
                'last_menstruation': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.obstetric_gynecological_historyWhereInput] = None,
        cursor: Optional[types.obstetric_gynecological_historyWhereUniqueInput] = None,
        include: Optional[types.obstetric_gynecological_historyInclude] = None,
        order: Optional[Union[types.obstetric_gynecological_historyOrderByInput, List[types.obstetric_gynecological_historyOrderByInput]]] = None,
        distinct: Optional[List[types.obstetric_gynecological_historyScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single obstetric_gynecological_history record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            obstetric_gynecological_history filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned obstetric_gynecological_history model
        order
            Order the returned obstetric_gynecological_history records by any field
        distinct
            Filter obstetric_gynecological_history records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.obstetric_gynecological_history
            The first obstetric_gynecological_history record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second obstetric_gynecological_history record ordered by the menstruation_characteristics field
        obstetric_gynecological_history = await obstetric_gynecological_history.prisma().find_first_or_raise(
            skip=1,
            order={
                'menstruation_characteristics': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.obstetric_gynecological_historyUpdateInput,
        where: types.obstetric_gynecological_historyWhereUniqueInput,
        include: Optional[types.obstetric_gynecological_historyInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single obstetric_gynecological_history record.

        Parameters
        ----------
        data
            obstetric_gynecological_history record data specifying what to update
        where
            obstetric_gynecological_history filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned obstetric_gynecological_history model

        Returns
        -------
        prisma.models.obstetric_gynecological_history
            The updated obstetric_gynecological_history record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        obstetric_gynecological_history = await obstetric_gynecological_history.prisma().update(
            where={
                'id': 2077067425,
            },
            data={
                # data to update the obstetric_gynecological_history record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.obstetric_gynecological_historyWhereUniqueInput,
        data: types.obstetric_gynecological_historyUpsertInput,
        include: Optional[types.obstetric_gynecological_historyInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            obstetric_gynecological_history filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned obstetric_gynecological_history model

        Returns
        -------
        prisma.models.obstetric_gynecological_history
            The created or updated obstetric_gynecological_history record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        obstetric_gynecological_history = await obstetric_gynecological_history.prisma().upsert(
            where={
                'id': 1672112838,
            },
            data={
                'create': {
                    'id': 1672112838,
                    'patient_id': 'bfhdbjjgfd',
                },
                'update': {
                    'patient_id': 'bfhdbjjgfd',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.obstetric_gynecological_historyUpdateManyMutationInput,
        where: types.obstetric_gynecological_historyWhereInput,
    ) -> int:
        """Update multiple obstetric_gynecological_history records

        Parameters
        ----------
        data
            obstetric_gynecological_history data to update the selected obstetric_gynecological_history records to
        where
            Filter to select the obstetric_gynecological_history records to update

        Returns
        -------
        int
            The total number of obstetric_gynecological_history records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all obstetric_gynecological_history records
        total = await obstetric_gynecological_history.prisma().update_many(
            data={
                'pregnancies': False
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.obstetric_gynecological_historyWhereInput] = None,
        cursor: Optional[types.obstetric_gynecological_historyWhereUniqueInput] = None,
    ) -> int:
        """Count the number of obstetric_gynecological_history records present in the database

        Parameters
        ----------
        select
            Select the obstetric_gynecological_history fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            obstetric_gynecological_history filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.obstetric_gynecological_historyCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await obstetric_gynecological_history.prisma().count()

        # results: prisma.types.obstetric_gynecological_historyCountAggregateOutput
        results = await obstetric_gynecological_history.prisma().count(
            select={
                '_all': True,
                'cervical_cancer': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.obstetric_gynecological_historyCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.obstetric_gynecological_historyWhereInput] = None,
        cursor: Optional[types.obstetric_gynecological_historyWhereUniqueInput] = None,
    ) -> types.obstetric_gynecological_historyCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.obstetric_gynecological_historyCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.obstetric_gynecological_historyWhereInput] = None,
        cursor: Optional[types.obstetric_gynecological_historyWhereUniqueInput] = None,
    ) -> Union[int, types.obstetric_gynecological_historyCountAggregateOutput]:
        """Count the number of obstetric_gynecological_history records present in the database

        Parameters
        ----------
        select
            Select the obstetric_gynecological_history fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            obstetric_gynecological_history filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.obstetric_gynecological_historyCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await obstetric_gynecological_history.prisma().count()

        # results: prisma.types.obstetric_gynecological_historyCountAggregateOutput
        results = await obstetric_gynecological_history.prisma().count(
            select={
                '_all': True,
                'uterine_cancer': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.obstetric_gynecological_historyCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.obstetric_gynecological_historyWhereInput] = None
    ) -> int:
        """Delete multiple obstetric_gynecological_history records.

        Parameters
        ----------
        where
            Optional obstetric_gynecological_history filter to find the records to be deleted

        Returns
        -------
        int
            The total number of obstetric_gynecological_history records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all obstetric_gynecological_history records
        total = await obstetric_gynecological_history.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.obstetric_gynecological_historyScalarFieldKeys'],
        *,
        where: Optional['types.obstetric_gynecological_historyWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.obstetric_gynecological_historyAvgAggregateInput'] = None,
        sum: Optional['types.obstetric_gynecological_historySumAggregateInput'] = None,
        min: Optional['types.obstetric_gynecological_historyMinAggregateInput'] = None,
        max: Optional['types.obstetric_gynecological_historyMaxAggregateInput'] = None,
        having: Optional['types.obstetric_gynecological_historyScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.obstetric_gynecological_historyCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.obstetric_gynecological_historyScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.obstetric_gynecological_historyScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.obstetric_gynecological_historyGroupByOutput']:
        """Group obstetric_gynecological_history records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar obstetric_gynecological_history fields to group records by
        where
            obstetric_gynecological_history filter to select records
        take
            Limit the maximum number of obstetric_gynecological_history records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.obstetric_gynecological_historyGroupByOutput]
            A list of dictionaries representing the obstetric_gynecological_history record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group obstetric_gynecological_history records by breast_cancer values
        # and count how many records are in each group
        results = await obstetric_gynecological_history.prisma().group_by(
            ['breast_cancer'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class pacientesActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.pacientes]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await pacientes.prisma().query_raw(
            'SELECT * FROM pacientes WHERE id = ?',
            'beehgcebbg',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.pacientes
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await pacientes.prisma().query_first(
            'SELECT * FROM pacientes WHERE name = ?',
            'bhdiaidiaf',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.pacientesCreateInput,
        include: Optional[types.pacientesInclude] = None
    ) -> _PrismaModelT:
        """Create a new pacientes record.

        Parameters
        ----------
        data
            pacientes record data
        include
            Specifies which relations should be loaded on the returned pacientes model

        Returns
        -------
        prisma.models.pacientes
            The created pacientes record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a pacientes record from just the required fields
        pacientes = await pacientes.prisma().create(
            data={
                # data to create a pacientes record
                'id': 'deajegcfi',
                'name': 'gabahhhjf',
                'last_name': 'cjagadcjg',
                'birthday': datetime.datetime.utcnow(),
                'sex': 'bifficggej',
                'identification_type': 'bgbbaajbic',
                'identification_number': 'eegghdhjb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.pacientesCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple pacientes records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of pacientes record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await pacientes.prisma().create_many(
            data=[
                {
                    # data to create a pacientes record
                    'id': 'daafgidjg',
                    'name': 'gdcgcgagj',
                    'last_name': 'bhceabbgja',
                    'birthday': datetime.datetime.utcnow(),
                    'sex': 'ehabfhegh',
                    'identification_type': 'bcajcajjbc',
                    'identification_number': 'bfdgheeegf',
                },
                {
                    # data to create a pacientes record
                    'id': 'ececbijji',
                    'name': 'cbcfgdcdhf',
                    'last_name': 'fdgjfbhia',
                    'birthday': datetime.datetime.utcnow(),
                    'sex': 'jcehcdchh',
                    'identification_type': 'bgcbjdhjcc',
                    'identification_number': 'bieiidcabj',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.pacientesWhereUniqueInput,
        include: Optional[types.pacientesInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single pacientes record.

        Parameters
        ----------
        where
            pacientes filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned pacientes model

        Returns
        -------
        prisma.models.pacientes
            The deleted pacientes record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        pacientes = await pacientes.prisma().delete(
            where={
                'id': 'bjcbfcieaa',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.pacientesWhereUniqueInput,
        include: Optional[types.pacientesInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique pacientes record.

        Parameters
        ----------
        where
            pacientes filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned pacientes model

        Returns
        -------
        prisma.models.pacientes
            The found pacientes record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        pacientes = await pacientes.prisma().find_unique(
            where={
                'id': 'cbaaechiej',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.pacientesWhereUniqueInput,
        include: Optional[types.pacientesInclude] = None
    ) -> _PrismaModelT:
        """Find a unique pacientes record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            pacientes filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned pacientes model

        Returns
        -------
        prisma.models.pacientes
            The found pacientes record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        pacientes = await pacientes.prisma().find_unique_or_raise(
            where={
                'id': 'iejbeaaeg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.pacientesWhereInput] = None,
        cursor: Optional[types.pacientesWhereUniqueInput] = None,
        include: Optional[types.pacientesInclude] = None,
        order: Optional[Union[types.pacientesOrderByInput, List[types.pacientesOrderByInput]]] = None,
        distinct: Optional[List[types.pacientesScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple pacientes records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of pacientes records returned
        skip
            Ignore the first N results
        where
            pacientes filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned pacientes model
        order
            Order the returned pacientes records by any field
        distinct
            Filter pacientes records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.pacientes]
            The list of all pacientes records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 pacientes records
        pacientes = await pacientes.prisma().find_many(take=10)

        # find the first 5 pacientes records ordered by the last_name field
        pacientes = await pacientes.prisma().find_many(
            take=5,
            order={
                'last_name': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.pacientesWhereInput] = None,
        cursor: Optional[types.pacientesWhereUniqueInput] = None,
        include: Optional[types.pacientesInclude] = None,
        order: Optional[Union[types.pacientesOrderByInput, List[types.pacientesOrderByInput]]] = None,
        distinct: Optional[List[types.pacientesScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single pacientes record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            pacientes filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned pacientes model
        order
            Order the returned pacientes records by any field
        distinct
            Filter pacientes records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.pacientes
            The first pacientes record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second pacientes record ordered by the birthday field
        pacientes = await pacientes.prisma().find_first(
            skip=1,
            order={
                'birthday': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.pacientesWhereInput] = None,
        cursor: Optional[types.pacientesWhereUniqueInput] = None,
        include: Optional[types.pacientesInclude] = None,
        order: Optional[Union[types.pacientesOrderByInput, List[types.pacientesOrderByInput]]] = None,
        distinct: Optional[List[types.pacientesScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single pacientes record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            pacientes filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned pacientes model
        order
            Order the returned pacientes records by any field
        distinct
            Filter pacientes records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.pacientes
            The first pacientes record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second pacientes record ordered by the sex field
        pacientes = await pacientes.prisma().find_first_or_raise(
            skip=1,
            order={
                'sex': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.pacientesUpdateInput,
        where: types.pacientesWhereUniqueInput,
        include: Optional[types.pacientesInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single pacientes record.

        Parameters
        ----------
        data
            pacientes record data specifying what to update
        where
            pacientes filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned pacientes model

        Returns
        -------
        prisma.models.pacientes
            The updated pacientes record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        pacientes = await pacientes.prisma().update(
            where={
                'id': 'jcibfcbhf',
            },
            data={
                # data to update the pacientes record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.pacientesWhereUniqueInput,
        data: types.pacientesUpsertInput,
        include: Optional[types.pacientesInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            pacientes filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned pacientes model

        Returns
        -------
        prisma.models.pacientes
            The created or updated pacientes record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        pacientes = await pacientes.prisma().upsert(
            where={
                'id': 'chdadcaga',
            },
            data={
                'create': {
                    'id': 'chdadcaga',
                    'name': 'cbcfgdcdhf',
                    'last_name': 'fdgjfbhia',
                    'birthday': datetime.datetime.utcnow(),
                    'sex': 'jcehcdchh',
                    'identification_type': 'bgcbjdhjcc',
                    'identification_number': 'bieiidcabj',
                },
                'update': {
                    'name': 'cbcfgdcdhf',
                    'last_name': 'fdgjfbhia',
                    'birthday': datetime.datetime.utcnow(),
                    'sex': 'jcehcdchh',
                    'identification_type': 'bgcbjdhjcc',
                    'identification_number': 'bieiidcabj',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.pacientesUpdateManyMutationInput,
        where: types.pacientesWhereInput,
    ) -> int:
        """Update multiple pacientes records

        Parameters
        ----------
        data
            pacientes data to update the selected pacientes records to
        where
            Filter to select the pacientes records to update

        Returns
        -------
        int
            The total number of pacientes records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all pacientes records
        total = await pacientes.prisma().update_many(
            data={
                'email': 'jicieifbh'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.pacientesWhereInput] = None,
        cursor: Optional[types.pacientesWhereUniqueInput] = None,
    ) -> int:
        """Count the number of pacientes records present in the database

        Parameters
        ----------
        select
            Select the pacientes fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            pacientes filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.pacientesCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await pacientes.prisma().count()

        # results: prisma.types.pacientesCountAggregateOutput
        results = await pacientes.prisma().count(
            select={
                '_all': True,
                'phone': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.pacientesCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.pacientesWhereInput] = None,
        cursor: Optional[types.pacientesWhereUniqueInput] = None,
    ) -> types.pacientesCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.pacientesCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.pacientesWhereInput] = None,
        cursor: Optional[types.pacientesWhereUniqueInput] = None,
    ) -> Union[int, types.pacientesCountAggregateOutput]:
        """Count the number of pacientes records present in the database

        Parameters
        ----------
        select
            Select the pacientes fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            pacientes filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.pacientesCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await pacientes.prisma().count()

        # results: prisma.types.pacientesCountAggregateOutput
        results = await pacientes.prisma().count(
            select={
                '_all': True,
                'identification_type': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.pacientesCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.pacientesWhereInput] = None
    ) -> int:
        """Delete multiple pacientes records.

        Parameters
        ----------
        where
            Optional pacientes filter to find the records to be deleted

        Returns
        -------
        int
            The total number of pacientes records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all pacientes records
        total = await pacientes.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.pacientesScalarFieldKeys'],
        *,
        where: Optional['types.pacientesWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.pacientesAvgAggregateInput'] = None,
        sum: Optional['types.pacientesSumAggregateInput'] = None,
        min: Optional['types.pacientesMinAggregateInput'] = None,
        max: Optional['types.pacientesMaxAggregateInput'] = None,
        having: Optional['types.pacientesScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.pacientesCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.pacientesScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.pacientesScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.pacientesGroupByOutput']:
        """Group pacientes records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar pacientes fields to group records by
        where
            pacientes filter to select records
        take
            Limit the maximum number of pacientes records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.pacientesGroupByOutput]
            A list of dictionaries representing the pacientes record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group pacientes records by identification_number values
        # and count how many records are in each group
        results = await pacientes.prisma().group_by(
            ['identification_number'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class pathological_historyActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.pathological_history]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await pathological_history.prisma().query_raw(
            'SELECT * FROM pathological_history WHERE id = ?',
            510737498,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.pathological_history
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await pathological_history.prisma().query_first(
            'SELECT * FROM pathological_history WHERE patient_id = ?',
            'cbbheiicgh',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.pathological_historyCreateInput,
        include: Optional[types.pathological_historyInclude] = None
    ) -> _PrismaModelT:
        """Create a new pathological_history record.

        Parameters
        ----------
        data
            pathological_history record data
        include
            Specifies which relations should be loaded on the returned pathological_history model

        Returns
        -------
        prisma.models.pathological_history
            The created pathological_history record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a pathological_history record from just the required fields
        pathological_history = await pathological_history.prisma().create(
            data={
                # data to create a pathological_history record
                'patient_id': 'beabjeejdg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.pathological_historyCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple pathological_history records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of pathological_history record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await pathological_history.prisma().create_many(
            data=[
                {
                    # data to create a pathological_history record
                    'patient_id': 'bcjhgahffd',
                },
                {
                    # data to create a pathological_history record
                    'patient_id': 'fbjeiiffa',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.pathological_historyWhereUniqueInput,
        include: Optional[types.pathological_historyInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single pathological_history record.

        Parameters
        ----------
        where
            pathological_history filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned pathological_history model

        Returns
        -------
        prisma.models.pathological_history
            The deleted pathological_history record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        pathological_history = await pathological_history.prisma().delete(
            where={
                'id': 976832615,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.pathological_historyWhereUniqueInput,
        include: Optional[types.pathological_historyInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique pathological_history record.

        Parameters
        ----------
        where
            pathological_history filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned pathological_history model

        Returns
        -------
        prisma.models.pathological_history
            The found pathological_history record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        pathological_history = await pathological_history.prisma().find_unique(
            where={
                'id': 1696425492,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.pathological_historyWhereUniqueInput,
        include: Optional[types.pathological_historyInclude] = None
    ) -> _PrismaModelT:
        """Find a unique pathological_history record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            pathological_history filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned pathological_history model

        Returns
        -------
        prisma.models.pathological_history
            The found pathological_history record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        pathological_history = await pathological_history.prisma().find_unique_or_raise(
            where={
                'id': 169262781,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.pathological_historyWhereInput] = None,
        cursor: Optional[types.pathological_historyWhereUniqueInput] = None,
        include: Optional[types.pathological_historyInclude] = None,
        order: Optional[Union[types.pathological_historyOrderByInput, List[types.pathological_historyOrderByInput]]] = None,
        distinct: Optional[List[types.pathological_historyScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple pathological_history records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of pathological_history records returned
        skip
            Ignore the first N results
        where
            pathological_history filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned pathological_history model
        order
            Order the returned pathological_history records by any field
        distinct
            Filter pathological_history records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.pathological_history]
            The list of all pathological_history records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 pathological_history records
        pathological_historys = await pathological_history.prisma().find_many(take=10)

        # find the first 5 pathological_history records ordered by the previous_hospitalization field
        pathological_historys = await pathological_history.prisma().find_many(
            take=5,
            order={
                'previous_hospitalization': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.pathological_historyWhereInput] = None,
        cursor: Optional[types.pathological_historyWhereUniqueInput] = None,
        include: Optional[types.pathological_historyInclude] = None,
        order: Optional[Union[types.pathological_historyOrderByInput, List[types.pathological_historyOrderByInput]]] = None,
        distinct: Optional[List[types.pathological_historyScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single pathological_history record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            pathological_history filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned pathological_history model
        order
            Order the returned pathological_history records by any field
        distinct
            Filter pathological_history records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.pathological_history
            The first pathological_history record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second pathological_history record ordered by the previous_surgeries field
        pathological_history = await pathological_history.prisma().find_first(
            skip=1,
            order={
                'previous_surgeries': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.pathological_historyWhereInput] = None,
        cursor: Optional[types.pathological_historyWhereUniqueInput] = None,
        include: Optional[types.pathological_historyInclude] = None,
        order: Optional[Union[types.pathological_historyOrderByInput, List[types.pathological_historyOrderByInput]]] = None,
        distinct: Optional[List[types.pathological_historyScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single pathological_history record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            pathological_history filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned pathological_history model
        order
            Order the returned pathological_history records by any field
        distinct
            Filter pathological_history records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.pathological_history
            The first pathological_history record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second pathological_history record ordered by the diabetes field
        pathological_history = await pathological_history.prisma().find_first_or_raise(
            skip=1,
            order={
                'diabetes': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.pathological_historyUpdateInput,
        where: types.pathological_historyWhereUniqueInput,
        include: Optional[types.pathological_historyInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single pathological_history record.

        Parameters
        ----------
        data
            pathological_history record data specifying what to update
        where
            pathological_history filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned pathological_history model

        Returns
        -------
        prisma.models.pathological_history
            The updated pathological_history record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        pathological_history = await pathological_history.prisma().update(
            where={
                'id': 1023081650,
            },
            data={
                # data to update the pathological_history record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.pathological_historyWhereUniqueInput,
        data: types.pathological_historyUpsertInput,
        include: Optional[types.pathological_historyInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            pathological_history filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned pathological_history model

        Returns
        -------
        prisma.models.pathological_history
            The created or updated pathological_history record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        pathological_history = await pathological_history.prisma().upsert(
            where={
                'id': 327681027,
            },
            data={
                'create': {
                    'id': 327681027,
                    'patient_id': 'fbjeiiffa',
                },
                'update': {
                    'patient_id': 'fbjeiiffa',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.pathological_historyUpdateManyMutationInput,
        where: types.pathological_historyWhereInput,
    ) -> int:
        """Update multiple pathological_history records

        Parameters
        ----------
        data
            pathological_history data to update the selected pathological_history records to
        where
            Filter to select the pathological_history records to update

        Returns
        -------
        int
            The total number of pathological_history records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all pathological_history records
        total = await pathological_history.prisma().update_many(
            data={
                'thyroid_diseases': True
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.pathological_historyWhereInput] = None,
        cursor: Optional[types.pathological_historyWhereUniqueInput] = None,
    ) -> int:
        """Count the number of pathological_history records present in the database

        Parameters
        ----------
        select
            Select the pathological_history fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            pathological_history filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.pathological_historyCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await pathological_history.prisma().count()

        # results: prisma.types.pathological_historyCountAggregateOutput
        results = await pathological_history.prisma().count(
            select={
                '_all': True,
                'arterial_hypertension': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.pathological_historyCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.pathological_historyWhereInput] = None,
        cursor: Optional[types.pathological_historyWhereUniqueInput] = None,
    ) -> types.pathological_historyCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.pathological_historyCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.pathological_historyWhereInput] = None,
        cursor: Optional[types.pathological_historyWhereUniqueInput] = None,
    ) -> Union[int, types.pathological_historyCountAggregateOutput]:
        """Count the number of pathological_history records present in the database

        Parameters
        ----------
        select
            Select the pathological_history fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            pathological_history filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.pathological_historyCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await pathological_history.prisma().count()

        # results: prisma.types.pathological_historyCountAggregateOutput
        results = await pathological_history.prisma().count(
            select={
                '_all': True,
                'cardiopary': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.pathological_historyCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.pathological_historyWhereInput] = None
    ) -> int:
        """Delete multiple pathological_history records.

        Parameters
        ----------
        where
            Optional pathological_history filter to find the records to be deleted

        Returns
        -------
        int
            The total number of pathological_history records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all pathological_history records
        total = await pathological_history.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.pathological_historyScalarFieldKeys'],
        *,
        where: Optional['types.pathological_historyWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.pathological_historyAvgAggregateInput'] = None,
        sum: Optional['types.pathological_historySumAggregateInput'] = None,
        min: Optional['types.pathological_historyMinAggregateInput'] = None,
        max: Optional['types.pathological_historyMaxAggregateInput'] = None,
        having: Optional['types.pathological_historyScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.pathological_historyCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.pathological_historyScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.pathological_historyScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.pathological_historyGroupByOutput']:
        """Group pathological_history records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar pathological_history fields to group records by
        where
            pathological_history filter to select records
        take
            Limit the maximum number of pathological_history records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.pathological_historyGroupByOutput]
            A list of dictionaries representing the pathological_history record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group pathological_history records by trauma values
        # and count how many records are in each group
        results = await pathological_history.prisma().group_by(
            ['trauma'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class patient_by_userActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.patient_by_user]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await patient_by_user.prisma().query_raw(
            'SELECT * FROM patient_by_user WHERE id = ?',
            'cacjdfhejh',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.patient_by_user
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await patient_by_user.prisma().query_first(
            'SELECT * FROM patient_by_user WHERE user_id = ?',
            'bdbifjhbbi',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.patient_by_userCreateInput,
        include: Optional[types.patient_by_userInclude] = None
    ) -> _PrismaModelT:
        """Create a new patient_by_user record.

        Parameters
        ----------
        data
            patient_by_user record data
        include
            Specifies which relations should be loaded on the returned patient_by_user model

        Returns
        -------
        prisma.models.patient_by_user
            The created patient_by_user record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a patient_by_user record from just the required fields
        patient_by_user = await patient_by_user.prisma().create(
            data={
                # data to create a patient_by_user record
                'id': 'cbccbbcdfb',
                'user_id': 'bacejedaca',
                'patient_id': 'bhbhdahfaj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.patient_by_userCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple patient_by_user records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of patient_by_user record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await patient_by_user.prisma().create_many(
            data=[
                {
                    # data to create a patient_by_user record
                    'id': 'bfjibceaec',
                    'user_id': 'ibhgcdbgd',
                    'patient_id': 'badaffhddg',
                },
                {
                    # data to create a patient_by_user record
                    'id': 'bbdbfcfihd',
                    'user_id': 'cbagggbji',
                    'patient_id': 'bchgafhjed',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.patient_by_userWhereUniqueInput,
        include: Optional[types.patient_by_userInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single patient_by_user record.

        Parameters
        ----------
        where
            patient_by_user filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned patient_by_user model

        Returns
        -------
        prisma.models.patient_by_user
            The deleted patient_by_user record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        patient_by_user = await patient_by_user.prisma().delete(
            where={
                'id': 'heffgjdei',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.patient_by_userWhereUniqueInput,
        include: Optional[types.patient_by_userInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique patient_by_user record.

        Parameters
        ----------
        where
            patient_by_user filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned patient_by_user model

        Returns
        -------
        prisma.models.patient_by_user
            The found patient_by_user record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        patient_by_user = await patient_by_user.prisma().find_unique(
            where={
                'id': 'dahihgbeb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.patient_by_userWhereUniqueInput,
        include: Optional[types.patient_by_userInclude] = None
    ) -> _PrismaModelT:
        """Find a unique patient_by_user record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            patient_by_user filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned patient_by_user model

        Returns
        -------
        prisma.models.patient_by_user
            The found patient_by_user record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        patient_by_user = await patient_by_user.prisma().find_unique_or_raise(
            where={
                'id': 'bgheaejbcc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.patient_by_userWhereInput] = None,
        cursor: Optional[types.patient_by_userWhereUniqueInput] = None,
        include: Optional[types.patient_by_userInclude] = None,
        order: Optional[Union[types.patient_by_userOrderByInput, List[types.patient_by_userOrderByInput]]] = None,
        distinct: Optional[List[types.patient_by_userScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple patient_by_user records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of patient_by_user records returned
        skip
            Ignore the first N results
        where
            patient_by_user filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned patient_by_user model
        order
            Order the returned patient_by_user records by any field
        distinct
            Filter patient_by_user records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.patient_by_user]
            The list of all patient_by_user records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 patient_by_user records
        patient_by_users = await patient_by_user.prisma().find_many(take=10)

        # find the first 5 patient_by_user records ordered by the patient_id field
        patient_by_users = await patient_by_user.prisma().find_many(
            take=5,
            order={
                'patient_id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.patient_by_userWhereInput] = None,
        cursor: Optional[types.patient_by_userWhereUniqueInput] = None,
        include: Optional[types.patient_by_userInclude] = None,
        order: Optional[Union[types.patient_by_userOrderByInput, List[types.patient_by_userOrderByInput]]] = None,
        distinct: Optional[List[types.patient_by_userScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single patient_by_user record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            patient_by_user filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned patient_by_user model
        order
            Order the returned patient_by_user records by any field
        distinct
            Filter patient_by_user records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.patient_by_user
            The first patient_by_user record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second patient_by_user record ordered by the id field
        patient_by_user = await patient_by_user.prisma().find_first(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.patient_by_userWhereInput] = None,
        cursor: Optional[types.patient_by_userWhereUniqueInput] = None,
        include: Optional[types.patient_by_userInclude] = None,
        order: Optional[Union[types.patient_by_userOrderByInput, List[types.patient_by_userOrderByInput]]] = None,
        distinct: Optional[List[types.patient_by_userScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single patient_by_user record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            patient_by_user filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned patient_by_user model
        order
            Order the returned patient_by_user records by any field
        distinct
            Filter patient_by_user records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.patient_by_user
            The first patient_by_user record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second patient_by_user record ordered by the user_id field
        patient_by_user = await patient_by_user.prisma().find_first_or_raise(
            skip=1,
            order={
                'user_id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.patient_by_userUpdateInput,
        where: types.patient_by_userWhereUniqueInput,
        include: Optional[types.patient_by_userInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single patient_by_user record.

        Parameters
        ----------
        data
            patient_by_user record data specifying what to update
        where
            patient_by_user filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned patient_by_user model

        Returns
        -------
        prisma.models.patient_by_user
            The updated patient_by_user record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        patient_by_user = await patient_by_user.prisma().update(
            where={
                'id': 'bfcgifeged',
            },
            data={
                # data to update the patient_by_user record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.patient_by_userWhereUniqueInput,
        data: types.patient_by_userUpsertInput,
        include: Optional[types.patient_by_userInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            patient_by_user filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned patient_by_user model

        Returns
        -------
        prisma.models.patient_by_user
            The created or updated patient_by_user record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        patient_by_user = await patient_by_user.prisma().upsert(
            where={
                'id': 'jfiahhbae',
            },
            data={
                'create': {
                    'id': 'jfiahhbae',
                    'user_id': 'cbagggbji',
                    'patient_id': 'bchgafhjed',
                },
                'update': {
                    'user_id': 'cbagggbji',
                    'patient_id': 'bchgafhjed',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.patient_by_userUpdateManyMutationInput,
        where: types.patient_by_userWhereInput,
    ) -> int:
        """Update multiple patient_by_user records

        Parameters
        ----------
        data
            patient_by_user data to update the selected patient_by_user records to
        where
            Filter to select the patient_by_user records to update

        Returns
        -------
        int
            The total number of patient_by_user records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all patient_by_user records
        total = await patient_by_user.prisma().update_many(
            data={
                'patient_id': 'bfbdafajcb'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.patient_by_userWhereInput] = None,
        cursor: Optional[types.patient_by_userWhereUniqueInput] = None,
    ) -> int:
        """Count the number of patient_by_user records present in the database

        Parameters
        ----------
        select
            Select the patient_by_user fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            patient_by_user filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.patient_by_userCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await patient_by_user.prisma().count()

        # results: prisma.types.patient_by_userCountAggregateOutput
        results = await patient_by_user.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.patient_by_userCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.patient_by_userWhereInput] = None,
        cursor: Optional[types.patient_by_userWhereUniqueInput] = None,
    ) -> types.patient_by_userCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.patient_by_userCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.patient_by_userWhereInput] = None,
        cursor: Optional[types.patient_by_userWhereUniqueInput] = None,
    ) -> Union[int, types.patient_by_userCountAggregateOutput]:
        """Count the number of patient_by_user records present in the database

        Parameters
        ----------
        select
            Select the patient_by_user fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            patient_by_user filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.patient_by_userCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await patient_by_user.prisma().count()

        # results: prisma.types.patient_by_userCountAggregateOutput
        results = await patient_by_user.prisma().count(
            select={
                '_all': True,
                'user_id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.patient_by_userCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.patient_by_userWhereInput] = None
    ) -> int:
        """Delete multiple patient_by_user records.

        Parameters
        ----------
        where
            Optional patient_by_user filter to find the records to be deleted

        Returns
        -------
        int
            The total number of patient_by_user records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all patient_by_user records
        total = await patient_by_user.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.patient_by_userScalarFieldKeys'],
        *,
        where: Optional['types.patient_by_userWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.patient_by_userAvgAggregateInput'] = None,
        sum: Optional['types.patient_by_userSumAggregateInput'] = None,
        min: Optional['types.patient_by_userMinAggregateInput'] = None,
        max: Optional['types.patient_by_userMaxAggregateInput'] = None,
        having: Optional['types.patient_by_userScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.patient_by_userCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.patient_by_userScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.patient_by_userScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.patient_by_userGroupByOutput']:
        """Group patient_by_user records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar patient_by_user fields to group records by
        where
            patient_by_user filter to select records
        take
            Limit the maximum number of patient_by_user records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.patient_by_userGroupByOutput]
            A list of dictionaries representing the patient_by_user record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group patient_by_user records by patient_id values
        # and count how many records are in each group
        results = await patient_by_user.prisma().group_by(
            ['patient_id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class perinatal_historyActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.perinatal_history]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await perinatal_history.prisma().query_raw(
            'SELECT * FROM perinatal_history WHERE id = ?',
            204674734,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.perinatal_history
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await perinatal_history.prisma().query_first(
            'SELECT * FROM perinatal_history WHERE patient_id = ?',
            'caghgfbggd',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.perinatal_historyCreateInput,
        include: Optional[types.perinatal_historyInclude] = None
    ) -> _PrismaModelT:
        """Create a new perinatal_history record.

        Parameters
        ----------
        data
            perinatal_history record data
        include
            Specifies which relations should be loaded on the returned perinatal_history model

        Returns
        -------
        prisma.models.perinatal_history
            The created perinatal_history record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a perinatal_history record from just the required fields
        perinatal_history = await perinatal_history.prisma().create(
            data={
                # data to create a perinatal_history record
                'patient_id': 'bbidjbbjaa',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.perinatal_historyCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple perinatal_history records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of perinatal_history record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await perinatal_history.prisma().create_many(
            data=[
                {
                    # data to create a perinatal_history record
                    'patient_id': 'bfijhaejdd',
                },
                {
                    # data to create a perinatal_history record
                    'patient_id': 'bcedehfiji',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.perinatal_historyWhereUniqueInput,
        include: Optional[types.perinatal_historyInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single perinatal_history record.

        Parameters
        ----------
        where
            perinatal_history filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned perinatal_history model

        Returns
        -------
        prisma.models.perinatal_history
            The deleted perinatal_history record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        perinatal_history = await perinatal_history.prisma().delete(
            where={
                'id': 1369828971,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.perinatal_historyWhereUniqueInput,
        include: Optional[types.perinatal_historyInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique perinatal_history record.

        Parameters
        ----------
        where
            perinatal_history filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned perinatal_history model

        Returns
        -------
        prisma.models.perinatal_history
            The found perinatal_history record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        perinatal_history = await perinatal_history.prisma().find_unique(
            where={
                'id': 1678593480,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.perinatal_historyWhereUniqueInput,
        include: Optional[types.perinatal_historyInclude] = None
    ) -> _PrismaModelT:
        """Find a unique perinatal_history record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            perinatal_history filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned perinatal_history model

        Returns
        -------
        prisma.models.perinatal_history
            The found perinatal_history record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        perinatal_history = await perinatal_history.prisma().find_unique_or_raise(
            where={
                'id': 403521121,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.perinatal_historyWhereInput] = None,
        cursor: Optional[types.perinatal_historyWhereUniqueInput] = None,
        include: Optional[types.perinatal_historyInclude] = None,
        order: Optional[Union[types.perinatal_historyOrderByInput, List[types.perinatal_historyOrderByInput]]] = None,
        distinct: Optional[List[types.perinatal_historyScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple perinatal_history records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of perinatal_history records returned
        skip
            Ignore the first N results
        where
            perinatal_history filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned perinatal_history model
        order
            Order the returned perinatal_history records by any field
        distinct
            Filter perinatal_history records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.perinatal_history]
            The list of all perinatal_history records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 perinatal_history records
        perinatal_historys = await perinatal_history.prisma().find_many(take=10)

        # find the first 5 perinatal_history records ordered by the last_menstrual_cycle field
        perinatal_historys = await perinatal_history.prisma().find_many(
            take=5,
            order={
                'last_menstrual_cycle': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.perinatal_historyWhereInput] = None,
        cursor: Optional[types.perinatal_historyWhereUniqueInput] = None,
        include: Optional[types.perinatal_historyInclude] = None,
        order: Optional[Union[types.perinatal_historyOrderByInput, List[types.perinatal_historyOrderByInput]]] = None,
        distinct: Optional[List[types.perinatal_historyScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single perinatal_history record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            perinatal_history filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned perinatal_history model
        order
            Order the returned perinatal_history records by any field
        distinct
            Filter perinatal_history records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.perinatal_history
            The first perinatal_history record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second perinatal_history record ordered by the cycle_duration field
        perinatal_history = await perinatal_history.prisma().find_first(
            skip=1,
            order={
                'cycle_duration': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.perinatal_historyWhereInput] = None,
        cursor: Optional[types.perinatal_historyWhereUniqueInput] = None,
        include: Optional[types.perinatal_historyInclude] = None,
        order: Optional[Union[types.perinatal_historyOrderByInput, List[types.perinatal_historyOrderByInput]]] = None,
        distinct: Optional[List[types.perinatal_historyScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single perinatal_history record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            perinatal_history filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned perinatal_history model
        order
            Order the returned perinatal_history records by any field
        distinct
            Filter perinatal_history records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.perinatal_history
            The first perinatal_history record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second perinatal_history record ordered by the last_contraceptive_method_used field
        perinatal_history = await perinatal_history.prisma().find_first_or_raise(
            skip=1,
            order={
                'last_contraceptive_method_used': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.perinatal_historyUpdateInput,
        where: types.perinatal_historyWhereUniqueInput,
        include: Optional[types.perinatal_historyInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single perinatal_history record.

        Parameters
        ----------
        data
            perinatal_history record data specifying what to update
        where
            perinatal_history filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned perinatal_history model

        Returns
        -------
        prisma.models.perinatal_history
            The updated perinatal_history record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        perinatal_history = await perinatal_history.prisma().update(
            where={
                'id': 648760710,
            },
            data={
                # data to update the perinatal_history record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.perinatal_historyWhereUniqueInput,
        data: types.perinatal_historyUpsertInput,
        include: Optional[types.perinatal_historyInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            perinatal_history filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned perinatal_history model

        Returns
        -------
        prisma.models.perinatal_history
            The created or updated perinatal_history record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        perinatal_history = await perinatal_history.prisma().upsert(
            where={
                'id': 607323719,
            },
            data={
                'create': {
                    'id': 607323719,
                    'patient_id': 'bcedehfiji',
                },
                'update': {
                    'patient_id': 'bcedehfiji',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.perinatal_historyUpdateManyMutationInput,
        where: types.perinatal_historyWhereInput,
    ) -> int:
        """Update multiple perinatal_history records

        Parameters
        ----------
        data
            perinatal_history data to update the selected perinatal_history records to
        where
            Filter to select the perinatal_history records to update

        Returns
        -------
        int
            The total number of perinatal_history records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all perinatal_history records
        total = await perinatal_history.prisma().update_many(
            data={
                'assisted_conception': True
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.perinatal_historyWhereInput] = None,
        cursor: Optional[types.perinatal_historyWhereUniqueInput] = None,
    ) -> int:
        """Count the number of perinatal_history records present in the database

        Parameters
        ----------
        select
            Select the perinatal_history fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            perinatal_history filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.perinatal_historyCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await perinatal_history.prisma().count()

        # results: prisma.types.perinatal_historyCountAggregateOutput
        results = await perinatal_history.prisma().count(
            select={
                '_all': True,
                'estimated_due_date_based_on_LMP': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.perinatal_historyCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.perinatal_historyWhereInput] = None,
        cursor: Optional[types.perinatal_historyWhereUniqueInput] = None,
    ) -> types.perinatal_historyCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.perinatal_historyCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.perinatal_historyWhereInput] = None,
        cursor: Optional[types.perinatal_historyWhereUniqueInput] = None,
    ) -> Union[int, types.perinatal_historyCountAggregateOutput]:
        """Count the number of perinatal_history records present in the database

        Parameters
        ----------
        select
            Select the perinatal_history fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            perinatal_history filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.perinatal_historyCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await perinatal_history.prisma().count()

        # results: prisma.types.perinatal_historyCountAggregateOutput
        results = await perinatal_history.prisma().count(
            select={
                '_all': True,
                'EDD': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.perinatal_historyCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.perinatal_historyWhereInput] = None
    ) -> int:
        """Delete multiple perinatal_history records.

        Parameters
        ----------
        where
            Optional perinatal_history filter to find the records to be deleted

        Returns
        -------
        int
            The total number of perinatal_history records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all perinatal_history records
        total = await perinatal_history.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.perinatal_historyScalarFieldKeys'],
        *,
        where: Optional['types.perinatal_historyWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.perinatal_historyAvgAggregateInput'] = None,
        sum: Optional['types.perinatal_historySumAggregateInput'] = None,
        min: Optional['types.perinatal_historyMinAggregateInput'] = None,
        max: Optional['types.perinatal_historyMaxAggregateInput'] = None,
        having: Optional['types.perinatal_historyScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.perinatal_historyCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.perinatal_historyScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.perinatal_historyScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.perinatal_historyGroupByOutput']:
        """Group perinatal_history records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar perinatal_history fields to group records by
        where
            perinatal_history filter to select records
        take
            Limit the maximum number of perinatal_history records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.perinatal_historyGroupByOutput]
            A list of dictionaries representing the perinatal_history record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group perinatal_history records by pregnancy_notes values
        # and count how many records are in each group
        results = await perinatal_history.prisma().group_by(
            ['pregnancy_notes'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class postnatal_historyActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.postnatal_history]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await postnatal_history.prisma().query_raw(
            'SELECT * FROM postnatal_history WHERE id = ?',
            629039005,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.postnatal_history
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await postnatal_history.prisma().query_first(
            'SELECT * FROM postnatal_history WHERE patient_id = ?',
            'bcbebgiaic',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.postnatal_historyCreateInput,
        include: Optional[types.postnatal_historyInclude] = None
    ) -> _PrismaModelT:
        """Create a new postnatal_history record.

        Parameters
        ----------
        data
            postnatal_history record data
        include
            Specifies which relations should be loaded on the returned postnatal_history model

        Returns
        -------
        prisma.models.postnatal_history
            The created postnatal_history record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a postnatal_history record from just the required fields
        postnatal_history = await postnatal_history.prisma().create(
            data={
                # data to create a postnatal_history record
                'patient_id': 'ijigbdcbj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.postnatal_historyCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple postnatal_history records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of postnatal_history record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await postnatal_history.prisma().create_many(
            data=[
                {
                    # data to create a postnatal_history record
                    'patient_id': 'gfidhicai',
                },
                {
                    # data to create a postnatal_history record
                    'patient_id': 'jfegcaafh',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.postnatal_historyWhereUniqueInput,
        include: Optional[types.postnatal_historyInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single postnatal_history record.

        Parameters
        ----------
        where
            postnatal_history filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned postnatal_history model

        Returns
        -------
        prisma.models.postnatal_history
            The deleted postnatal_history record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        postnatal_history = await postnatal_history.prisma().delete(
            where={
                'id': 1214809950,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.postnatal_historyWhereUniqueInput,
        include: Optional[types.postnatal_historyInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique postnatal_history record.

        Parameters
        ----------
        where
            postnatal_history filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned postnatal_history model

        Returns
        -------
        prisma.models.postnatal_history
            The found postnatal_history record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        postnatal_history = await postnatal_history.prisma().find_unique(
            where={
                'id': 1047820095,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.postnatal_historyWhereUniqueInput,
        include: Optional[types.postnatal_historyInclude] = None
    ) -> _PrismaModelT:
        """Find a unique postnatal_history record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            postnatal_history filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned postnatal_history model

        Returns
        -------
        prisma.models.postnatal_history
            The found postnatal_history record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        postnatal_history = await postnatal_history.prisma().find_unique_or_raise(
            where={
                'id': 1302734860,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.postnatal_historyWhereInput] = None,
        cursor: Optional[types.postnatal_historyWhereUniqueInput] = None,
        include: Optional[types.postnatal_historyInclude] = None,
        order: Optional[Union[types.postnatal_historyOrderByInput, List[types.postnatal_historyOrderByInput]]] = None,
        distinct: Optional[List[types.postnatal_historyScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple postnatal_history records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of postnatal_history records returned
        skip
            Ignore the first N results
        where
            postnatal_history filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned postnatal_history model
        order
            Order the returned postnatal_history records by any field
        distinct
            Filter postnatal_history records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.postnatal_history]
            The list of all postnatal_history records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 postnatal_history records
        postnatal_historys = await postnatal_history.prisma().find_many(take=10)

        # find the first 5 postnatal_history records ordered by the birth_details field
        postnatal_historys = await postnatal_history.prisma().find_many(
            take=5,
            order={
                'birth_details': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.postnatal_historyWhereInput] = None,
        cursor: Optional[types.postnatal_historyWhereUniqueInput] = None,
        include: Optional[types.postnatal_historyInclude] = None,
        order: Optional[Union[types.postnatal_historyOrderByInput, List[types.postnatal_historyOrderByInput]]] = None,
        distinct: Optional[List[types.postnatal_historyScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single postnatal_history record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            postnatal_history filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned postnatal_history model
        order
            Order the returned postnatal_history records by any field
        distinct
            Filter postnatal_history records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.postnatal_history
            The first postnatal_history record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second postnatal_history record ordered by the babys_name field
        postnatal_history = await postnatal_history.prisma().find_first(
            skip=1,
            order={
                'babys_name': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.postnatal_historyWhereInput] = None,
        cursor: Optional[types.postnatal_historyWhereUniqueInput] = None,
        include: Optional[types.postnatal_historyInclude] = None,
        order: Optional[Union[types.postnatal_historyOrderByInput, List[types.postnatal_historyOrderByInput]]] = None,
        distinct: Optional[List[types.postnatal_historyScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single postnatal_history record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            postnatal_history filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned postnatal_history model
        order
            Order the returned postnatal_history records by any field
        distinct
            Filter postnatal_history records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.postnatal_history
            The first postnatal_history record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second postnatal_history record ordered by the birth_weight field
        postnatal_history = await postnatal_history.prisma().find_first_or_raise(
            skip=1,
            order={
                'birth_weight': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.postnatal_historyUpdateInput,
        where: types.postnatal_historyWhereUniqueInput,
        include: Optional[types.postnatal_historyInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single postnatal_history record.

        Parameters
        ----------
        data
            postnatal_history record data specifying what to update
        where
            postnatal_history filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned postnatal_history model

        Returns
        -------
        prisma.models.postnatal_history
            The updated postnatal_history record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        postnatal_history = await postnatal_history.prisma().update(
            where={
                'id': 893052245,
            },
            data={
                # data to update the postnatal_history record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.postnatal_historyWhereUniqueInput,
        data: types.postnatal_historyUpsertInput,
        include: Optional[types.postnatal_historyInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            postnatal_history filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned postnatal_history model

        Returns
        -------
        prisma.models.postnatal_history
            The created or updated postnatal_history record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        postnatal_history = await postnatal_history.prisma().upsert(
            where={
                'id': 280083306,
            },
            data={
                'create': {
                    'id': 280083306,
                    'patient_id': 'jfegcaafh',
                },
                'update': {
                    'patient_id': 'jfegcaafh',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.postnatal_historyUpdateManyMutationInput,
        where: types.postnatal_historyWhereInput,
    ) -> int:
        """Update multiple postnatal_history records

        Parameters
        ----------
        data
            postnatal_history data to update the selected postnatal_history records to
        where
            Filter to select the postnatal_history records to update

        Returns
        -------
        int
            The total number of postnatal_history records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all postnatal_history records
        total = await postnatal_history.prisma().update_many(
            data={
                'baby_health': 'fejggijff'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.postnatal_historyWhereInput] = None,
        cursor: Optional[types.postnatal_historyWhereUniqueInput] = None,
    ) -> int:
        """Count the number of postnatal_history records present in the database

        Parameters
        ----------
        select
            Select the postnatal_history fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            postnatal_history filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.postnatal_historyCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await postnatal_history.prisma().count()

        # results: prisma.types.postnatal_historyCountAggregateOutput
        results = await postnatal_history.prisma().count(
            select={
                '_all': True,
                'baby_feeding': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.postnatal_historyCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.postnatal_historyWhereInput] = None,
        cursor: Optional[types.postnatal_historyWhereUniqueInput] = None,
    ) -> types.postnatal_historyCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.postnatal_historyCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.postnatal_historyWhereInput] = None,
        cursor: Optional[types.postnatal_historyWhereUniqueInput] = None,
    ) -> Union[int, types.postnatal_historyCountAggregateOutput]:
        """Count the number of postnatal_history records present in the database

        Parameters
        ----------
        select
            Select the postnatal_history fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            postnatal_history filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.postnatal_historyCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await postnatal_history.prisma().count()

        # results: prisma.types.postnatal_historyCountAggregateOutput
        results = await postnatal_history.prisma().count(
            select={
                '_all': True,
                'emotional_state': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.postnatal_historyCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.postnatal_historyWhereInput] = None
    ) -> int:
        """Delete multiple postnatal_history records.

        Parameters
        ----------
        where
            Optional postnatal_history filter to find the records to be deleted

        Returns
        -------
        int
            The total number of postnatal_history records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all postnatal_history records
        total = await postnatal_history.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.postnatal_historyScalarFieldKeys'],
        *,
        where: Optional['types.postnatal_historyWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.postnatal_historyAvgAggregateInput'] = None,
        sum: Optional['types.postnatal_historySumAggregateInput'] = None,
        min: Optional['types.postnatal_historyMinAggregateInput'] = None,
        max: Optional['types.postnatal_historyMaxAggregateInput'] = None,
        having: Optional['types.postnatal_historyScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.postnatal_historyCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.postnatal_historyScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.postnatal_historyScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.postnatal_historyGroupByOutput']:
        """Group postnatal_history records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar postnatal_history fields to group records by
        where
            postnatal_history filter to select records
        take
            Limit the maximum number of postnatal_history records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.postnatal_historyGroupByOutput]
            A list of dictionaries representing the postnatal_history record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group postnatal_history records by id values
        # and count how many records are in each group
        results = await postnatal_history.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class psychiatric_historyActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.psychiatric_history]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await psychiatric_history.prisma().query_raw(
            'SELECT * FROM psychiatric_history WHERE id = ?',
            76790008,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.psychiatric_history
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await psychiatric_history.prisma().query_first(
            'SELECT * FROM psychiatric_history WHERE patient_id = ?',
            'cajicjjdef',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.psychiatric_historyCreateInput,
        include: Optional[types.psychiatric_historyInclude] = None
    ) -> _PrismaModelT:
        """Create a new psychiatric_history record.

        Parameters
        ----------
        data
            psychiatric_history record data
        include
            Specifies which relations should be loaded on the returned psychiatric_history model

        Returns
        -------
        prisma.models.psychiatric_history
            The created psychiatric_history record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a psychiatric_history record from just the required fields
        psychiatric_history = await psychiatric_history.prisma().create(
            data={
                # data to create a psychiatric_history record
                'patient_id': 'cefjaadec',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.psychiatric_historyCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple psychiatric_history records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of psychiatric_history record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await psychiatric_history.prisma().create_many(
            data=[
                {
                    # data to create a psychiatric_history record
                    'patient_id': 'ibbigdigd',
                },
                {
                    # data to create a psychiatric_history record
                    'patient_id': 'bdiiiabbii',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.psychiatric_historyWhereUniqueInput,
        include: Optional[types.psychiatric_historyInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single psychiatric_history record.

        Parameters
        ----------
        where
            psychiatric_history filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned psychiatric_history model

        Returns
        -------
        prisma.models.psychiatric_history
            The deleted psychiatric_history record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        psychiatric_history = await psychiatric_history.prisma().delete(
            where={
                'id': 752577037,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.psychiatric_historyWhereUniqueInput,
        include: Optional[types.psychiatric_historyInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique psychiatric_history record.

        Parameters
        ----------
        where
            psychiatric_history filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned psychiatric_history model

        Returns
        -------
        prisma.models.psychiatric_history
            The found psychiatric_history record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        psychiatric_history = await psychiatric_history.prisma().find_unique(
            where={
                'id': 1187663298,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.psychiatric_historyWhereUniqueInput,
        include: Optional[types.psychiatric_historyInclude] = None
    ) -> _PrismaModelT:
        """Find a unique psychiatric_history record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            psychiatric_history filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned psychiatric_history model

        Returns
        -------
        prisma.models.psychiatric_history
            The found psychiatric_history record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        psychiatric_history = await psychiatric_history.prisma().find_unique_or_raise(
            where={
                'id': 769681363,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.psychiatric_historyWhereInput] = None,
        cursor: Optional[types.psychiatric_historyWhereUniqueInput] = None,
        include: Optional[types.psychiatric_historyInclude] = None,
        order: Optional[Union[types.psychiatric_historyOrderByInput, List[types.psychiatric_historyOrderByInput]]] = None,
        distinct: Optional[List[types.psychiatric_historyScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple psychiatric_history records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of psychiatric_history records returned
        skip
            Ignore the first N results
        where
            psychiatric_history filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned psychiatric_history model
        order
            Order the returned psychiatric_history records by any field
        distinct
            Filter psychiatric_history records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.psychiatric_history]
            The list of all psychiatric_history records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 psychiatric_history records
        psychiatric_historys = await psychiatric_history.prisma().find_many(take=10)

        # find the first 5 psychiatric_history records ordered by the family_history field
        psychiatric_historys = await psychiatric_history.prisma().find_many(
            take=5,
            order={
                'family_history': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.psychiatric_historyWhereInput] = None,
        cursor: Optional[types.psychiatric_historyWhereUniqueInput] = None,
        include: Optional[types.psychiatric_historyInclude] = None,
        order: Optional[Union[types.psychiatric_historyOrderByInput, List[types.psychiatric_historyOrderByInput]]] = None,
        distinct: Optional[List[types.psychiatric_historyScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single psychiatric_history record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            psychiatric_history filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned psychiatric_history model
        order
            Order the returned psychiatric_history records by any field
        distinct
            Filter psychiatric_history records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.psychiatric_history
            The first psychiatric_history record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second psychiatric_history record ordered by the disease_awareness field
        psychiatric_history = await psychiatric_history.prisma().find_first(
            skip=1,
            order={
                'disease_awareness': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.psychiatric_historyWhereInput] = None,
        cursor: Optional[types.psychiatric_historyWhereUniqueInput] = None,
        include: Optional[types.psychiatric_historyInclude] = None,
        order: Optional[Union[types.psychiatric_historyOrderByInput, List[types.psychiatric_historyOrderByInput]]] = None,
        distinct: Optional[List[types.psychiatric_historyScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single psychiatric_history record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            psychiatric_history filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned psychiatric_history model
        order
            Order the returned psychiatric_history records by any field
        distinct
            Filter psychiatric_history records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.psychiatric_history
            The first psychiatric_history record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second psychiatric_history record ordered by the areas_affected_by_the_disease field
        psychiatric_history = await psychiatric_history.prisma().find_first_or_raise(
            skip=1,
            order={
                'areas_affected_by_the_disease': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.psychiatric_historyUpdateInput,
        where: types.psychiatric_historyWhereUniqueInput,
        include: Optional[types.psychiatric_historyInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single psychiatric_history record.

        Parameters
        ----------
        data
            psychiatric_history record data specifying what to update
        where
            psychiatric_history filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned psychiatric_history model

        Returns
        -------
        prisma.models.psychiatric_history
            The updated psychiatric_history record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        psychiatric_history = await psychiatric_history.prisma().update(
            where={
                'id': 1214295824,
            },
            data={
                # data to update the psychiatric_history record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.psychiatric_historyWhereUniqueInput,
        data: types.psychiatric_historyUpsertInput,
        include: Optional[types.psychiatric_historyInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            psychiatric_history filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned psychiatric_history model

        Returns
        -------
        prisma.models.psychiatric_history
            The created or updated psychiatric_history record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        psychiatric_history = await psychiatric_history.prisma().upsert(
            where={
                'id': 1021417993,
            },
            data={
                'create': {
                    'id': 1021417993,
                    'patient_id': 'bdiiiabbii',
                },
                'update': {
                    'patient_id': 'bdiiiabbii',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.psychiatric_historyUpdateManyMutationInput,
        where: types.psychiatric_historyWhereInput,
    ) -> int:
        """Update multiple psychiatric_history records

        Parameters
        ----------
        data
            psychiatric_history data to update the selected psychiatric_history records to
        where
            Filter to select the psychiatric_history records to update

        Returns
        -------
        int
            The total number of psychiatric_history records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all psychiatric_history records
        total = await psychiatric_history.prisma().update_many(
            data={
                'past_and_current_treatments': 'dfbfaddhe'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.psychiatric_historyWhereInput] = None,
        cursor: Optional[types.psychiatric_historyWhereUniqueInput] = None,
    ) -> int:
        """Count the number of psychiatric_history records present in the database

        Parameters
        ----------
        select
            Select the psychiatric_history fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            psychiatric_history filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.psychiatric_historyCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await psychiatric_history.prisma().count()

        # results: prisma.types.psychiatric_historyCountAggregateOutput
        results = await psychiatric_history.prisma().count(
            select={
                '_all': True,
                'support_from_the_family_or_social_group': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.psychiatric_historyCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.psychiatric_historyWhereInput] = None,
        cursor: Optional[types.psychiatric_historyWhereUniqueInput] = None,
    ) -> types.psychiatric_historyCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.psychiatric_historyCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.psychiatric_historyWhereInput] = None,
        cursor: Optional[types.psychiatric_historyWhereUniqueInput] = None,
    ) -> Union[int, types.psychiatric_historyCountAggregateOutput]:
        """Count the number of psychiatric_history records present in the database

        Parameters
        ----------
        select
            Select the psychiatric_history fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            psychiatric_history filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.psychiatric_historyCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await psychiatric_history.prisma().count()

        # results: prisma.types.psychiatric_historyCountAggregateOutput
        results = await psychiatric_history.prisma().count(
            select={
                '_all': True,
                'patients_family_group': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.psychiatric_historyCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.psychiatric_historyWhereInput] = None
    ) -> int:
        """Delete multiple psychiatric_history records.

        Parameters
        ----------
        where
            Optional psychiatric_history filter to find the records to be deleted

        Returns
        -------
        int
            The total number of psychiatric_history records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all psychiatric_history records
        total = await psychiatric_history.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.psychiatric_historyScalarFieldKeys'],
        *,
        where: Optional['types.psychiatric_historyWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.psychiatric_historyAvgAggregateInput'] = None,
        sum: Optional['types.psychiatric_historySumAggregateInput'] = None,
        min: Optional['types.psychiatric_historyMinAggregateInput'] = None,
        max: Optional['types.psychiatric_historyMaxAggregateInput'] = None,
        having: Optional['types.psychiatric_historyScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.psychiatric_historyCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.psychiatric_historyScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.psychiatric_historyScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.psychiatric_historyGroupByOutput']:
        """Group psychiatric_history records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar psychiatric_history fields to group records by
        where
            psychiatric_history filter to select records
        take
            Limit the maximum number of psychiatric_history records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.psychiatric_historyGroupByOutput]
            A list of dictionaries representing the psychiatric_history record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group psychiatric_history records by aspects_of_social_life values
        # and count how many records are in each group
        results = await psychiatric_history.prisma().group_by(
            ['aspects_of_social_life'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class usersActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.users]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await users.prisma().query_raw(
            'SELECT * FROM users WHERE id = ?',
            'bdcbbieibf',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.users
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await users.prisma().query_first(
            'SELECT * FROM users WHERE email = ?',
            'dgjhdcggi',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.usersCreateInput,
        include: Optional[types.usersInclude] = None
    ) -> _PrismaModelT:
        """Create a new users record.

        Parameters
        ----------
        data
            users record data
        include
            Specifies which relations should be loaded on the returned users model

        Returns
        -------
        prisma.models.users
            The created users record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a users record from just the required fields
        users = await users.prisma().create(
            data={
                # data to create a users record
                'id': 'bbjbcdfabd',
                'email': 'gchfgbcec',
                'password': 'bihcjfcjah',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.usersCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple users records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of users record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await users.prisma().create_many(
            data=[
                {
                    # data to create a users record
                    'id': 'bhjdcicaii',
                    'email': 'bibedjhcej',
                    'password': 'bjcdajabfa',
                },
                {
                    # data to create a users record
                    'id': 'bchhceeeff',
                    'email': 'bbgaifhdaa',
                    'password': 'dgbcdaegb',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.usersWhereUniqueInput,
        include: Optional[types.usersInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single users record.

        Parameters
        ----------
        where
            users filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned users model

        Returns
        -------
        prisma.models.users
            The deleted users record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        users = await users.prisma().delete(
            where={
                'id': 'beagfbbjig',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.usersWhereUniqueInput,
        include: Optional[types.usersInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique users record.

        Parameters
        ----------
        where
            users filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned users model

        Returns
        -------
        prisma.models.users
            The found users record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        users = await users.prisma().find_unique(
            where={
                'id': 'beicihhijb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.usersWhereUniqueInput,
        include: Optional[types.usersInclude] = None
    ) -> _PrismaModelT:
        """Find a unique users record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            users filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned users model

        Returns
        -------
        prisma.models.users
            The found users record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        users = await users.prisma().find_unique_or_raise(
            where={
                'id': 'fgggcdcjg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.usersWhereInput] = None,
        cursor: Optional[types.usersWhereUniqueInput] = None,
        include: Optional[types.usersInclude] = None,
        order: Optional[Union[types.usersOrderByInput, List[types.usersOrderByInput]]] = None,
        distinct: Optional[List[types.usersScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple users records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of users records returned
        skip
            Ignore the first N results
        where
            users filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned users model
        order
            Order the returned users records by any field
        distinct
            Filter users records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.users]
            The list of all users records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 users records
        users = await users.prisma().find_many(take=10)

        # find the first 5 users records ordered by the password field
        users = await users.prisma().find_many(
            take=5,
            order={
                'password': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.usersWhereInput] = None,
        cursor: Optional[types.usersWhereUniqueInput] = None,
        include: Optional[types.usersInclude] = None,
        order: Optional[Union[types.usersOrderByInput, List[types.usersOrderByInput]]] = None,
        distinct: Optional[List[types.usersScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single users record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            users filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned users model
        order
            Order the returned users records by any field
        distinct
            Filter users records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.users
            The first users record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second users record ordered by the id field
        users = await users.prisma().find_first(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.usersWhereInput] = None,
        cursor: Optional[types.usersWhereUniqueInput] = None,
        include: Optional[types.usersInclude] = None,
        order: Optional[Union[types.usersOrderByInput, List[types.usersOrderByInput]]] = None,
        distinct: Optional[List[types.usersScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single users record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            users filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned users model
        order
            Order the returned users records by any field
        distinct
            Filter users records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.users
            The first users record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second users record ordered by the email field
        users = await users.prisma().find_first_or_raise(
            skip=1,
            order={
                'email': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.usersUpdateInput,
        where: types.usersWhereUniqueInput,
        include: Optional[types.usersInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single users record.

        Parameters
        ----------
        data
            users record data specifying what to update
        where
            users filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned users model

        Returns
        -------
        prisma.models.users
            The updated users record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await users.prisma().update(
            where={
                'id': 'ccjbbjigf',
            },
            data={
                # data to update the users record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.usersWhereUniqueInput,
        data: types.usersUpsertInput,
        include: Optional[types.usersInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            users filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned users model

        Returns
        -------
        prisma.models.users
            The created or updated users record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        users = await users.prisma().upsert(
            where={
                'id': 'bhfaabbaha',
            },
            data={
                'create': {
                    'id': 'bhfaabbaha',
                    'email': 'bbgaifhdaa',
                    'password': 'dgbcdaegb',
                },
                'update': {
                    'email': 'bbgaifhdaa',
                    'password': 'dgbcdaegb',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.usersUpdateManyMutationInput,
        where: types.usersWhereInput,
    ) -> int:
        """Update multiple users records

        Parameters
        ----------
        data
            users data to update the selected users records to
        where
            Filter to select the users records to update

        Returns
        -------
        int
            The total number of users records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all users records
        total = await users.prisma().update_many(
            data={
                'password': 'ebajedhhf'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.usersWhereInput] = None,
        cursor: Optional[types.usersWhereUniqueInput] = None,
    ) -> int:
        """Count the number of users records present in the database

        Parameters
        ----------
        select
            Select the users fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            users filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.usersCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await users.prisma().count()

        # results: prisma.types.usersCountAggregateOutput
        results = await users.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.usersCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.usersWhereInput] = None,
        cursor: Optional[types.usersWhereUniqueInput] = None,
    ) -> types.usersCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.usersCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.usersWhereInput] = None,
        cursor: Optional[types.usersWhereUniqueInput] = None,
    ) -> Union[int, types.usersCountAggregateOutput]:
        """Count the number of users records present in the database

        Parameters
        ----------
        select
            Select the users fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            users filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.usersCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await users.prisma().count()

        # results: prisma.types.usersCountAggregateOutput
        results = await users.prisma().count(
            select={
                '_all': True,
                'email': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.usersCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.usersWhereInput] = None
    ) -> int:
        """Delete multiple users records.

        Parameters
        ----------
        where
            Optional users filter to find the records to be deleted

        Returns
        -------
        int
            The total number of users records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all users records
        total = await users.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.usersScalarFieldKeys'],
        *,
        where: Optional['types.usersWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.usersAvgAggregateInput'] = None,
        sum: Optional['types.usersSumAggregateInput'] = None,
        min: Optional['types.usersMinAggregateInput'] = None,
        max: Optional['types.usersMaxAggregateInput'] = None,
        having: Optional['types.usersScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.usersCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.usersScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.usersScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.usersGroupByOutput']:
        """Group users records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar users fields to group records by
        where
            users filter to select records
        take
            Limit the maximum number of users records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.usersGroupByOutput]
            A list of dictionaries representing the users record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group users records by password values
        # and count how many records are in each group
        results = await users.prisma().group_by(
            ['password'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class vaccinesActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.vaccines]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await vaccines.prisma().query_raw(
            'SELECT * FROM vaccines WHERE id = ?',
            909024364,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.vaccines
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await vaccines.prisma().query_first(
            'SELECT * FROM vaccines WHERE patient_id = ?',
            'hffgbabgf',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.vaccinesCreateInput,
        include: Optional[types.vaccinesInclude] = None
    ) -> _PrismaModelT:
        """Create a new vaccines record.

        Parameters
        ----------
        data
            vaccines record data
        include
            Specifies which relations should be loaded on the returned vaccines model

        Returns
        -------
        prisma.models.vaccines
            The created vaccines record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a vaccines record from just the required fields
        vaccines = await vaccines.prisma().create(
            data={
                # data to create a vaccines record
                'patient_id': 'biacbiieja',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.vaccinesCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple vaccines records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of vaccines record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await vaccines.prisma().create_many(
            data=[
                {
                    # data to create a vaccines record
                    'patient_id': 'cjejbgbff',
                },
                {
                    # data to create a vaccines record
                    'patient_id': 'fgeahddae',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.vaccinesWhereUniqueInput,
        include: Optional[types.vaccinesInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single vaccines record.

        Parameters
        ----------
        where
            vaccines filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned vaccines model

        Returns
        -------
        prisma.models.vaccines
            The deleted vaccines record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        vaccines = await vaccines.prisma().delete(
            where={
                'id': 380648625,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.vaccinesWhereUniqueInput,
        include: Optional[types.vaccinesInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique vaccines record.

        Parameters
        ----------
        where
            vaccines filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned vaccines model

        Returns
        -------
        prisma.models.vaccines
            The found vaccines record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        vaccines = await vaccines.prisma().find_unique(
            where={
                'id': 1030616470,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.vaccinesWhereUniqueInput,
        include: Optional[types.vaccinesInclude] = None
    ) -> _PrismaModelT:
        """Find a unique vaccines record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            vaccines filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned vaccines model

        Returns
        -------
        prisma.models.vaccines
            The found vaccines record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        vaccines = await vaccines.prisma().find_unique_or_raise(
            where={
                'id': 816411927,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.vaccinesWhereInput] = None,
        cursor: Optional[types.vaccinesWhereUniqueInput] = None,
        include: Optional[types.vaccinesInclude] = None,
        order: Optional[Union[types.vaccinesOrderByInput, List[types.vaccinesOrderByInput]]] = None,
        distinct: Optional[List[types.vaccinesScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple vaccines records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of vaccines records returned
        skip
            Ignore the first N results
        where
            vaccines filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned vaccines model
        order
            Order the returned vaccines records by any field
        distinct
            Filter vaccines records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.vaccines]
            The list of all vaccines records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 vaccines records
        vaccines = await vaccines.prisma().find_many(take=10)

        # find the first 5 vaccines records ordered by the application_date field
        vaccines = await vaccines.prisma().find_many(
            take=5,
            order={
                'application_date': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.vaccinesWhereInput] = None,
        cursor: Optional[types.vaccinesWhereUniqueInput] = None,
        include: Optional[types.vaccinesInclude] = None,
        order: Optional[Union[types.vaccinesOrderByInput, List[types.vaccinesOrderByInput]]] = None,
        distinct: Optional[List[types.vaccinesScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single vaccines record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            vaccines filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned vaccines model
        order
            Order the returned vaccines records by any field
        distinct
            Filter vaccines records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.vaccines
            The first vaccines record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second vaccines record ordered by the next_dose field
        vaccines = await vaccines.prisma().find_first(
            skip=1,
            order={
                'next_dose': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.vaccinesWhereInput] = None,
        cursor: Optional[types.vaccinesWhereUniqueInput] = None,
        include: Optional[types.vaccinesInclude] = None,
        order: Optional[Union[types.vaccinesOrderByInput, List[types.vaccinesOrderByInput]]] = None,
        distinct: Optional[List[types.vaccinesScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single vaccines record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            vaccines filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned vaccines model
        order
            Order the returned vaccines records by any field
        distinct
            Filter vaccines records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.vaccines
            The first vaccines record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second vaccines record ordered by the batch field
        vaccines = await vaccines.prisma().find_first_or_raise(
            skip=1,
            order={
                'batch': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.vaccinesUpdateInput,
        where: types.vaccinesWhereUniqueInput,
        include: Optional[types.vaccinesInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single vaccines record.

        Parameters
        ----------
        data
            vaccines record data specifying what to update
        where
            vaccines filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned vaccines model

        Returns
        -------
        prisma.models.vaccines
            The updated vaccines record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        vaccines = await vaccines.prisma().update(
            where={
                'id': 1084099844,
            },
            data={
                # data to update the vaccines record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.vaccinesWhereUniqueInput,
        data: types.vaccinesUpsertInput,
        include: Optional[types.vaccinesInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            vaccines filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned vaccines model

        Returns
        -------
        prisma.models.vaccines
            The created or updated vaccines record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        vaccines = await vaccines.prisma().upsert(
            where={
                'id': 1079702253,
            },
            data={
                'create': {
                    'id': 1079702253,
                    'patient_id': 'fgeahddae',
                },
                'update': {
                    'patient_id': 'fgeahddae',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.vaccinesUpdateManyMutationInput,
        where: types.vaccinesWhereInput,
    ) -> int:
        """Update multiple vaccines records

        Parameters
        ----------
        data
            vaccines data to update the selected vaccines records to
        where
            Filter to select the vaccines records to update

        Returns
        -------
        int
            The total number of vaccines records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all vaccines records
        total = await vaccines.prisma().update_many(
            data={
                'notes': 'hffhfabhi'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.vaccinesWhereInput] = None,
        cursor: Optional[types.vaccinesWhereUniqueInput] = None,
    ) -> int:
        """Count the number of vaccines records present in the database

        Parameters
        ----------
        select
            Select the vaccines fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            vaccines filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.vaccinesCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await vaccines.prisma().count()

        # results: prisma.types.vaccinesCountAggregateOutput
        results = await vaccines.prisma().count(
            select={
                '_all': True,
                'name': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.vaccinesCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.vaccinesWhereInput] = None,
        cursor: Optional[types.vaccinesWhereUniqueInput] = None,
    ) -> types.vaccinesCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.vaccinesCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.vaccinesWhereInput] = None,
        cursor: Optional[types.vaccinesWhereUniqueInput] = None,
    ) -> Union[int, types.vaccinesCountAggregateOutput]:
        """Count the number of vaccines records present in the database

        Parameters
        ----------
        select
            Select the vaccines fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            vaccines filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.vaccinesCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await vaccines.prisma().count()

        # results: prisma.types.vaccinesCountAggregateOutput
        results = await vaccines.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.vaccinesCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.vaccinesWhereInput] = None
    ) -> int:
        """Delete multiple vaccines records.

        Parameters
        ----------
        where
            Optional vaccines filter to find the records to be deleted

        Returns
        -------
        int
            The total number of vaccines records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all vaccines records
        total = await vaccines.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.vaccinesScalarFieldKeys'],
        *,
        where: Optional['types.vaccinesWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.vaccinesAvgAggregateInput'] = None,
        sum: Optional['types.vaccinesSumAggregateInput'] = None,
        min: Optional['types.vaccinesMinAggregateInput'] = None,
        max: Optional['types.vaccinesMaxAggregateInput'] = None,
        having: Optional['types.vaccinesScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.vaccinesCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.vaccinesScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.vaccinesScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.vaccinesGroupByOutput']:
        """Group vaccines records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar vaccines fields to group records by
        where
            vaccines filter to select records
        take
            Limit the maximum number of vaccines records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.vaccinesGroupByOutput]
            A list of dictionaries representing the vaccines record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group vaccines records by patient_id values
        # and count how many records are in each group
        results = await vaccines.prisma().group_by(
            ['patient_id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class vital_signsActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.vital_signs]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await vital_signs.prisma().query_raw(
            'SELECT * FROM vital_signs WHERE id = ?',
            1128680371,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.vital_signs
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await vital_signs.prisma().query_first(
            'SELECT * FROM vital_signs WHERE patient_id = ?',
            'cfjagbbae',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.vital_signsCreateInput,
        include: Optional[types.vital_signsInclude] = None
    ) -> _PrismaModelT:
        """Create a new vital_signs record.

        Parameters
        ----------
        data
            vital_signs record data
        include
            Specifies which relations should be loaded on the returned vital_signs model

        Returns
        -------
        prisma.models.vital_signs
            The created vital_signs record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a vital_signs record from just the required fields
        vital_signs = await vital_signs.prisma().create(
            data={
                # data to create a vital_signs record
                'patient_id': 'bbbfhdidef',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.vital_signsCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple vital_signs records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of vital_signs record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await vital_signs.prisma().create_many(
            data=[
                {
                    # data to create a vital_signs record
                    'patient_id': 'bdadhibhec',
                },
                {
                    # data to create a vital_signs record
                    'patient_id': 'bfhdjaiejf',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.vital_signsWhereUniqueInput,
        include: Optional[types.vital_signsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single vital_signs record.

        Parameters
        ----------
        where
            vital_signs filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned vital_signs model

        Returns
        -------
        prisma.models.vital_signs
            The deleted vital_signs record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        vital_signs = await vital_signs.prisma().delete(
            where={
                'id': 1195899036,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.vital_signsWhereUniqueInput,
        include: Optional[types.vital_signsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique vital_signs record.

        Parameters
        ----------
        where
            vital_signs filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned vital_signs model

        Returns
        -------
        prisma.models.vital_signs
            The found vital_signs record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        vital_signs = await vital_signs.prisma().find_unique(
            where={
                'id': 739021477,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.vital_signsWhereUniqueInput,
        include: Optional[types.vital_signsInclude] = None
    ) -> _PrismaModelT:
        """Find a unique vital_signs record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            vital_signs filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned vital_signs model

        Returns
        -------
        prisma.models.vital_signs
            The found vital_signs record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        vital_signs = await vital_signs.prisma().find_unique_or_raise(
            where={
                'id': 1722214010,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.vital_signsWhereInput] = None,
        cursor: Optional[types.vital_signsWhereUniqueInput] = None,
        include: Optional[types.vital_signsInclude] = None,
        order: Optional[Union[types.vital_signsOrderByInput, List[types.vital_signsOrderByInput]]] = None,
        distinct: Optional[List[types.vital_signsScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple vital_signs records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of vital_signs records returned
        skip
            Ignore the first N results
        where
            vital_signs filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned vital_signs model
        order
            Order the returned vital_signs records by any field
        distinct
            Filter vital_signs records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.vital_signs]
            The list of all vital_signs records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 vital_signs records
        vital_signs = await vital_signs.prisma().find_many(take=10)

        # find the first 5 vital_signs records ordered by the stature field
        vital_signs = await vital_signs.prisma().find_many(
            take=5,
            order={
                'stature': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.vital_signsWhereInput] = None,
        cursor: Optional[types.vital_signsWhereUniqueInput] = None,
        include: Optional[types.vital_signsInclude] = None,
        order: Optional[Union[types.vital_signsOrderByInput, List[types.vital_signsOrderByInput]]] = None,
        distinct: Optional[List[types.vital_signsScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single vital_signs record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            vital_signs filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned vital_signs model
        order
            Order the returned vital_signs records by any field
        distinct
            Filter vital_signs records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.vital_signs
            The first vital_signs record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second vital_signs record ordered by the weight field
        vital_signs = await vital_signs.prisma().find_first(
            skip=1,
            order={
                'weight': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.vital_signsWhereInput] = None,
        cursor: Optional[types.vital_signsWhereUniqueInput] = None,
        include: Optional[types.vital_signsInclude] = None,
        order: Optional[Union[types.vital_signsOrderByInput, List[types.vital_signsOrderByInput]]] = None,
        distinct: Optional[List[types.vital_signsScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single vital_signs record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            vital_signs filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned vital_signs model
        order
            Order the returned vital_signs records by any field
        distinct
            Filter vital_signs records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.vital_signs
            The first vital_signs record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second vital_signs record ordered by the body_mass field
        vital_signs = await vital_signs.prisma().find_first_or_raise(
            skip=1,
            order={
                'body_mass': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.vital_signsUpdateInput,
        where: types.vital_signsWhereUniqueInput,
        include: Optional[types.vital_signsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single vital_signs record.

        Parameters
        ----------
        data
            vital_signs record data specifying what to update
        where
            vital_signs filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned vital_signs model

        Returns
        -------
        prisma.models.vital_signs
            The updated vital_signs record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        vital_signs = await vital_signs.prisma().update(
            where={
                'id': 1269136939,
            },
            data={
                # data to update the vital_signs record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.vital_signsWhereUniqueInput,
        data: types.vital_signsUpsertInput,
        include: Optional[types.vital_signsInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            vital_signs filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned vital_signs model

        Returns
        -------
        prisma.models.vital_signs
            The created or updated vital_signs record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        vital_signs = await vital_signs.prisma().upsert(
            where={
                'id': 573178504,
            },
            data={
                'create': {
                    'id': 573178504,
                    'patient_id': 'bfhdjaiejf',
                },
                'update': {
                    'patient_id': 'bfhdjaiejf',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.vital_signsUpdateManyMutationInput,
        where: types.vital_signsWhereInput,
    ) -> int:
        """Update multiple vital_signs records

        Parameters
        ----------
        data
            vital_signs data to update the selected vital_signs records to
        where
            Filter to select the vital_signs records to update

        Returns
        -------
        int
            The total number of vital_signs records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all vital_signs records
        total = await vital_signs.prisma().update_many(
            data={
                'temperature': 1440265249.118573
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.vital_signsWhereInput] = None,
        cursor: Optional[types.vital_signsWhereUniqueInput] = None,
    ) -> int:
        """Count the number of vital_signs records present in the database

        Parameters
        ----------
        select
            Select the vital_signs fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            vital_signs filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.vital_signsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await vital_signs.prisma().count()

        # results: prisma.types.vital_signsCountAggregateOutput
        results = await vital_signs.prisma().count(
            select={
                '_all': True,
                'respiratory_rate': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.vital_signsCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.vital_signsWhereInput] = None,
        cursor: Optional[types.vital_signsWhereUniqueInput] = None,
    ) -> types.vital_signsCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.vital_signsCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.vital_signsWhereInput] = None,
        cursor: Optional[types.vital_signsWhereUniqueInput] = None,
    ) -> Union[int, types.vital_signsCountAggregateOutput]:
        """Count the number of vital_signs records present in the database

        Parameters
        ----------
        select
            Select the vital_signs fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            vital_signs filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.vital_signsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await vital_signs.prisma().count()

        # results: prisma.types.vital_signsCountAggregateOutput
        results = await vital_signs.prisma().count(
            select={
                '_all': True,
                'systolic': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.vital_signsCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.vital_signsWhereInput] = None
    ) -> int:
        """Delete multiple vital_signs records.

        Parameters
        ----------
        where
            Optional vital_signs filter to find the records to be deleted

        Returns
        -------
        int
            The total number of vital_signs records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all vital_signs records
        total = await vital_signs.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.vital_signsScalarFieldKeys'],
        *,
        where: Optional['types.vital_signsWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.vital_signsAvgAggregateInput'] = None,
        sum: Optional['types.vital_signsSumAggregateInput'] = None,
        min: Optional['types.vital_signsMinAggregateInput'] = None,
        max: Optional['types.vital_signsMaxAggregateInput'] = None,
        having: Optional['types.vital_signsScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.vital_signsCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.vital_signsScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.vital_signsScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.vital_signsGroupByOutput']:
        """Group vital_signs records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar vital_signs fields to group records by
        where
            vital_signs filter to select records
        take
            Limit the maximum number of vital_signs records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.vital_signsGroupByOutput]
            A list of dictionaries representing the vital_signs record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group vital_signs records by diastolic values
        # and count how many records are in each group
        results = await vital_signs.prisma().group_by(
            ['diastolic'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ketosisActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.ketosis]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await ketosis.prisma().query_raw(
            'SELECT * FROM ketosis WHERE id = ?',
            1694224903,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.ketosis
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await ketosis.prisma().query_first(
            'SELECT * FROM ketosis WHERE medical_consultation_id = ?',
            'bjagdgabbg',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.ketosisCreateInput,
        include: Optional[types.ketosisInclude] = None
    ) -> _PrismaModelT:
        """Create a new ketosis record.

        Parameters
        ----------
        data
            ketosis record data
        include
            Specifies which relations should be loaded on the returned ketosis model

        Returns
        -------
        prisma.models.ketosis
            The created ketosis record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a ketosis record from just the required fields
        ketosis = await ketosis.prisma().create(
            data={
                # data to create a ketosis record
                'medical_consultation_id': 'bjbbcffdij',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ketosisCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple ketosis records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of ketosis record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await ketosis.prisma().create_many(
            data=[
                {
                    # data to create a ketosis record
                    'medical_consultation_id': 'begcgchdi',
                },
                {
                    # data to create a ketosis record
                    'medical_consultation_id': 'bhbjceagbb',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ketosisWhereUniqueInput,
        include: Optional[types.ketosisInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single ketosis record.

        Parameters
        ----------
        where
            ketosis filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned ketosis model

        Returns
        -------
        prisma.models.ketosis
            The deleted ketosis record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        ketosis = await ketosis.prisma().delete(
            where={
                'id': 1948555936,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.ketosisWhereUniqueInput,
        include: Optional[types.ketosisInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique ketosis record.

        Parameters
        ----------
        where
            ketosis filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ketosis model

        Returns
        -------
        prisma.models.ketosis
            The found ketosis record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        ketosis = await ketosis.prisma().find_unique(
            where={
                'id': 1383253593,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.ketosisWhereUniqueInput,
        include: Optional[types.ketosisInclude] = None
    ) -> _PrismaModelT:
        """Find a unique ketosis record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            ketosis filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ketosis model

        Returns
        -------
        prisma.models.ketosis
            The found ketosis record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        ketosis = await ketosis.prisma().find_unique_or_raise(
            where={
                'id': 354664990,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ketosisWhereInput] = None,
        cursor: Optional[types.ketosisWhereUniqueInput] = None,
        include: Optional[types.ketosisInclude] = None,
        order: Optional[Union[types.ketosisOrderByInput, List[types.ketosisOrderByInput]]] = None,
        distinct: Optional[List[types.ketosisScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple ketosis records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of ketosis records returned
        skip
            Ignore the first N results
        where
            ketosis filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ketosis model
        order
            Order the returned ketosis records by any field
        distinct
            Filter ketosis records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.ketosis]
            The list of all ketosis records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 ketosis records
        ketosis = await ketosis.prisma().find_many(take=10)

        # find the first 5 ketosis records ordered by the satiety field
        ketosis = await ketosis.prisma().find_many(
            take=5,
            order={
                'satiety': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ketosisWhereInput] = None,
        cursor: Optional[types.ketosisWhereUniqueInput] = None,
        include: Optional[types.ketosisInclude] = None,
        order: Optional[Union[types.ketosisOrderByInput, List[types.ketosisOrderByInput]]] = None,
        distinct: Optional[List[types.ketosisScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single ketosis record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ketosis filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ketosis model
        order
            Order the returned ketosis records by any field
        distinct
            Filter ketosis records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ketosis
            The first ketosis record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ketosis record ordered by the cramps field
        ketosis = await ketosis.prisma().find_first(
            skip=1,
            order={
                'cramps': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ketosisWhereInput] = None,
        cursor: Optional[types.ketosisWhereUniqueInput] = None,
        include: Optional[types.ketosisInclude] = None,
        order: Optional[Union[types.ketosisOrderByInput, List[types.ketosisOrderByInput]]] = None,
        distinct: Optional[List[types.ketosisScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single ketosis record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ketosis filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ketosis model
        order
            Order the returned ketosis records by any field
        distinct
            Filter ketosis records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ketosis
            The first ketosis record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ketosis record ordered by the diarrhea field
        ketosis = await ketosis.prisma().find_first_or_raise(
            skip=1,
            order={
                'diarrhea': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.ketosisUpdateInput,
        where: types.ketosisWhereUniqueInput,
        include: Optional[types.ketosisInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single ketosis record.

        Parameters
        ----------
        data
            ketosis record data specifying what to update
        where
            ketosis filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned ketosis model

        Returns
        -------
        prisma.models.ketosis
            The updated ketosis record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        ketosis = await ketosis.prisma().update(
            where={
                'id': 647166719,
            },
            data={
                # data to update the ketosis record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.ketosisWhereUniqueInput,
        data: types.ketosisUpsertInput,
        include: Optional[types.ketosisInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            ketosis filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned ketosis model

        Returns
        -------
        prisma.models.ketosis
            The created or updated ketosis record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        ketosis = await ketosis.prisma().upsert(
            where={
                'id': 357089484,
            },
            data={
                'create': {
                    'id': 357089484,
                    'medical_consultation_id': 'bhbjceagbb',
                },
                'update': {
                    'medical_consultation_id': 'bhbjceagbb',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.ketosisUpdateManyMutationInput,
        where: types.ketosisWhereInput,
    ) -> int:
        """Update multiple ketosis records

        Parameters
        ----------
        data
            ketosis data to update the selected ketosis records to
        where
            Filter to select the ketosis records to update

        Returns
        -------
        int
            The total number of ketosis records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all ketosis records
        total = await ketosis.prisma().update_many(
            data={
                'depressed': 612396821
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ketosisWhereInput] = None,
        cursor: Optional[types.ketosisWhereUniqueInput] = None,
    ) -> int:
        """Count the number of ketosis records present in the database

        Parameters
        ----------
        select
            Select the ketosis fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ketosis filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ketosisCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ketosis.prisma().count()

        # results: prisma.types.ketosisCountAggregateOutput
        results = await ketosis.prisma().count(
            select={
                '_all': True,
                'tolerance': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.ketosisCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ketosisWhereInput] = None,
        cursor: Optional[types.ketosisWhereUniqueInput] = None,
    ) -> types.ketosisCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.ketosisCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ketosisWhereInput] = None,
        cursor: Optional[types.ketosisWhereUniqueInput] = None,
    ) -> Union[int, types.ketosisCountAggregateOutput]:
        """Count the number of ketosis records present in the database

        Parameters
        ----------
        select
            Select the ketosis fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ketosis filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ketosisCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ketosis.prisma().count()

        # results: prisma.types.ketosisCountAggregateOutput
        results = await ketosis.prisma().count(
            select={
                '_all': True,
                'constipation': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ketosisCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.ketosisWhereInput] = None
    ) -> int:
        """Delete multiple ketosis records.

        Parameters
        ----------
        where
            Optional ketosis filter to find the records to be deleted

        Returns
        -------
        int
            The total number of ketosis records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all ketosis records
        total = await ketosis.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.ketosisScalarFieldKeys'],
        *,
        where: Optional['types.ketosisWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ketosisAvgAggregateInput'] = None,
        sum: Optional['types.ketosisSumAggregateInput'] = None,
        min: Optional['types.ketosisMinAggregateInput'] = None,
        max: Optional['types.ketosisMaxAggregateInput'] = None,
        having: Optional['types.ketosisScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ketosisCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ketosisScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.ketosisScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.ketosisGroupByOutput']:
        """Group ketosis records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar ketosis fields to group records by
        where
            ketosis filter to select records
        take
            Limit the maximum number of ketosis records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ketosisGroupByOutput]
            A list of dictionaries representing the ketosis record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group ketosis records by dizziness values
        # and count how many records are in each group
        results = await ketosis.prisma().group_by(
            ['dizziness'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class lab_requests_and_imageActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.lab_requests_and_image]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await lab_requests_and_image.prisma().query_raw(
            'SELECT * FROM lab_requests_and_image WHERE id = ?',
            1808130602,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.lab_requests_and_image
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await lab_requests_and_image.prisma().query_first(
            'SELECT * FROM lab_requests_and_image WHERE medical_consultation_id = ?',
            'bbfbheibcd',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.lab_requests_and_imageCreateInput,
        include: Optional[types.lab_requests_and_imageInclude] = None
    ) -> _PrismaModelT:
        """Create a new lab_requests_and_image record.

        Parameters
        ----------
        data
            lab_requests_and_image record data
        include
            Specifies which relations should be loaded on the returned lab_requests_and_image model

        Returns
        -------
        prisma.models.lab_requests_and_image
            The created lab_requests_and_image record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a lab_requests_and_image record from just the required fields
        lab_requests_and_image = await lab_requests_and_image.prisma().create(
            data={
                # data to create a lab_requests_and_image record
                'medical_consultation_id': 'hiagajie',
                'name': 'eeejidbif',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.lab_requests_and_imageCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple lab_requests_and_image records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of lab_requests_and_image record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await lab_requests_and_image.prisma().create_many(
            data=[
                {
                    # data to create a lab_requests_and_image record
                    'medical_consultation_id': 'efgbahec',
                    'name': 'hgjaiebfb',
                },
                {
                    # data to create a lab_requests_and_image record
                    'medical_consultation_id': 'bddefjjabc',
                    'name': 'bbbghgbadh',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.lab_requests_and_imageWhereUniqueInput,
        include: Optional[types.lab_requests_and_imageInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single lab_requests_and_image record.

        Parameters
        ----------
        where
            lab_requests_and_image filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned lab_requests_and_image model

        Returns
        -------
        prisma.models.lab_requests_and_image
            The deleted lab_requests_and_image record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        lab_requests_and_image = await lab_requests_and_image.prisma().delete(
            where={
                'id': 1172606082,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.lab_requests_and_imageWhereUniqueInput,
        include: Optional[types.lab_requests_and_imageInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique lab_requests_and_image record.

        Parameters
        ----------
        where
            lab_requests_and_image filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned lab_requests_and_image model

        Returns
        -------
        prisma.models.lab_requests_and_image
            The found lab_requests_and_image record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        lab_requests_and_image = await lab_requests_and_image.prisma().find_unique(
            where={
                'id': 330014611,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.lab_requests_and_imageWhereUniqueInput,
        include: Optional[types.lab_requests_and_imageInclude] = None
    ) -> _PrismaModelT:
        """Find a unique lab_requests_and_image record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            lab_requests_and_image filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned lab_requests_and_image model

        Returns
        -------
        prisma.models.lab_requests_and_image
            The found lab_requests_and_image record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        lab_requests_and_image = await lab_requests_and_image.prisma().find_unique_or_raise(
            where={
                'id': 1768156112,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.lab_requests_and_imageWhereInput] = None,
        cursor: Optional[types.lab_requests_and_imageWhereUniqueInput] = None,
        include: Optional[types.lab_requests_and_imageInclude] = None,
        order: Optional[Union[types.lab_requests_and_imageOrderByInput, List[types.lab_requests_and_imageOrderByInput]]] = None,
        distinct: Optional[List[types.lab_requests_and_imageScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple lab_requests_and_image records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of lab_requests_and_image records returned
        skip
            Ignore the first N results
        where
            lab_requests_and_image filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned lab_requests_and_image model
        order
            Order the returned lab_requests_and_image records by any field
        distinct
            Filter lab_requests_and_image records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.lab_requests_and_image]
            The list of all lab_requests_and_image records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 lab_requests_and_image records
        lab_requests_and_images = await lab_requests_and_image.prisma().find_many(take=10)

        # find the first 5 lab_requests_and_image records ordered by the name field
        lab_requests_and_images = await lab_requests_and_image.prisma().find_many(
            take=5,
            order={
                'name': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.lab_requests_and_imageWhereInput] = None,
        cursor: Optional[types.lab_requests_and_imageWhereUniqueInput] = None,
        include: Optional[types.lab_requests_and_imageInclude] = None,
        order: Optional[Union[types.lab_requests_and_imageOrderByInput, List[types.lab_requests_and_imageOrderByInput]]] = None,
        distinct: Optional[List[types.lab_requests_and_imageScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single lab_requests_and_image record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            lab_requests_and_image filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned lab_requests_and_image model
        order
            Order the returned lab_requests_and_image records by any field
        distinct
            Filter lab_requests_and_image records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.lab_requests_and_image
            The first lab_requests_and_image record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second lab_requests_and_image record ordered by the notes field
        lab_requests_and_image = await lab_requests_and_image.prisma().find_first(
            skip=1,
            order={
                'notes': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.lab_requests_and_imageWhereInput] = None,
        cursor: Optional[types.lab_requests_and_imageWhereUniqueInput] = None,
        include: Optional[types.lab_requests_and_imageInclude] = None,
        order: Optional[Union[types.lab_requests_and_imageOrderByInput, List[types.lab_requests_and_imageOrderByInput]]] = None,
        distinct: Optional[List[types.lab_requests_and_imageScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single lab_requests_and_image record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            lab_requests_and_image filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned lab_requests_and_image model
        order
            Order the returned lab_requests_and_image records by any field
        distinct
            Filter lab_requests_and_image records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.lab_requests_and_image
            The first lab_requests_and_image record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second lab_requests_and_image record ordered by the id field
        lab_requests_and_image = await lab_requests_and_image.prisma().find_first_or_raise(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.lab_requests_and_imageUpdateInput,
        where: types.lab_requests_and_imageWhereUniqueInput,
        include: Optional[types.lab_requests_and_imageInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single lab_requests_and_image record.

        Parameters
        ----------
        data
            lab_requests_and_image record data specifying what to update
        where
            lab_requests_and_image filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned lab_requests_and_image model

        Returns
        -------
        prisma.models.lab_requests_and_image
            The updated lab_requests_and_image record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        lab_requests_and_image = await lab_requests_and_image.prisma().update(
            where={
                'id': 71628745,
            },
            data={
                # data to update the lab_requests_and_image record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.lab_requests_and_imageWhereUniqueInput,
        data: types.lab_requests_and_imageUpsertInput,
        include: Optional[types.lab_requests_and_imageInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            lab_requests_and_image filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned lab_requests_and_image model

        Returns
        -------
        prisma.models.lab_requests_and_image
            The created or updated lab_requests_and_image record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        lab_requests_and_image = await lab_requests_and_image.prisma().upsert(
            where={
                'id': 55766734,
            },
            data={
                'create': {
                    'id': 55766734,
                    'medical_consultation_id': 'bddefjjabc',
                    'name': 'bbbghgbadh',
                },
                'update': {
                    'medical_consultation_id': 'bddefjjabc',
                    'name': 'bbbghgbadh',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.lab_requests_and_imageUpdateManyMutationInput,
        where: types.lab_requests_and_imageWhereInput,
    ) -> int:
        """Update multiple lab_requests_and_image records

        Parameters
        ----------
        data
            lab_requests_and_image data to update the selected lab_requests_and_image records to
        where
            Filter to select the lab_requests_and_image records to update

        Returns
        -------
        int
            The total number of lab_requests_and_image records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all lab_requests_and_image records
        total = await lab_requests_and_image.prisma().update_many(
            data={
                'medical_consultation_id': 'ibcadcejf'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.lab_requests_and_imageWhereInput] = None,
        cursor: Optional[types.lab_requests_and_imageWhereUniqueInput] = None,
    ) -> int:
        """Count the number of lab_requests_and_image records present in the database

        Parameters
        ----------
        select
            Select the lab_requests_and_image fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            lab_requests_and_image filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.lab_requests_and_imageCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await lab_requests_and_image.prisma().count()

        # results: prisma.types.lab_requests_and_imageCountAggregateOutput
        results = await lab_requests_and_image.prisma().count(
            select={
                '_all': True,
                'name': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.lab_requests_and_imageCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.lab_requests_and_imageWhereInput] = None,
        cursor: Optional[types.lab_requests_and_imageWhereUniqueInput] = None,
    ) -> types.lab_requests_and_imageCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.lab_requests_and_imageCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.lab_requests_and_imageWhereInput] = None,
        cursor: Optional[types.lab_requests_and_imageWhereUniqueInput] = None,
    ) -> Union[int, types.lab_requests_and_imageCountAggregateOutput]:
        """Count the number of lab_requests_and_image records present in the database

        Parameters
        ----------
        select
            Select the lab_requests_and_image fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            lab_requests_and_image filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.lab_requests_and_imageCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await lab_requests_and_image.prisma().count()

        # results: prisma.types.lab_requests_and_imageCountAggregateOutput
        results = await lab_requests_and_image.prisma().count(
            select={
                '_all': True,
                'notes': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.lab_requests_and_imageCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.lab_requests_and_imageWhereInput] = None
    ) -> int:
        """Delete multiple lab_requests_and_image records.

        Parameters
        ----------
        where
            Optional lab_requests_and_image filter to find the records to be deleted

        Returns
        -------
        int
            The total number of lab_requests_and_image records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all lab_requests_and_image records
        total = await lab_requests_and_image.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.lab_requests_and_imageScalarFieldKeys'],
        *,
        where: Optional['types.lab_requests_and_imageWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.lab_requests_and_imageAvgAggregateInput'] = None,
        sum: Optional['types.lab_requests_and_imageSumAggregateInput'] = None,
        min: Optional['types.lab_requests_and_imageMinAggregateInput'] = None,
        max: Optional['types.lab_requests_and_imageMaxAggregateInput'] = None,
        having: Optional['types.lab_requests_and_imageScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.lab_requests_and_imageCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.lab_requests_and_imageScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.lab_requests_and_imageScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.lab_requests_and_imageGroupByOutput']:
        """Group lab_requests_and_image records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar lab_requests_and_image fields to group records by
        where
            lab_requests_and_image filter to select records
        take
            Limit the maximum number of lab_requests_and_image records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.lab_requests_and_imageGroupByOutput]
            A list of dictionaries representing the lab_requests_and_image record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group lab_requests_and_image records by id values
        # and count how many records are in each group
        results = await lab_requests_and_image.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class medical_diagnosisActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.medical_diagnosis]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await medical_diagnosis.prisma().query_raw(
            'SELECT * FROM medical_diagnosis WHERE id = ?',
            1323562236,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.medical_diagnosis
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await medical_diagnosis.prisma().query_first(
            'SELECT * FROM medical_diagnosis WHERE medical_consultation_id = ?',
            'edhjgdfh',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.medical_diagnosisCreateInput,
        include: Optional[types.medical_diagnosisInclude] = None
    ) -> _PrismaModelT:
        """Create a new medical_diagnosis record.

        Parameters
        ----------
        data
            medical_diagnosis record data
        include
            Specifies which relations should be loaded on the returned medical_diagnosis model

        Returns
        -------
        prisma.models.medical_diagnosis
            The created medical_diagnosis record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a medical_diagnosis record from just the required fields
        medical_diagnosis = await medical_diagnosis.prisma().create(
            data={
                # data to create a medical_diagnosis record
                'medical_consultation_id': 'bdeffdadda',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.medical_diagnosisCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple medical_diagnosis records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of medical_diagnosis record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await medical_diagnosis.prisma().create_many(
            data=[
                {
                    # data to create a medical_diagnosis record
                    'medical_consultation_id': 'bjgfdihchf',
                },
                {
                    # data to create a medical_diagnosis record
                    'medical_consultation_id': 'iaeihdeei',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.medical_diagnosisWhereUniqueInput,
        include: Optional[types.medical_diagnosisInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single medical_diagnosis record.

        Parameters
        ----------
        where
            medical_diagnosis filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned medical_diagnosis model

        Returns
        -------
        prisma.models.medical_diagnosis
            The deleted medical_diagnosis record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        medical_diagnosis = await medical_diagnosis.prisma().delete(
            where={
                'id': 1566496513,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.medical_diagnosisWhereUniqueInput,
        include: Optional[types.medical_diagnosisInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique medical_diagnosis record.

        Parameters
        ----------
        where
            medical_diagnosis filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned medical_diagnosis model

        Returns
        -------
        prisma.models.medical_diagnosis
            The found medical_diagnosis record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        medical_diagnosis = await medical_diagnosis.prisma().find_unique(
            where={
                'id': 850004390,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.medical_diagnosisWhereUniqueInput,
        include: Optional[types.medical_diagnosisInclude] = None
    ) -> _PrismaModelT:
        """Find a unique medical_diagnosis record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            medical_diagnosis filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned medical_diagnosis model

        Returns
        -------
        prisma.models.medical_diagnosis
            The found medical_diagnosis record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        medical_diagnosis = await medical_diagnosis.prisma().find_unique_or_raise(
            where={
                'id': 2109399015,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.medical_diagnosisWhereInput] = None,
        cursor: Optional[types.medical_diagnosisWhereUniqueInput] = None,
        include: Optional[types.medical_diagnosisInclude] = None,
        order: Optional[Union[types.medical_diagnosisOrderByInput, List[types.medical_diagnosisOrderByInput]]] = None,
        distinct: Optional[List[types.medical_diagnosisScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple medical_diagnosis records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of medical_diagnosis records returned
        skip
            Ignore the first N results
        where
            medical_diagnosis filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned medical_diagnosis model
        order
            Order the returned medical_diagnosis records by any field
        distinct
            Filter medical_diagnosis records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.medical_diagnosis]
            The list of all medical_diagnosis records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 medical_diagnosis records
        medical_diagnosis = await medical_diagnosis.prisma().find_many(take=10)

        # find the first 5 medical_diagnosis records ordered by the code field
        medical_diagnosis = await medical_diagnosis.prisma().find_many(
            take=5,
            order={
                'code': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.medical_diagnosisWhereInput] = None,
        cursor: Optional[types.medical_diagnosisWhereUniqueInput] = None,
        include: Optional[types.medical_diagnosisInclude] = None,
        order: Optional[Union[types.medical_diagnosisOrderByInput, List[types.medical_diagnosisOrderByInput]]] = None,
        distinct: Optional[List[types.medical_diagnosisScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single medical_diagnosis record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            medical_diagnosis filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned medical_diagnosis model
        order
            Order the returned medical_diagnosis records by any field
        distinct
            Filter medical_diagnosis records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.medical_diagnosis
            The first medical_diagnosis record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second medical_diagnosis record ordered by the description field
        medical_diagnosis = await medical_diagnosis.prisma().find_first(
            skip=1,
            order={
                'description': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.medical_diagnosisWhereInput] = None,
        cursor: Optional[types.medical_diagnosisWhereUniqueInput] = None,
        include: Optional[types.medical_diagnosisInclude] = None,
        order: Optional[Union[types.medical_diagnosisOrderByInput, List[types.medical_diagnosisOrderByInput]]] = None,
        distinct: Optional[List[types.medical_diagnosisScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single medical_diagnosis record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            medical_diagnosis filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned medical_diagnosis model
        order
            Order the returned medical_diagnosis records by any field
        distinct
            Filter medical_diagnosis records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.medical_diagnosis
            The first medical_diagnosis record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second medical_diagnosis record ordered by the notes field
        medical_diagnosis = await medical_diagnosis.prisma().find_first_or_raise(
            skip=1,
            order={
                'notes': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.medical_diagnosisUpdateInput,
        where: types.medical_diagnosisWhereUniqueInput,
        include: Optional[types.medical_diagnosisInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single medical_diagnosis record.

        Parameters
        ----------
        data
            medical_diagnosis record data specifying what to update
        where
            medical_diagnosis filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned medical_diagnosis model

        Returns
        -------
        prisma.models.medical_diagnosis
            The updated medical_diagnosis record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        medical_diagnosis = await medical_diagnosis.prisma().update(
            where={
                'id': 1282664340,
            },
            data={
                # data to update the medical_diagnosis record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.medical_diagnosisWhereUniqueInput,
        data: types.medical_diagnosisUpsertInput,
        include: Optional[types.medical_diagnosisInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            medical_diagnosis filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned medical_diagnosis model

        Returns
        -------
        prisma.models.medical_diagnosis
            The created or updated medical_diagnosis record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        medical_diagnosis = await medical_diagnosis.prisma().upsert(
            where={
                'id': 241230397,
            },
            data={
                'create': {
                    'id': 241230397,
                    'medical_consultation_id': 'iaeihdeei',
                },
                'update': {
                    'medical_consultation_id': 'iaeihdeei',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.medical_diagnosisUpdateManyMutationInput,
        where: types.medical_diagnosisWhereInput,
    ) -> int:
        """Update multiple medical_diagnosis records

        Parameters
        ----------
        data
            medical_diagnosis data to update the selected medical_diagnosis records to
        where
            Filter to select the medical_diagnosis records to update

        Returns
        -------
        int
            The total number of medical_diagnosis records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all medical_diagnosis records
        total = await medical_diagnosis.prisma().update_many(
            data={
                'id': 475863602
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.medical_diagnosisWhereInput] = None,
        cursor: Optional[types.medical_diagnosisWhereUniqueInput] = None,
    ) -> int:
        """Count the number of medical_diagnosis records present in the database

        Parameters
        ----------
        select
            Select the medical_diagnosis fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            medical_diagnosis filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.medical_diagnosisCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await medical_diagnosis.prisma().count()

        # results: prisma.types.medical_diagnosisCountAggregateOutput
        results = await medical_diagnosis.prisma().count(
            select={
                '_all': True,
                'medical_consultation_id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.medical_diagnosisCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.medical_diagnosisWhereInput] = None,
        cursor: Optional[types.medical_diagnosisWhereUniqueInput] = None,
    ) -> types.medical_diagnosisCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.medical_diagnosisCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.medical_diagnosisWhereInput] = None,
        cursor: Optional[types.medical_diagnosisWhereUniqueInput] = None,
    ) -> Union[int, types.medical_diagnosisCountAggregateOutput]:
        """Count the number of medical_diagnosis records present in the database

        Parameters
        ----------
        select
            Select the medical_diagnosis fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            medical_diagnosis filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.medical_diagnosisCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await medical_diagnosis.prisma().count()

        # results: prisma.types.medical_diagnosisCountAggregateOutput
        results = await medical_diagnosis.prisma().count(
            select={
                '_all': True,
                'code': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.medical_diagnosisCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.medical_diagnosisWhereInput] = None
    ) -> int:
        """Delete multiple medical_diagnosis records.

        Parameters
        ----------
        where
            Optional medical_diagnosis filter to find the records to be deleted

        Returns
        -------
        int
            The total number of medical_diagnosis records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all medical_diagnosis records
        total = await medical_diagnosis.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.medical_diagnosisScalarFieldKeys'],
        *,
        where: Optional['types.medical_diagnosisWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.medical_diagnosisAvgAggregateInput'] = None,
        sum: Optional['types.medical_diagnosisSumAggregateInput'] = None,
        min: Optional['types.medical_diagnosisMinAggregateInput'] = None,
        max: Optional['types.medical_diagnosisMaxAggregateInput'] = None,
        having: Optional['types.medical_diagnosisScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.medical_diagnosisCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.medical_diagnosisScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.medical_diagnosisScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.medical_diagnosisGroupByOutput']:
        """Group medical_diagnosis records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar medical_diagnosis fields to group records by
        where
            medical_diagnosis filter to select records
        take
            Limit the maximum number of medical_diagnosis records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.medical_diagnosisGroupByOutput]
            A list of dictionaries representing the medical_diagnosis record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group medical_diagnosis records by description values
        # and count how many records are in each group
        results = await medical_diagnosis.prisma().group_by(
            ['description'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class medical_prescriptionActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.medical_prescription]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await medical_prescription.prisma().query_raw(
            'SELECT * FROM medical_prescription WHERE id = ?',
            1716228995,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.medical_prescription
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await medical_prescription.prisma().query_first(
            'SELECT * FROM medical_prescription WHERE medical_consultation_id = ?',
            'bigjhdgbjc',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.medical_prescriptionCreateInput,
        include: Optional[types.medical_prescriptionInclude] = None
    ) -> _PrismaModelT:
        """Create a new medical_prescription record.

        Parameters
        ----------
        data
            medical_prescription record data
        include
            Specifies which relations should be loaded on the returned medical_prescription model

        Returns
        -------
        prisma.models.medical_prescription
            The created medical_prescription record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a medical_prescription record from just the required fields
        medical_prescription = await medical_prescription.prisma().create(
            data={
                # data to create a medical_prescription record
                'medical_consultation_id': 'bfifdebhfd',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.medical_prescriptionCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple medical_prescription records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of medical_prescription record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await medical_prescription.prisma().create_many(
            data=[
                {
                    # data to create a medical_prescription record
                    'medical_consultation_id': 'cjchbjde',
                },
                {
                    # data to create a medical_prescription record
                    'medical_consultation_id': 'bfiibjcehj',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.medical_prescriptionWhereUniqueInput,
        include: Optional[types.medical_prescriptionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single medical_prescription record.

        Parameters
        ----------
        where
            medical_prescription filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned medical_prescription model

        Returns
        -------
        prisma.models.medical_prescription
            The deleted medical_prescription record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        medical_prescription = await medical_prescription.prisma().delete(
            where={
                'id': 898405676,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.medical_prescriptionWhereUniqueInput,
        include: Optional[types.medical_prescriptionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique medical_prescription record.

        Parameters
        ----------
        where
            medical_prescription filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned medical_prescription model

        Returns
        -------
        prisma.models.medical_prescription
            The found medical_prescription record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        medical_prescription = await medical_prescription.prisma().find_unique(
            where={
                'id': 777460725,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.medical_prescriptionWhereUniqueInput,
        include: Optional[types.medical_prescriptionInclude] = None
    ) -> _PrismaModelT:
        """Find a unique medical_prescription record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            medical_prescription filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned medical_prescription model

        Returns
        -------
        prisma.models.medical_prescription
            The found medical_prescription record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        medical_prescription = await medical_prescription.prisma().find_unique_or_raise(
            where={
                'id': 437894538,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.medical_prescriptionWhereInput] = None,
        cursor: Optional[types.medical_prescriptionWhereUniqueInput] = None,
        include: Optional[types.medical_prescriptionInclude] = None,
        order: Optional[Union[types.medical_prescriptionOrderByInput, List[types.medical_prescriptionOrderByInput]]] = None,
        distinct: Optional[List[types.medical_prescriptionScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple medical_prescription records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of medical_prescription records returned
        skip
            Ignore the first N results
        where
            medical_prescription filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned medical_prescription model
        order
            Order the returned medical_prescription records by any field
        distinct
            Filter medical_prescription records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.medical_prescription]
            The list of all medical_prescription records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 medical_prescription records
        medical_prescriptions = await medical_prescription.prisma().find_many(take=10)

        # find the first 5 medical_prescription records ordered by the medical_instructions field
        medical_prescriptions = await medical_prescription.prisma().find_many(
            take=5,
            order={
                'medical_instructions': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.medical_prescriptionWhereInput] = None,
        cursor: Optional[types.medical_prescriptionWhereUniqueInput] = None,
        include: Optional[types.medical_prescriptionInclude] = None,
        order: Optional[Union[types.medical_prescriptionOrderByInput, List[types.medical_prescriptionOrderByInput]]] = None,
        distinct: Optional[List[types.medical_prescriptionScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single medical_prescription record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            medical_prescription filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned medical_prescription model
        order
            Order the returned medical_prescription records by any field
        distinct
            Filter medical_prescription records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.medical_prescription
            The first medical_prescription record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second medical_prescription record ordered by the id field
        medical_prescription = await medical_prescription.prisma().find_first(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.medical_prescriptionWhereInput] = None,
        cursor: Optional[types.medical_prescriptionWhereUniqueInput] = None,
        include: Optional[types.medical_prescriptionInclude] = None,
        order: Optional[Union[types.medical_prescriptionOrderByInput, List[types.medical_prescriptionOrderByInput]]] = None,
        distinct: Optional[List[types.medical_prescriptionScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single medical_prescription record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            medical_prescription filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned medical_prescription model
        order
            Order the returned medical_prescription records by any field
        distinct
            Filter medical_prescription records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.medical_prescription
            The first medical_prescription record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second medical_prescription record ordered by the medical_consultation_id field
        medical_prescription = await medical_prescription.prisma().find_first_or_raise(
            skip=1,
            order={
                'medical_consultation_id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.medical_prescriptionUpdateInput,
        where: types.medical_prescriptionWhereUniqueInput,
        include: Optional[types.medical_prescriptionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single medical_prescription record.

        Parameters
        ----------
        data
            medical_prescription record data specifying what to update
        where
            medical_prescription filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned medical_prescription model

        Returns
        -------
        prisma.models.medical_prescription
            The updated medical_prescription record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        medical_prescription = await medical_prescription.prisma().update(
            where={
                'id': 393342971,
            },
            data={
                # data to update the medical_prescription record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.medical_prescriptionWhereUniqueInput,
        data: types.medical_prescriptionUpsertInput,
        include: Optional[types.medical_prescriptionInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            medical_prescription filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned medical_prescription model

        Returns
        -------
        prisma.models.medical_prescription
            The created or updated medical_prescription record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        medical_prescription = await medical_prescription.prisma().upsert(
            where={
                'id': 163829784,
            },
            data={
                'create': {
                    'id': 163829784,
                    'medical_consultation_id': 'bfiibjcehj',
                },
                'update': {
                    'medical_consultation_id': 'bfiibjcehj',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.medical_prescriptionUpdateManyMutationInput,
        where: types.medical_prescriptionWhereInput,
    ) -> int:
        """Update multiple medical_prescription records

        Parameters
        ----------
        data
            medical_prescription data to update the selected medical_prescription records to
        where
            Filter to select the medical_prescription records to update

        Returns
        -------
        int
            The total number of medical_prescription records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all medical_prescription records
        total = await medical_prescription.prisma().update_many(
            data={
                'medical_instructions': 'ceibfcgij'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.medical_prescriptionWhereInput] = None,
        cursor: Optional[types.medical_prescriptionWhereUniqueInput] = None,
    ) -> int:
        """Count the number of medical_prescription records present in the database

        Parameters
        ----------
        select
            Select the medical_prescription fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            medical_prescription filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.medical_prescriptionCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await medical_prescription.prisma().count()

        # results: prisma.types.medical_prescriptionCountAggregateOutput
        results = await medical_prescription.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.medical_prescriptionCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.medical_prescriptionWhereInput] = None,
        cursor: Optional[types.medical_prescriptionWhereUniqueInput] = None,
    ) -> types.medical_prescriptionCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.medical_prescriptionCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.medical_prescriptionWhereInput] = None,
        cursor: Optional[types.medical_prescriptionWhereUniqueInput] = None,
    ) -> Union[int, types.medical_prescriptionCountAggregateOutput]:
        """Count the number of medical_prescription records present in the database

        Parameters
        ----------
        select
            Select the medical_prescription fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            medical_prescription filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.medical_prescriptionCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await medical_prescription.prisma().count()

        # results: prisma.types.medical_prescriptionCountAggregateOutput
        results = await medical_prescription.prisma().count(
            select={
                '_all': True,
                'medical_consultation_id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.medical_prescriptionCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.medical_prescriptionWhereInput] = None
    ) -> int:
        """Delete multiple medical_prescription records.

        Parameters
        ----------
        where
            Optional medical_prescription filter to find the records to be deleted

        Returns
        -------
        int
            The total number of medical_prescription records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all medical_prescription records
        total = await medical_prescription.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.medical_prescriptionScalarFieldKeys'],
        *,
        where: Optional['types.medical_prescriptionWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.medical_prescriptionAvgAggregateInput'] = None,
        sum: Optional['types.medical_prescriptionSumAggregateInput'] = None,
        min: Optional['types.medical_prescriptionMinAggregateInput'] = None,
        max: Optional['types.medical_prescriptionMaxAggregateInput'] = None,
        having: Optional['types.medical_prescriptionScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.medical_prescriptionCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.medical_prescriptionScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.medical_prescriptionScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.medical_prescriptionGroupByOutput']:
        """Group medical_prescription records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar medical_prescription fields to group records by
        where
            medical_prescription filter to select records
        take
            Limit the maximum number of medical_prescription records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.medical_prescriptionGroupByOutput]
            A list of dictionaries representing the medical_prescription record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group medical_prescription records by medical_instructions values
        # and count how many records are in each group
        results = await medical_prescription.prisma().group_by(
            ['medical_instructions'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class medical_prescription_detailActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.medical_prescription_detail]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await medical_prescription_detail.prisma().query_raw(
            'SELECT * FROM medical_prescription_detail WHERE id = ?',
            341715030,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.medical_prescription_detail
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await medical_prescription_detail.prisma().query_first(
            'SELECT * FROM medical_prescription_detail WHERE medical_prescription_id = ?',
            1692766423,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.medical_prescription_detailCreateInput,
        include: Optional[types.medical_prescription_detailInclude] = None
    ) -> _PrismaModelT:
        """Create a new medical_prescription_detail record.

        Parameters
        ----------
        data
            medical_prescription_detail record data
        include
            Specifies which relations should be loaded on the returned medical_prescription_detail model

        Returns
        -------
        prisma.models.medical_prescription_detail
            The created medical_prescription_detail record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a medical_prescription_detail record from just the required fields
        medical_prescription_detail = await medical_prescription_detail.prisma().create(
            data={
                # data to create a medical_prescription_detail record
                'medical_prescription_id': 86662596,
                'name': 'bgjhijffjh',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.medical_prescription_detailCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple medical_prescription_detail records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of medical_prescription_detail record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await medical_prescription_detail.prisma().create_many(
            data=[
                {
                    # data to create a medical_prescription_detail record
                    'medical_prescription_id': 1286370274,
                    'name': 'igefhgdhb',
                },
                {
                    # data to create a medical_prescription_detail record
                    'medical_prescription_id': 491885104,
                    'name': 'djcfgedjd',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.medical_prescription_detailWhereUniqueInput,
        include: Optional[types.medical_prescription_detailInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single medical_prescription_detail record.

        Parameters
        ----------
        where
            medical_prescription_detail filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned medical_prescription_detail model

        Returns
        -------
        prisma.models.medical_prescription_detail
            The deleted medical_prescription_detail record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        medical_prescription_detail = await medical_prescription_detail.prisma().delete(
            where={
                'id': 1319234606,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.medical_prescription_detailWhereUniqueInput,
        include: Optional[types.medical_prescription_detailInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique medical_prescription_detail record.

        Parameters
        ----------
        where
            medical_prescription_detail filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned medical_prescription_detail model

        Returns
        -------
        prisma.models.medical_prescription_detail
            The found medical_prescription_detail record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        medical_prescription_detail = await medical_prescription_detail.prisma().find_unique(
            where={
                'id': 712754127,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.medical_prescription_detailWhereUniqueInput,
        include: Optional[types.medical_prescription_detailInclude] = None
    ) -> _PrismaModelT:
        """Find a unique medical_prescription_detail record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            medical_prescription_detail filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned medical_prescription_detail model

        Returns
        -------
        prisma.models.medical_prescription_detail
            The found medical_prescription_detail record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        medical_prescription_detail = await medical_prescription_detail.prisma().find_unique_or_raise(
            where={
                'id': 1299554652,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.medical_prescription_detailWhereInput] = None,
        cursor: Optional[types.medical_prescription_detailWhereUniqueInput] = None,
        include: Optional[types.medical_prescription_detailInclude] = None,
        order: Optional[Union[types.medical_prescription_detailOrderByInput, List[types.medical_prescription_detailOrderByInput]]] = None,
        distinct: Optional[List[types.medical_prescription_detailScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple medical_prescription_detail records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of medical_prescription_detail records returned
        skip
            Ignore the first N results
        where
            medical_prescription_detail filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned medical_prescription_detail model
        order
            Order the returned medical_prescription_detail records by any field
        distinct
            Filter medical_prescription_detail records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.medical_prescription_detail]
            The list of all medical_prescription_detail records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 medical_prescription_detail records
        medical_prescription_details = await medical_prescription_detail.prisma().find_many(take=10)

        # find the first 5 medical_prescription_detail records ordered by the name field
        medical_prescription_details = await medical_prescription_detail.prisma().find_many(
            take=5,
            order={
                'name': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.medical_prescription_detailWhereInput] = None,
        cursor: Optional[types.medical_prescription_detailWhereUniqueInput] = None,
        include: Optional[types.medical_prescription_detailInclude] = None,
        order: Optional[Union[types.medical_prescription_detailOrderByInput, List[types.medical_prescription_detailOrderByInput]]] = None,
        distinct: Optional[List[types.medical_prescription_detailScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single medical_prescription_detail record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            medical_prescription_detail filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned medical_prescription_detail model
        order
            Order the returned medical_prescription_detail records by any field
        distinct
            Filter medical_prescription_detail records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.medical_prescription_detail
            The first medical_prescription_detail record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second medical_prescription_detail record ordered by the dose field
        medical_prescription_detail = await medical_prescription_detail.prisma().find_first(
            skip=1,
            order={
                'dose': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.medical_prescription_detailWhereInput] = None,
        cursor: Optional[types.medical_prescription_detailWhereUniqueInput] = None,
        include: Optional[types.medical_prescription_detailInclude] = None,
        order: Optional[Union[types.medical_prescription_detailOrderByInput, List[types.medical_prescription_detailOrderByInput]]] = None,
        distinct: Optional[List[types.medical_prescription_detailScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single medical_prescription_detail record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            medical_prescription_detail filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned medical_prescription_detail model
        order
            Order the returned medical_prescription_detail records by any field
        distinct
            Filter medical_prescription_detail records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.medical_prescription_detail
            The first medical_prescription_detail record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second medical_prescription_detail record ordered by the frequency field
        medical_prescription_detail = await medical_prescription_detail.prisma().find_first_or_raise(
            skip=1,
            order={
                'frequency': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.medical_prescription_detailUpdateInput,
        where: types.medical_prescription_detailWhereUniqueInput,
        include: Optional[types.medical_prescription_detailInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single medical_prescription_detail record.

        Parameters
        ----------
        data
            medical_prescription_detail record data specifying what to update
        where
            medical_prescription_detail filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned medical_prescription_detail model

        Returns
        -------
        prisma.models.medical_prescription_detail
            The updated medical_prescription_detail record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        medical_prescription_detail = await medical_prescription_detail.prisma().update(
            where={
                'id': 2070408293,
            },
            data={
                # data to update the medical_prescription_detail record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.medical_prescription_detailWhereUniqueInput,
        data: types.medical_prescription_detailUpsertInput,
        include: Optional[types.medical_prescription_detailInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            medical_prescription_detail filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned medical_prescription_detail model

        Returns
        -------
        prisma.models.medical_prescription_detail
            The created or updated medical_prescription_detail record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        medical_prescription_detail = await medical_prescription_detail.prisma().upsert(
            where={
                'id': 811900218,
            },
            data={
                'create': {
                    'id': 811900218,
                    'medical_prescription_id': 491885104,
                    'name': 'djcfgedjd',
                },
                'update': {
                    'medical_prescription_id': 491885104,
                    'name': 'djcfgedjd',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.medical_prescription_detailUpdateManyMutationInput,
        where: types.medical_prescription_detailWhereInput,
    ) -> int:
        """Update multiple medical_prescription_detail records

        Parameters
        ----------
        data
            medical_prescription_detail data to update the selected medical_prescription_detail records to
        where
            Filter to select the medical_prescription_detail records to update

        Returns
        -------
        int
            The total number of medical_prescription_detail records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all medical_prescription_detail records
        total = await medical_prescription_detail.prisma().update_many(
            data={
                'duration_of_treatment': 'djgacbcch'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.medical_prescription_detailWhereInput] = None,
        cursor: Optional[types.medical_prescription_detailWhereUniqueInput] = None,
    ) -> int:
        """Count the number of medical_prescription_detail records present in the database

        Parameters
        ----------
        select
            Select the medical_prescription_detail fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            medical_prescription_detail filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.medical_prescription_detailCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await medical_prescription_detail.prisma().count()

        # results: prisma.types.medical_prescription_detailCountAggregateOutput
        results = await medical_prescription_detail.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.medical_prescription_detailCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.medical_prescription_detailWhereInput] = None,
        cursor: Optional[types.medical_prescription_detailWhereUniqueInput] = None,
    ) -> types.medical_prescription_detailCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.medical_prescription_detailCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.medical_prescription_detailWhereInput] = None,
        cursor: Optional[types.medical_prescription_detailWhereUniqueInput] = None,
    ) -> Union[int, types.medical_prescription_detailCountAggregateOutput]:
        """Count the number of medical_prescription_detail records present in the database

        Parameters
        ----------
        select
            Select the medical_prescription_detail fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            medical_prescription_detail filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.medical_prescription_detailCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await medical_prescription_detail.prisma().count()

        # results: prisma.types.medical_prescription_detailCountAggregateOutput
        results = await medical_prescription_detail.prisma().count(
            select={
                '_all': True,
                'medical_prescription_id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.medical_prescription_detailCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.medical_prescription_detailWhereInput] = None
    ) -> int:
        """Delete multiple medical_prescription_detail records.

        Parameters
        ----------
        where
            Optional medical_prescription_detail filter to find the records to be deleted

        Returns
        -------
        int
            The total number of medical_prescription_detail records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all medical_prescription_detail records
        total = await medical_prescription_detail.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.medical_prescription_detailScalarFieldKeys'],
        *,
        where: Optional['types.medical_prescription_detailWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.medical_prescription_detailAvgAggregateInput'] = None,
        sum: Optional['types.medical_prescription_detailSumAggregateInput'] = None,
        min: Optional['types.medical_prescription_detailMinAggregateInput'] = None,
        max: Optional['types.medical_prescription_detailMaxAggregateInput'] = None,
        having: Optional['types.medical_prescription_detailScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.medical_prescription_detailCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.medical_prescription_detailScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.medical_prescription_detailScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.medical_prescription_detailGroupByOutput']:
        """Group medical_prescription_detail records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar medical_prescription_detail fields to group records by
        where
            medical_prescription_detail filter to select records
        take
            Limit the maximum number of medical_prescription_detail records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.medical_prescription_detailGroupByOutput]
            A list of dictionaries representing the medical_prescription_detail record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group medical_prescription_detail records by name values
        # and count how many records are in each group
        results = await medical_prescription_detail.prisma().group_by(
            ['name'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class medical_procedureActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.medical_procedure]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await medical_procedure.prisma().query_raw(
            'SELECT * FROM medical_procedure WHERE id = ?',
            644446024,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.medical_procedure
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await medical_procedure.prisma().query_first(
            'SELECT * FROM medical_procedure WHERE medical_consultation_id = ?',
            'bbgdigchd',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.medical_procedureCreateInput,
        include: Optional[types.medical_procedureInclude] = None
    ) -> _PrismaModelT:
        """Create a new medical_procedure record.

        Parameters
        ----------
        data
            medical_procedure record data
        include
            Specifies which relations should be loaded on the returned medical_procedure model

        Returns
        -------
        prisma.models.medical_procedure
            The created medical_procedure record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a medical_procedure record from just the required fields
        medical_procedure = await medical_procedure.prisma().create(
            data={
                # data to create a medical_procedure record
                'medical_consultation_id': 'dajcifgdi',
                'name': 'ccedhdbj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.medical_procedureCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple medical_procedure records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of medical_procedure record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await medical_procedure.prisma().create_many(
            data=[
                {
                    # data to create a medical_procedure record
                    'medical_consultation_id': 'bjaabjjjce',
                    'name': 'cafhdcdcjd',
                },
                {
                    # data to create a medical_procedure record
                    'medical_consultation_id': 'bdeebbhbdi',
                    'name': 'cafcbdchah',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.medical_procedureWhereUniqueInput,
        include: Optional[types.medical_procedureInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single medical_procedure record.

        Parameters
        ----------
        where
            medical_procedure filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned medical_procedure model

        Returns
        -------
        prisma.models.medical_procedure
            The deleted medical_procedure record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        medical_procedure = await medical_procedure.prisma().delete(
            where={
                'id': 1355147104,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.medical_procedureWhereUniqueInput,
        include: Optional[types.medical_procedureInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique medical_procedure record.

        Parameters
        ----------
        where
            medical_procedure filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned medical_procedure model

        Returns
        -------
        prisma.models.medical_procedure
            The found medical_procedure record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        medical_procedure = await medical_procedure.prisma().find_unique(
            where={
                'id': 84079641,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.medical_procedureWhereUniqueInput,
        include: Optional[types.medical_procedureInclude] = None
    ) -> _PrismaModelT:
        """Find a unique medical_procedure record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            medical_procedure filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned medical_procedure model

        Returns
        -------
        prisma.models.medical_procedure
            The found medical_procedure record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        medical_procedure = await medical_procedure.prisma().find_unique_or_raise(
            where={
                'id': 754433246,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.medical_procedureWhereInput] = None,
        cursor: Optional[types.medical_procedureWhereUniqueInput] = None,
        include: Optional[types.medical_procedureInclude] = None,
        order: Optional[Union[types.medical_procedureOrderByInput, List[types.medical_procedureOrderByInput]]] = None,
        distinct: Optional[List[types.medical_procedureScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple medical_procedure records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of medical_procedure records returned
        skip
            Ignore the first N results
        where
            medical_procedure filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned medical_procedure model
        order
            Order the returned medical_procedure records by any field
        distinct
            Filter medical_procedure records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.medical_procedure]
            The list of all medical_procedure records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 medical_procedure records
        medical_procedures = await medical_procedure.prisma().find_many(take=10)

        # find the first 5 medical_procedure records ordered by the name field
        medical_procedures = await medical_procedure.prisma().find_many(
            take=5,
            order={
                'name': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.medical_procedureWhereInput] = None,
        cursor: Optional[types.medical_procedureWhereUniqueInput] = None,
        include: Optional[types.medical_procedureInclude] = None,
        order: Optional[Union[types.medical_procedureOrderByInput, List[types.medical_procedureOrderByInput]]] = None,
        distinct: Optional[List[types.medical_procedureScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single medical_procedure record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            medical_procedure filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned medical_procedure model
        order
            Order the returned medical_procedure records by any field
        distinct
            Filter medical_procedure records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.medical_procedure
            The first medical_procedure record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second medical_procedure record ordered by the notes field
        medical_procedure = await medical_procedure.prisma().find_first(
            skip=1,
            order={
                'notes': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.medical_procedureWhereInput] = None,
        cursor: Optional[types.medical_procedureWhereUniqueInput] = None,
        include: Optional[types.medical_procedureInclude] = None,
        order: Optional[Union[types.medical_procedureOrderByInput, List[types.medical_procedureOrderByInput]]] = None,
        distinct: Optional[List[types.medical_procedureScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single medical_procedure record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            medical_procedure filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned medical_procedure model
        order
            Order the returned medical_procedure records by any field
        distinct
            Filter medical_procedure records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.medical_procedure
            The first medical_procedure record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second medical_procedure record ordered by the id field
        medical_procedure = await medical_procedure.prisma().find_first_or_raise(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.medical_procedureUpdateInput,
        where: types.medical_procedureWhereUniqueInput,
        include: Optional[types.medical_procedureInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single medical_procedure record.

        Parameters
        ----------
        data
            medical_procedure record data specifying what to update
        where
            medical_procedure filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned medical_procedure model

        Returns
        -------
        prisma.models.medical_procedure
            The updated medical_procedure record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        medical_procedure = await medical_procedure.prisma().update(
            where={
                'id': 314261183,
            },
            data={
                # data to update the medical_procedure record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.medical_procedureWhereUniqueInput,
        data: types.medical_procedureUpsertInput,
        include: Optional[types.medical_procedureInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            medical_procedure filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned medical_procedure model

        Returns
        -------
        prisma.models.medical_procedure
            The created or updated medical_procedure record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        medical_procedure = await medical_procedure.prisma().upsert(
            where={
                'id': 227678604,
            },
            data={
                'create': {
                    'id': 227678604,
                    'medical_consultation_id': 'bdeebbhbdi',
                    'name': 'cafcbdchah',
                },
                'update': {
                    'medical_consultation_id': 'bdeebbhbdi',
                    'name': 'cafcbdchah',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.medical_procedureUpdateManyMutationInput,
        where: types.medical_procedureWhereInput,
    ) -> int:
        """Update multiple medical_procedure records

        Parameters
        ----------
        data
            medical_procedure data to update the selected medical_procedure records to
        where
            Filter to select the medical_procedure records to update

        Returns
        -------
        int
            The total number of medical_procedure records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all medical_procedure records
        total = await medical_procedure.prisma().update_many(
            data={
                'medical_consultation_id': 'ecdjjjhab'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.medical_procedureWhereInput] = None,
        cursor: Optional[types.medical_procedureWhereUniqueInput] = None,
    ) -> int:
        """Count the number of medical_procedure records present in the database

        Parameters
        ----------
        select
            Select the medical_procedure fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            medical_procedure filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.medical_procedureCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await medical_procedure.prisma().count()

        # results: prisma.types.medical_procedureCountAggregateOutput
        results = await medical_procedure.prisma().count(
            select={
                '_all': True,
                'name': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.medical_procedureCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.medical_procedureWhereInput] = None,
        cursor: Optional[types.medical_procedureWhereUniqueInput] = None,
    ) -> types.medical_procedureCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.medical_procedureCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.medical_procedureWhereInput] = None,
        cursor: Optional[types.medical_procedureWhereUniqueInput] = None,
    ) -> Union[int, types.medical_procedureCountAggregateOutput]:
        """Count the number of medical_procedure records present in the database

        Parameters
        ----------
        select
            Select the medical_procedure fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            medical_procedure filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.medical_procedureCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await medical_procedure.prisma().count()

        # results: prisma.types.medical_procedureCountAggregateOutput
        results = await medical_procedure.prisma().count(
            select={
                '_all': True,
                'notes': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.medical_procedureCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.medical_procedureWhereInput] = None
    ) -> int:
        """Delete multiple medical_procedure records.

        Parameters
        ----------
        where
            Optional medical_procedure filter to find the records to be deleted

        Returns
        -------
        int
            The total number of medical_procedure records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all medical_procedure records
        total = await medical_procedure.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.medical_procedureScalarFieldKeys'],
        *,
        where: Optional['types.medical_procedureWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.medical_procedureAvgAggregateInput'] = None,
        sum: Optional['types.medical_procedureSumAggregateInput'] = None,
        min: Optional['types.medical_procedureMinAggregateInput'] = None,
        max: Optional['types.medical_procedureMaxAggregateInput'] = None,
        having: Optional['types.medical_procedureScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.medical_procedureCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.medical_procedureScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.medical_procedureScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.medical_procedureGroupByOutput']:
        """Group medical_procedure records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar medical_procedure fields to group records by
        where
            medical_procedure filter to select records
        take
            Limit the maximum number of medical_procedure records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.medical_procedureGroupByOutput]
            A list of dictionaries representing the medical_procedure record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group medical_procedure records by id values
        # and count how many records are in each group
        results = await medical_procedure.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class phsycal_examinationActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.phsycal_examination]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await phsycal_examination.prisma().query_raw(
            'SELECT * FROM phsycal_examination WHERE id = ?',
            180275434,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.phsycal_examination
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await phsycal_examination.prisma().query_first(
            'SELECT * FROM phsycal_examination WHERE medical_consultation_id = ?',
            'fhgaibff',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.phsycal_examinationCreateInput,
        include: Optional[types.phsycal_examinationInclude] = None
    ) -> _PrismaModelT:
        """Create a new phsycal_examination record.

        Parameters
        ----------
        data
            phsycal_examination record data
        include
            Specifies which relations should be loaded on the returned phsycal_examination model

        Returns
        -------
        prisma.models.phsycal_examination
            The created phsycal_examination record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a phsycal_examination record from just the required fields
        phsycal_examination = await phsycal_examination.prisma().create(
            data={
                # data to create a phsycal_examination record
                'medical_consultation_id': 'cadajbcbca',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.phsycal_examinationCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple phsycal_examination records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of phsycal_examination record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await phsycal_examination.prisma().create_many(
            data=[
                {
                    # data to create a phsycal_examination record
                    'medical_consultation_id': 'bjheigfcdd',
                },
                {
                    # data to create a phsycal_examination record
                    'medical_consultation_id': 'bjejigcdcg',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.phsycal_examinationWhereUniqueInput,
        include: Optional[types.phsycal_examinationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single phsycal_examination record.

        Parameters
        ----------
        where
            phsycal_examination filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned phsycal_examination model

        Returns
        -------
        prisma.models.phsycal_examination
            The deleted phsycal_examination record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        phsycal_examination = await phsycal_examination.prisma().delete(
            where={
                'id': 1858881207,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.phsycal_examinationWhereUniqueInput,
        include: Optional[types.phsycal_examinationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique phsycal_examination record.

        Parameters
        ----------
        where
            phsycal_examination filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned phsycal_examination model

        Returns
        -------
        prisma.models.phsycal_examination
            The found phsycal_examination record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        phsycal_examination = await phsycal_examination.prisma().find_unique(
            where={
                'id': 319819300,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.phsycal_examinationWhereUniqueInput,
        include: Optional[types.phsycal_examinationInclude] = None
    ) -> _PrismaModelT:
        """Find a unique phsycal_examination record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            phsycal_examination filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned phsycal_examination model

        Returns
        -------
        prisma.models.phsycal_examination
            The found phsycal_examination record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        phsycal_examination = await phsycal_examination.prisma().find_unique_or_raise(
            where={
                'id': 368913805,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.phsycal_examinationWhereInput] = None,
        cursor: Optional[types.phsycal_examinationWhereUniqueInput] = None,
        include: Optional[types.phsycal_examinationInclude] = None,
        order: Optional[Union[types.phsycal_examinationOrderByInput, List[types.phsycal_examinationOrderByInput]]] = None,
        distinct: Optional[List[types.phsycal_examinationScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple phsycal_examination records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of phsycal_examination records returned
        skip
            Ignore the first N results
        where
            phsycal_examination filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned phsycal_examination model
        order
            Order the returned phsycal_examination records by any field
        distinct
            Filter phsycal_examination records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.phsycal_examination]
            The list of all phsycal_examination records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 phsycal_examination records
        phsycal_examinations = await phsycal_examination.prisma().find_many(take=10)

        # find the first 5 phsycal_examination records ordered by the digestive_system field
        phsycal_examinations = await phsycal_examination.prisma().find_many(
            take=5,
            order={
                'digestive_system': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.phsycal_examinationWhereInput] = None,
        cursor: Optional[types.phsycal_examinationWhereUniqueInput] = None,
        include: Optional[types.phsycal_examinationInclude] = None,
        order: Optional[Union[types.phsycal_examinationOrderByInput, List[types.phsycal_examinationOrderByInput]]] = None,
        distinct: Optional[List[types.phsycal_examinationScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single phsycal_examination record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            phsycal_examination filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned phsycal_examination model
        order
            Order the returned phsycal_examination records by any field
        distinct
            Filter phsycal_examination records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.phsycal_examination
            The first phsycal_examination record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second phsycal_examination record ordered by the reproductive_system field
        phsycal_examination = await phsycal_examination.prisma().find_first(
            skip=1,
            order={
                'reproductive_system': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.phsycal_examinationWhereInput] = None,
        cursor: Optional[types.phsycal_examinationWhereUniqueInput] = None,
        include: Optional[types.phsycal_examinationInclude] = None,
        order: Optional[Union[types.phsycal_examinationOrderByInput, List[types.phsycal_examinationOrderByInput]]] = None,
        distinct: Optional[List[types.phsycal_examinationScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single phsycal_examination record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            phsycal_examination filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned phsycal_examination model
        order
            Order the returned phsycal_examination records by any field
        distinct
            Filter phsycal_examination records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.phsycal_examination
            The first phsycal_examination record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second phsycal_examination record ordered by the urinary_system field
        phsycal_examination = await phsycal_examination.prisma().find_first_or_raise(
            skip=1,
            order={
                'urinary_system': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.phsycal_examinationUpdateInput,
        where: types.phsycal_examinationWhereUniqueInput,
        include: Optional[types.phsycal_examinationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single phsycal_examination record.

        Parameters
        ----------
        data
            phsycal_examination record data specifying what to update
        where
            phsycal_examination filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned phsycal_examination model

        Returns
        -------
        prisma.models.phsycal_examination
            The updated phsycal_examination record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        phsycal_examination = await phsycal_examination.prisma().update(
            where={
                'id': 146508610,
            },
            data={
                # data to update the phsycal_examination record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.phsycal_examinationWhereUniqueInput,
        data: types.phsycal_examinationUpsertInput,
        include: Optional[types.phsycal_examinationInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            phsycal_examination filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned phsycal_examination model

        Returns
        -------
        prisma.models.phsycal_examination
            The created or updated phsycal_examination record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        phsycal_examination = await phsycal_examination.prisma().upsert(
            where={
                'id': 1398052691,
            },
            data={
                'create': {
                    'id': 1398052691,
                    'medical_consultation_id': 'bjejigcdcg',
                },
                'update': {
                    'medical_consultation_id': 'bjejigcdcg',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.phsycal_examinationUpdateManyMutationInput,
        where: types.phsycal_examinationWhereInput,
    ) -> int:
        """Update multiple phsycal_examination records

        Parameters
        ----------
        data
            phsycal_examination data to update the selected phsycal_examination records to
        where
            Filter to select the phsycal_examination records to update

        Returns
        -------
        int
            The total number of phsycal_examination records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all phsycal_examination records
        total = await phsycal_examination.prisma().update_many(
            data={
                'cardiac_and_vascular': 'bficecgcfg'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.phsycal_examinationWhereInput] = None,
        cursor: Optional[types.phsycal_examinationWhereUniqueInput] = None,
    ) -> int:
        """Count the number of phsycal_examination records present in the database

        Parameters
        ----------
        select
            Select the phsycal_examination fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            phsycal_examination filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.phsycal_examinationCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await phsycal_examination.prisma().count()

        # results: prisma.types.phsycal_examinationCountAggregateOutput
        results = await phsycal_examination.prisma().count(
            select={
                '_all': True,
                'dental': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.phsycal_examinationCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.phsycal_examinationWhereInput] = None,
        cursor: Optional[types.phsycal_examinationWhereUniqueInput] = None,
    ) -> types.phsycal_examinationCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.phsycal_examinationCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.phsycal_examinationWhereInput] = None,
        cursor: Optional[types.phsycal_examinationWhereUniqueInput] = None,
    ) -> Union[int, types.phsycal_examinationCountAggregateOutput]:
        """Count the number of phsycal_examination records present in the database

        Parameters
        ----------
        select
            Select the phsycal_examination fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            phsycal_examination filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.phsycal_examinationCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await phsycal_examination.prisma().count()

        # results: prisma.types.phsycal_examinationCountAggregateOutput
        results = await phsycal_examination.prisma().count(
            select={
                '_all': True,
                'dermatological': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.phsycal_examinationCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.phsycal_examinationWhereInput] = None
    ) -> int:
        """Delete multiple phsycal_examination records.

        Parameters
        ----------
        where
            Optional phsycal_examination filter to find the records to be deleted

        Returns
        -------
        int
            The total number of phsycal_examination records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all phsycal_examination records
        total = await phsycal_examination.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.phsycal_examinationScalarFieldKeys'],
        *,
        where: Optional['types.phsycal_examinationWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.phsycal_examinationAvgAggregateInput'] = None,
        sum: Optional['types.phsycal_examinationSumAggregateInput'] = None,
        min: Optional['types.phsycal_examinationMinAggregateInput'] = None,
        max: Optional['types.phsycal_examinationMaxAggregateInput'] = None,
        having: Optional['types.phsycal_examinationScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.phsycal_examinationCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.phsycal_examinationScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.phsycal_examinationScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.phsycal_examinationGroupByOutput']:
        """Group phsycal_examination records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar phsycal_examination fields to group records by
        where
            phsycal_examination filter to select records
        take
            Limit the maximum number of phsycal_examination records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.phsycal_examinationGroupByOutput]
            A list of dictionaries representing the phsycal_examination record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group phsycal_examination records by neurological values
        # and count how many records are in each group
        results = await phsycal_examination.prisma().group_by(
            ['neurological'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class topographic_explorationActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.topographic_exploration]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await topographic_exploration.prisma().query_raw(
            'SELECT * FROM topographic_exploration WHERE id = ?',
            219944329,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.topographic_exploration
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await topographic_exploration.prisma().query_first(
            'SELECT * FROM topographic_exploration WHERE medical_consultation_id = ?',
            'dedgbbhja',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.topographic_explorationCreateInput,
        include: Optional[types.topographic_explorationInclude] = None
    ) -> _PrismaModelT:
        """Create a new topographic_exploration record.

        Parameters
        ----------
        data
            topographic_exploration record data
        include
            Specifies which relations should be loaded on the returned topographic_exploration model

        Returns
        -------
        prisma.models.topographic_exploration
            The created topographic_exploration record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a topographic_exploration record from just the required fields
        topographic_exploration = await topographic_exploration.prisma().create(
            data={
                # data to create a topographic_exploration record
                'medical_consultation_id': 'cabiahchj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.topographic_explorationCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple topographic_exploration records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of topographic_exploration record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await topographic_exploration.prisma().create_many(
            data=[
                {
                    # data to create a topographic_exploration record
                    'medical_consultation_id': 'cgbeccfce',
                },
                {
                    # data to create a topographic_exploration record
                    'medical_consultation_id': 'fcjcagef',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.topographic_explorationWhereUniqueInput,
        include: Optional[types.topographic_explorationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single topographic_exploration record.

        Parameters
        ----------
        where
            topographic_exploration filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned topographic_exploration model

        Returns
        -------
        prisma.models.topographic_exploration
            The deleted topographic_exploration record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        topographic_exploration = await topographic_exploration.prisma().delete(
            where={
                'id': 1637040282,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.topographic_explorationWhereUniqueInput,
        include: Optional[types.topographic_explorationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique topographic_exploration record.

        Parameters
        ----------
        where
            topographic_exploration filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned topographic_exploration model

        Returns
        -------
        prisma.models.topographic_exploration
            The found topographic_exploration record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        topographic_exploration = await topographic_exploration.prisma().find_unique(
            where={
                'id': 2055052747,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.topographic_explorationWhereUniqueInput,
        include: Optional[types.topographic_explorationInclude] = None
    ) -> _PrismaModelT:
        """Find a unique topographic_exploration record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            topographic_exploration filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned topographic_exploration model

        Returns
        -------
        prisma.models.topographic_exploration
            The found topographic_exploration record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        topographic_exploration = await topographic_exploration.prisma().find_unique_or_raise(
            where={
                'id': 59914664,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.topographic_explorationWhereInput] = None,
        cursor: Optional[types.topographic_explorationWhereUniqueInput] = None,
        include: Optional[types.topographic_explorationInclude] = None,
        order: Optional[Union[types.topographic_explorationOrderByInput, List[types.topographic_explorationOrderByInput]]] = None,
        distinct: Optional[List[types.topographic_explorationScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple topographic_exploration records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of topographic_exploration records returned
        skip
            Ignore the first N results
        where
            topographic_exploration filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned topographic_exploration model
        order
            Order the returned topographic_exploration records by any field
        distinct
            Filter topographic_exploration records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.topographic_exploration]
            The list of all topographic_exploration records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 topographic_exploration records
        topographic_explorations = await topographic_exploration.prisma().find_many(take=10)

        # find the first 5 topographic_exploration records ordered by the head_front_part field
        topographic_explorations = await topographic_exploration.prisma().find_many(
            take=5,
            order={
                'head_front_part': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.topographic_explorationWhereInput] = None,
        cursor: Optional[types.topographic_explorationWhereUniqueInput] = None,
        include: Optional[types.topographic_explorationInclude] = None,
        order: Optional[Union[types.topographic_explorationOrderByInput, List[types.topographic_explorationOrderByInput]]] = None,
        distinct: Optional[List[types.topographic_explorationScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single topographic_exploration record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            topographic_exploration filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned topographic_exploration model
        order
            Order the returned topographic_exploration records by any field
        distinct
            Filter topographic_exploration records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.topographic_exploration
            The first topographic_exploration record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second topographic_exploration record ordered by the head_back_part field
        topographic_exploration = await topographic_exploration.prisma().find_first(
            skip=1,
            order={
                'head_back_part': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.topographic_explorationWhereInput] = None,
        cursor: Optional[types.topographic_explorationWhereUniqueInput] = None,
        include: Optional[types.topographic_explorationInclude] = None,
        order: Optional[Union[types.topographic_explorationOrderByInput, List[types.topographic_explorationOrderByInput]]] = None,
        distinct: Optional[List[types.topographic_explorationScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single topographic_exploration record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            topographic_exploration filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned topographic_exploration model
        order
            Order the returned topographic_exploration records by any field
        distinct
            Filter topographic_exploration records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.topographic_exploration
            The first topographic_exploration record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second topographic_exploration record ordered by the neck_front_part field
        topographic_exploration = await topographic_exploration.prisma().find_first_or_raise(
            skip=1,
            order={
                'neck_front_part': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.topographic_explorationUpdateInput,
        where: types.topographic_explorationWhereUniqueInput,
        include: Optional[types.topographic_explorationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single topographic_exploration record.

        Parameters
        ----------
        data
            topographic_exploration record data specifying what to update
        where
            topographic_exploration filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned topographic_exploration model

        Returns
        -------
        prisma.models.topographic_exploration
            The updated topographic_exploration record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        topographic_exploration = await topographic_exploration.prisma().update(
            where={
                'id': 1388571841,
            },
            data={
                # data to update the topographic_exploration record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.topographic_explorationWhereUniqueInput,
        data: types.topographic_explorationUpsertInput,
        include: Optional[types.topographic_explorationInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            topographic_exploration filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned topographic_exploration model

        Returns
        -------
        prisma.models.topographic_exploration
            The created or updated topographic_exploration record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        topographic_exploration = await topographic_exploration.prisma().upsert(
            where={
                'id': 232049766,
            },
            data={
                'create': {
                    'id': 232049766,
                    'medical_consultation_id': 'fcjcagef',
                },
                'update': {
                    'medical_consultation_id': 'fcjcagef',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.topographic_explorationUpdateManyMutationInput,
        where: types.topographic_explorationWhereInput,
    ) -> int:
        """Update multiple topographic_exploration records

        Parameters
        ----------
        data
            topographic_exploration data to update the selected topographic_exploration records to
        where
            Filter to select the topographic_exploration records to update

        Returns
        -------
        int
            The total number of topographic_exploration records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all topographic_exploration records
        total = await topographic_exploration.prisma().update_many(
            data={
                'neck_back_part': 'jbijgfbfj'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.topographic_explorationWhereInput] = None,
        cursor: Optional[types.topographic_explorationWhereUniqueInput] = None,
    ) -> int:
        """Count the number of topographic_exploration records present in the database

        Parameters
        ----------
        select
            Select the topographic_exploration fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            topographic_exploration filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.topographic_explorationCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await topographic_exploration.prisma().count()

        # results: prisma.types.topographic_explorationCountAggregateOutput
        results = await topographic_exploration.prisma().count(
            select={
                '_all': True,
                'upper_limb_left_front_part': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.topographic_explorationCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.topographic_explorationWhereInput] = None,
        cursor: Optional[types.topographic_explorationWhereUniqueInput] = None,
    ) -> types.topographic_explorationCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.topographic_explorationCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.topographic_explorationWhereInput] = None,
        cursor: Optional[types.topographic_explorationWhereUniqueInput] = None,
    ) -> Union[int, types.topographic_explorationCountAggregateOutput]:
        """Count the number of topographic_exploration records present in the database

        Parameters
        ----------
        select
            Select the topographic_exploration fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            topographic_exploration filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.topographic_explorationCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await topographic_exploration.prisma().count()

        # results: prisma.types.topographic_explorationCountAggregateOutput
        results = await topographic_exploration.prisma().count(
            select={
                '_all': True,
                'upper_limb_left_back_part': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.topographic_explorationCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.topographic_explorationWhereInput] = None
    ) -> int:
        """Delete multiple topographic_exploration records.

        Parameters
        ----------
        where
            Optional topographic_exploration filter to find the records to be deleted

        Returns
        -------
        int
            The total number of topographic_exploration records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all topographic_exploration records
        total = await topographic_exploration.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.topographic_explorationScalarFieldKeys'],
        *,
        where: Optional['types.topographic_explorationWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.topographic_explorationAvgAggregateInput'] = None,
        sum: Optional['types.topographic_explorationSumAggregateInput'] = None,
        min: Optional['types.topographic_explorationMinAggregateInput'] = None,
        max: Optional['types.topographic_explorationMaxAggregateInput'] = None,
        having: Optional['types.topographic_explorationScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.topographic_explorationCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.topographic_explorationScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.topographic_explorationScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.topographic_explorationGroupByOutput']:
        """Group topographic_exploration records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar topographic_exploration fields to group records by
        where
            topographic_exploration filter to select records
        take
            Limit the maximum number of topographic_exploration records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.topographic_explorationGroupByOutput]
            A list of dictionaries representing the topographic_exploration record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group topographic_exploration records by upper_limb_right_front_part values
        # and count how many records are in each group
        results = await topographic_exploration.prisma().group_by(
            ['upper_limb_right_front_part'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class lab_results_by_medical_consultationActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.lab_results_by_medical_consultation]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await lab_results_by_medical_consultation.prisma().query_raw(
            'SELECT * FROM lab_results_by_medical_consultation WHERE id = ?',
            665143380,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.lab_results_by_medical_consultation
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await lab_results_by_medical_consultation.prisma().query_first(
            'SELECT * FROM lab_results_by_medical_consultation WHERE lab_result_id = ?',
            39949309,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.lab_results_by_medical_consultationCreateInput,
        include: Optional[types.lab_results_by_medical_consultationInclude] = None
    ) -> _PrismaModelT:
        """Create a new lab_results_by_medical_consultation record.

        Parameters
        ----------
        data
            lab_results_by_medical_consultation record data
        include
            Specifies which relations should be loaded on the returned lab_results_by_medical_consultation model

        Returns
        -------
        prisma.models.lab_results_by_medical_consultation
            The created lab_results_by_medical_consultation record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a lab_results_by_medical_consultation record from just the required fields
        lab_results_by_medical_consultation = await lab_results_by_medical_consultation.prisma().create(
            data={
                # data to create a lab_results_by_medical_consultation record
                'lab_result_id': 1901152498,
                'medical_consultation_id': 'bgchfbjibb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.lab_results_by_medical_consultationCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple lab_results_by_medical_consultation records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of lab_results_by_medical_consultation record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await lab_results_by_medical_consultation.prisma().create_many(
            data=[
                {
                    # data to create a lab_results_by_medical_consultation record
                    'lab_result_id': 1094227392,
                    'medical_consultation_id': 'dfgacajif',
                },
                {
                    # data to create a lab_results_by_medical_consultation record
                    'lab_result_id': 1638335038,
                    'medical_consultation_id': 'bijbfghhhf',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.lab_results_by_medical_consultationWhereUniqueInput,
        include: Optional[types.lab_results_by_medical_consultationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single lab_results_by_medical_consultation record.

        Parameters
        ----------
        where
            lab_results_by_medical_consultation filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned lab_results_by_medical_consultation model

        Returns
        -------
        prisma.models.lab_results_by_medical_consultation
            The deleted lab_results_by_medical_consultation record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        lab_results_by_medical_consultation = await lab_results_by_medical_consultation.prisma().delete(
            where={
                'id': 1072778732,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.lab_results_by_medical_consultationWhereUniqueInput,
        include: Optional[types.lab_results_by_medical_consultationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique lab_results_by_medical_consultation record.

        Parameters
        ----------
        where
            lab_results_by_medical_consultation filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned lab_results_by_medical_consultation model

        Returns
        -------
        prisma.models.lab_results_by_medical_consultation
            The found lab_results_by_medical_consultation record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        lab_results_by_medical_consultation = await lab_results_by_medical_consultation.prisma().find_unique(
            where={
                'id': 1879328181,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.lab_results_by_medical_consultationWhereUniqueInput,
        include: Optional[types.lab_results_by_medical_consultationInclude] = None
    ) -> _PrismaModelT:
        """Find a unique lab_results_by_medical_consultation record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            lab_results_by_medical_consultation filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned lab_results_by_medical_consultation model

        Returns
        -------
        prisma.models.lab_results_by_medical_consultation
            The found lab_results_by_medical_consultation record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        lab_results_by_medical_consultation = await lab_results_by_medical_consultation.prisma().find_unique_or_raise(
            where={
                'id': 1577911370,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.lab_results_by_medical_consultationWhereInput] = None,
        cursor: Optional[types.lab_results_by_medical_consultationWhereUniqueInput] = None,
        include: Optional[types.lab_results_by_medical_consultationInclude] = None,
        order: Optional[Union[types.lab_results_by_medical_consultationOrderByInput, List[types.lab_results_by_medical_consultationOrderByInput]]] = None,
        distinct: Optional[List[types.lab_results_by_medical_consultationScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple lab_results_by_medical_consultation records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of lab_results_by_medical_consultation records returned
        skip
            Ignore the first N results
        where
            lab_results_by_medical_consultation filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned lab_results_by_medical_consultation model
        order
            Order the returned lab_results_by_medical_consultation records by any field
        distinct
            Filter lab_results_by_medical_consultation records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.lab_results_by_medical_consultation]
            The list of all lab_results_by_medical_consultation records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 lab_results_by_medical_consultation records
        lab_results_by_medical_consultations = await lab_results_by_medical_consultation.prisma().find_many(take=10)

        # find the first 5 lab_results_by_medical_consultation records ordered by the medical_consultation_id field
        lab_results_by_medical_consultations = await lab_results_by_medical_consultation.prisma().find_many(
            take=5,
            order={
                'medical_consultation_id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.lab_results_by_medical_consultationWhereInput] = None,
        cursor: Optional[types.lab_results_by_medical_consultationWhereUniqueInput] = None,
        include: Optional[types.lab_results_by_medical_consultationInclude] = None,
        order: Optional[Union[types.lab_results_by_medical_consultationOrderByInput, List[types.lab_results_by_medical_consultationOrderByInput]]] = None,
        distinct: Optional[List[types.lab_results_by_medical_consultationScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single lab_results_by_medical_consultation record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            lab_results_by_medical_consultation filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned lab_results_by_medical_consultation model
        order
            Order the returned lab_results_by_medical_consultation records by any field
        distinct
            Filter lab_results_by_medical_consultation records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.lab_results_by_medical_consultation
            The first lab_results_by_medical_consultation record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second lab_results_by_medical_consultation record ordered by the id field
        lab_results_by_medical_consultation = await lab_results_by_medical_consultation.prisma().find_first(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.lab_results_by_medical_consultationWhereInput] = None,
        cursor: Optional[types.lab_results_by_medical_consultationWhereUniqueInput] = None,
        include: Optional[types.lab_results_by_medical_consultationInclude] = None,
        order: Optional[Union[types.lab_results_by_medical_consultationOrderByInput, List[types.lab_results_by_medical_consultationOrderByInput]]] = None,
        distinct: Optional[List[types.lab_results_by_medical_consultationScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single lab_results_by_medical_consultation record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            lab_results_by_medical_consultation filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned lab_results_by_medical_consultation model
        order
            Order the returned lab_results_by_medical_consultation records by any field
        distinct
            Filter lab_results_by_medical_consultation records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.lab_results_by_medical_consultation
            The first lab_results_by_medical_consultation record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second lab_results_by_medical_consultation record ordered by the lab_result_id field
        lab_results_by_medical_consultation = await lab_results_by_medical_consultation.prisma().find_first_or_raise(
            skip=1,
            order={
                'lab_result_id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.lab_results_by_medical_consultationUpdateInput,
        where: types.lab_results_by_medical_consultationWhereUniqueInput,
        include: Optional[types.lab_results_by_medical_consultationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single lab_results_by_medical_consultation record.

        Parameters
        ----------
        data
            lab_results_by_medical_consultation record data specifying what to update
        where
            lab_results_by_medical_consultation filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned lab_results_by_medical_consultation model

        Returns
        -------
        prisma.models.lab_results_by_medical_consultation
            The updated lab_results_by_medical_consultation record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        lab_results_by_medical_consultation = await lab_results_by_medical_consultation.prisma().update(
            where={
                'id': 504729531,
            },
            data={
                # data to update the lab_results_by_medical_consultation record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.lab_results_by_medical_consultationWhereUniqueInput,
        data: types.lab_results_by_medical_consultationUpsertInput,
        include: Optional[types.lab_results_by_medical_consultationInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            lab_results_by_medical_consultation filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned lab_results_by_medical_consultation model

        Returns
        -------
        prisma.models.lab_results_by_medical_consultation
            The created or updated lab_results_by_medical_consultation record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        lab_results_by_medical_consultation = await lab_results_by_medical_consultation.prisma().upsert(
            where={
                'id': 110845144,
            },
            data={
                'create': {
                    'id': 110845144,
                    'lab_result_id': 1638335038,
                    'medical_consultation_id': 'bijbfghhhf',
                },
                'update': {
                    'lab_result_id': 1638335038,
                    'medical_consultation_id': 'bijbfghhhf',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.lab_results_by_medical_consultationUpdateManyMutationInput,
        where: types.lab_results_by_medical_consultationWhereInput,
    ) -> int:
        """Update multiple lab_results_by_medical_consultation records

        Parameters
        ----------
        data
            lab_results_by_medical_consultation data to update the selected lab_results_by_medical_consultation records to
        where
            Filter to select the lab_results_by_medical_consultation records to update

        Returns
        -------
        int
            The total number of lab_results_by_medical_consultation records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all lab_results_by_medical_consultation records
        total = await lab_results_by_medical_consultation.prisma().update_many(
            data={
                'medical_consultation_id': 'bdaacgjbaf'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.lab_results_by_medical_consultationWhereInput] = None,
        cursor: Optional[types.lab_results_by_medical_consultationWhereUniqueInput] = None,
    ) -> int:
        """Count the number of lab_results_by_medical_consultation records present in the database

        Parameters
        ----------
        select
            Select the lab_results_by_medical_consultation fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            lab_results_by_medical_consultation filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.lab_results_by_medical_consultationCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await lab_results_by_medical_consultation.prisma().count()

        # results: prisma.types.lab_results_by_medical_consultationCountAggregateOutput
        results = await lab_results_by_medical_consultation.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.lab_results_by_medical_consultationCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.lab_results_by_medical_consultationWhereInput] = None,
        cursor: Optional[types.lab_results_by_medical_consultationWhereUniqueInput] = None,
    ) -> types.lab_results_by_medical_consultationCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.lab_results_by_medical_consultationCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.lab_results_by_medical_consultationWhereInput] = None,
        cursor: Optional[types.lab_results_by_medical_consultationWhereUniqueInput] = None,
    ) -> Union[int, types.lab_results_by_medical_consultationCountAggregateOutput]:
        """Count the number of lab_results_by_medical_consultation records present in the database

        Parameters
        ----------
        select
            Select the lab_results_by_medical_consultation fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            lab_results_by_medical_consultation filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.lab_results_by_medical_consultationCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await lab_results_by_medical_consultation.prisma().count()

        # results: prisma.types.lab_results_by_medical_consultationCountAggregateOutput
        results = await lab_results_by_medical_consultation.prisma().count(
            select={
                '_all': True,
                'lab_result_id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.lab_results_by_medical_consultationCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.lab_results_by_medical_consultationWhereInput] = None
    ) -> int:
        """Delete multiple lab_results_by_medical_consultation records.

        Parameters
        ----------
        where
            Optional lab_results_by_medical_consultation filter to find the records to be deleted

        Returns
        -------
        int
            The total number of lab_results_by_medical_consultation records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all lab_results_by_medical_consultation records
        total = await lab_results_by_medical_consultation.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.lab_results_by_medical_consultationScalarFieldKeys'],
        *,
        where: Optional['types.lab_results_by_medical_consultationWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.lab_results_by_medical_consultationAvgAggregateInput'] = None,
        sum: Optional['types.lab_results_by_medical_consultationSumAggregateInput'] = None,
        min: Optional['types.lab_results_by_medical_consultationMinAggregateInput'] = None,
        max: Optional['types.lab_results_by_medical_consultationMaxAggregateInput'] = None,
        having: Optional['types.lab_results_by_medical_consultationScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.lab_results_by_medical_consultationCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.lab_results_by_medical_consultationScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.lab_results_by_medical_consultationScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.lab_results_by_medical_consultationGroupByOutput']:
        """Group lab_results_by_medical_consultation records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar lab_results_by_medical_consultation fields to group records by
        where
            lab_results_by_medical_consultation filter to select records
        take
            Limit the maximum number of lab_results_by_medical_consultation records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.lab_results_by_medical_consultationGroupByOutput]
            A list of dictionaries representing the lab_results_by_medical_consultation record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group lab_results_by_medical_consultation records by medical_consultation_id values
        # and count how many records are in each group
        results = await lab_results_by_medical_consultation.prisma().group_by(
            ['medical_consultation_id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class event_patientActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.event_patient]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await event_patient.prisma().query_raw(
            'SELECT * FROM event_patient WHERE id = ?',
            1881086742,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.event_patient
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await event_patient.prisma().query_first(
            'SELECT * FROM event_patient WHERE event_id = ?',
            'baicdfeidj',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.event_patientCreateInput,
        include: Optional[types.event_patientInclude] = None
    ) -> _PrismaModelT:
        """Create a new event_patient record.

        Parameters
        ----------
        data
            event_patient record data
        include
            Specifies which relations should be loaded on the returned event_patient model

        Returns
        -------
        prisma.models.event_patient
            The created event_patient record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a event_patient record from just the required fields
        event_patient = await event_patient.prisma().create(
            data={
                # data to create a event_patient record
                'event_id': 'befgiciadg',
                'patient_id': 'cbcehahedh',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.event_patientCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple event_patient records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of event_patient record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await event_patient.prisma().create_many(
            data=[
                {
                    # data to create a event_patient record
                    'event_id': 'bcjihiaide',
                    'patient_id': 'bagfijcgfj',
                },
                {
                    # data to create a event_patient record
                    'event_id': 'bcggehiidc',
                    'patient_id': 'bjcdacgacf',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.event_patientWhereUniqueInput,
        include: Optional[types.event_patientInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single event_patient record.

        Parameters
        ----------
        where
            event_patient filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned event_patient model

        Returns
        -------
        prisma.models.event_patient
            The deleted event_patient record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        event_patient = await event_patient.prisma().delete(
            where={
                'id': 95844078,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.event_patientWhereUniqueInput,
        include: Optional[types.event_patientInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique event_patient record.

        Parameters
        ----------
        where
            event_patient filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned event_patient model

        Returns
        -------
        prisma.models.event_patient
            The found event_patient record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        event_patient = await event_patient.prisma().find_unique(
            where={
                'id': 1895913359,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.event_patientWhereUniqueInput,
        include: Optional[types.event_patientInclude] = None
    ) -> _PrismaModelT:
        """Find a unique event_patient record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            event_patient filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned event_patient model

        Returns
        -------
        prisma.models.event_patient
            The found event_patient record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        event_patient = await event_patient.prisma().find_unique_or_raise(
            where={
                'id': 232393244,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.event_patientWhereInput] = None,
        cursor: Optional[types.event_patientWhereUniqueInput] = None,
        include: Optional[types.event_patientInclude] = None,
        order: Optional[Union[types.event_patientOrderByInput, List[types.event_patientOrderByInput]]] = None,
        distinct: Optional[List[types.event_patientScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple event_patient records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of event_patient records returned
        skip
            Ignore the first N results
        where
            event_patient filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned event_patient model
        order
            Order the returned event_patient records by any field
        distinct
            Filter event_patient records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.event_patient]
            The list of all event_patient records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 event_patient records
        event_patients = await event_patient.prisma().find_many(take=10)

        # find the first 5 event_patient records ordered by the patient_id field
        event_patients = await event_patient.prisma().find_many(
            take=5,
            order={
                'patient_id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.event_patientWhereInput] = None,
        cursor: Optional[types.event_patientWhereUniqueInput] = None,
        include: Optional[types.event_patientInclude] = None,
        order: Optional[Union[types.event_patientOrderByInput, List[types.event_patientOrderByInput]]] = None,
        distinct: Optional[List[types.event_patientScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single event_patient record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            event_patient filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned event_patient model
        order
            Order the returned event_patient records by any field
        distinct
            Filter event_patient records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.event_patient
            The first event_patient record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second event_patient record ordered by the id field
        event_patient = await event_patient.prisma().find_first(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.event_patientWhereInput] = None,
        cursor: Optional[types.event_patientWhereUniqueInput] = None,
        include: Optional[types.event_patientInclude] = None,
        order: Optional[Union[types.event_patientOrderByInput, List[types.event_patientOrderByInput]]] = None,
        distinct: Optional[List[types.event_patientScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single event_patient record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            event_patient filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned event_patient model
        order
            Order the returned event_patient records by any field
        distinct
            Filter event_patient records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.event_patient
            The first event_patient record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second event_patient record ordered by the event_id field
        event_patient = await event_patient.prisma().find_first_or_raise(
            skip=1,
            order={
                'event_id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.event_patientUpdateInput,
        where: types.event_patientWhereUniqueInput,
        include: Optional[types.event_patientInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single event_patient record.

        Parameters
        ----------
        data
            event_patient record data specifying what to update
        where
            event_patient filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned event_patient model

        Returns
        -------
        prisma.models.event_patient
            The updated event_patient record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        event_patient = await event_patient.prisma().update(
            where={
                'id': 1116931621,
            },
            data={
                # data to update the event_patient record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.event_patientWhereUniqueInput,
        data: types.event_patientUpsertInput,
        include: Optional[types.event_patientInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            event_patient filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned event_patient model

        Returns
        -------
        prisma.models.event_patient
            The created or updated event_patient record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        event_patient = await event_patient.prisma().upsert(
            where={
                'id': 1243026426,
            },
            data={
                'create': {
                    'id': 1243026426,
                    'event_id': 'bcggehiidc',
                    'patient_id': 'bjcdacgacf',
                },
                'update': {
                    'event_id': 'bcggehiidc',
                    'patient_id': 'bjcdacgacf',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.event_patientUpdateManyMutationInput,
        where: types.event_patientWhereInput,
    ) -> int:
        """Update multiple event_patient records

        Parameters
        ----------
        data
            event_patient data to update the selected event_patient records to
        where
            Filter to select the event_patient records to update

        Returns
        -------
        int
            The total number of event_patient records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all event_patient records
        total = await event_patient.prisma().update_many(
            data={
                'patient_id': 'cbdffjeh'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.event_patientWhereInput] = None,
        cursor: Optional[types.event_patientWhereUniqueInput] = None,
    ) -> int:
        """Count the number of event_patient records present in the database

        Parameters
        ----------
        select
            Select the event_patient fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            event_patient filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.event_patientCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await event_patient.prisma().count()

        # results: prisma.types.event_patientCountAggregateOutput
        results = await event_patient.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.event_patientCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.event_patientWhereInput] = None,
        cursor: Optional[types.event_patientWhereUniqueInput] = None,
    ) -> types.event_patientCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.event_patientCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.event_patientWhereInput] = None,
        cursor: Optional[types.event_patientWhereUniqueInput] = None,
    ) -> Union[int, types.event_patientCountAggregateOutput]:
        """Count the number of event_patient records present in the database

        Parameters
        ----------
        select
            Select the event_patient fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            event_patient filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.event_patientCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await event_patient.prisma().count()

        # results: prisma.types.event_patientCountAggregateOutput
        results = await event_patient.prisma().count(
            select={
                '_all': True,
                'event_id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.event_patientCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.event_patientWhereInput] = None
    ) -> int:
        """Delete multiple event_patient records.

        Parameters
        ----------
        where
            Optional event_patient filter to find the records to be deleted

        Returns
        -------
        int
            The total number of event_patient records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all event_patient records
        total = await event_patient.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.event_patientScalarFieldKeys'],
        *,
        where: Optional['types.event_patientWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.event_patientAvgAggregateInput'] = None,
        sum: Optional['types.event_patientSumAggregateInput'] = None,
        min: Optional['types.event_patientMinAggregateInput'] = None,
        max: Optional['types.event_patientMaxAggregateInput'] = None,
        having: Optional['types.event_patientScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.event_patientCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.event_patientScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.event_patientScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.event_patientGroupByOutput']:
        """Group event_patient records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar event_patient fields to group records by
        where
            event_patient filter to select records
        take
            Limit the maximum number of event_patient records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.event_patientGroupByOutput]
            A list of dictionaries representing the event_patient record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group event_patient records by patient_id values
        # and count how many records are in each group
        results = await event_patient.prisma().group_by(
            ['patient_id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class event_prospective_patientActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.event_prospective_patient]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await event_prospective_patient.prisma().query_raw(
            'SELECT * FROM event_prospective_patient WHERE id = ?',
            831237128,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.event_prospective_patient
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await event_prospective_patient.prisma().query_first(
            'SELECT * FROM event_prospective_patient WHERE event_id = ?',
            'bacegehahd',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.event_prospective_patientCreateInput,
        include: Optional[types.event_prospective_patientInclude] = None
    ) -> _PrismaModelT:
        """Create a new event_prospective_patient record.

        Parameters
        ----------
        data
            event_prospective_patient record data
        include
            Specifies which relations should be loaded on the returned event_prospective_patient model

        Returns
        -------
        prisma.models.event_prospective_patient
            The created event_prospective_patient record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a event_prospective_patient record from just the required fields
        event_prospective_patient = await event_prospective_patient.prisma().create(
            data={
                # data to create a event_prospective_patient record
                'event_id': 'ebedeihec',
                'prospective_patient_id': 1090693511,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.event_prospective_patientCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple event_prospective_patient records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of event_prospective_patient record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await event_prospective_patient.prisma().create_many(
            data=[
                {
                    # data to create a event_prospective_patient record
                    'event_id': 'bggedbjggi',
                    'prospective_patient_id': 761058525,
                },
                {
                    # data to create a event_prospective_patient record
                    'event_id': 'bejiecfecg',
                    'prospective_patient_id': 1960204067,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.event_prospective_patientWhereUniqueInput,
        include: Optional[types.event_prospective_patientInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single event_prospective_patient record.

        Parameters
        ----------
        where
            event_prospective_patient filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned event_prospective_patient model

        Returns
        -------
        prisma.models.event_prospective_patient
            The deleted event_prospective_patient record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        event_prospective_patient = await event_prospective_patient.prisma().delete(
            where={
                'id': 1440871456,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.event_prospective_patientWhereUniqueInput,
        include: Optional[types.event_prospective_patientInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique event_prospective_patient record.

        Parameters
        ----------
        where
            event_prospective_patient filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned event_prospective_patient model

        Returns
        -------
        prisma.models.event_prospective_patient
            The found event_prospective_patient record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        event_prospective_patient = await event_prospective_patient.prisma().find_unique(
            where={
                'id': 1515643353,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.event_prospective_patientWhereUniqueInput,
        include: Optional[types.event_prospective_patientInclude] = None
    ) -> _PrismaModelT:
        """Find a unique event_prospective_patient record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            event_prospective_patient filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned event_prospective_patient model

        Returns
        -------
        prisma.models.event_prospective_patient
            The found event_prospective_patient record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        event_prospective_patient = await event_prospective_patient.prisma().find_unique_or_raise(
            where={
                'id': 916748190,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.event_prospective_patientWhereInput] = None,
        cursor: Optional[types.event_prospective_patientWhereUniqueInput] = None,
        include: Optional[types.event_prospective_patientInclude] = None,
        order: Optional[Union[types.event_prospective_patientOrderByInput, List[types.event_prospective_patientOrderByInput]]] = None,
        distinct: Optional[List[types.event_prospective_patientScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple event_prospective_patient records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of event_prospective_patient records returned
        skip
            Ignore the first N results
        where
            event_prospective_patient filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned event_prospective_patient model
        order
            Order the returned event_prospective_patient records by any field
        distinct
            Filter event_prospective_patient records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.event_prospective_patient]
            The list of all event_prospective_patient records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 event_prospective_patient records
        event_prospective_patients = await event_prospective_patient.prisma().find_many(take=10)

        # find the first 5 event_prospective_patient records ordered by the prospective_patient_id field
        event_prospective_patients = await event_prospective_patient.prisma().find_many(
            take=5,
            order={
                'prospective_patient_id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.event_prospective_patientWhereInput] = None,
        cursor: Optional[types.event_prospective_patientWhereUniqueInput] = None,
        include: Optional[types.event_prospective_patientInclude] = None,
        order: Optional[Union[types.event_prospective_patientOrderByInput, List[types.event_prospective_patientOrderByInput]]] = None,
        distinct: Optional[List[types.event_prospective_patientScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single event_prospective_patient record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            event_prospective_patient filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned event_prospective_patient model
        order
            Order the returned event_prospective_patient records by any field
        distinct
            Filter event_prospective_patient records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.event_prospective_patient
            The first event_prospective_patient record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second event_prospective_patient record ordered by the id field
        event_prospective_patient = await event_prospective_patient.prisma().find_first(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.event_prospective_patientWhereInput] = None,
        cursor: Optional[types.event_prospective_patientWhereUniqueInput] = None,
        include: Optional[types.event_prospective_patientInclude] = None,
        order: Optional[Union[types.event_prospective_patientOrderByInput, List[types.event_prospective_patientOrderByInput]]] = None,
        distinct: Optional[List[types.event_prospective_patientScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single event_prospective_patient record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            event_prospective_patient filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned event_prospective_patient model
        order
            Order the returned event_prospective_patient records by any field
        distinct
            Filter event_prospective_patient records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.event_prospective_patient
            The first event_prospective_patient record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second event_prospective_patient record ordered by the event_id field
        event_prospective_patient = await event_prospective_patient.prisma().find_first_or_raise(
            skip=1,
            order={
                'event_id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.event_prospective_patientUpdateInput,
        where: types.event_prospective_patientWhereUniqueInput,
        include: Optional[types.event_prospective_patientInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single event_prospective_patient record.

        Parameters
        ----------
        data
            event_prospective_patient record data specifying what to update
        where
            event_prospective_patient filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned event_prospective_patient model

        Returns
        -------
        prisma.models.event_prospective_patient
            The updated event_prospective_patient record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        event_prospective_patient = await event_prospective_patient.prisma().update(
            where={
                'id': 44909183,
            },
            data={
                # data to update the event_prospective_patient record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.event_prospective_patientWhereUniqueInput,
        data: types.event_prospective_patientUpsertInput,
        include: Optional[types.event_prospective_patientInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            event_prospective_patient filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned event_prospective_patient model

        Returns
        -------
        prisma.models.event_prospective_patient
            The created or updated event_prospective_patient record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        event_prospective_patient = await event_prospective_patient.prisma().upsert(
            where={
                'id': 457323084,
            },
            data={
                'create': {
                    'id': 457323084,
                    'event_id': 'bejiecfecg',
                    'prospective_patient_id': 1960204067,
                },
                'update': {
                    'event_id': 'bejiecfecg',
                    'prospective_patient_id': 1960204067,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.event_prospective_patientUpdateManyMutationInput,
        where: types.event_prospective_patientWhereInput,
    ) -> int:
        """Update multiple event_prospective_patient records

        Parameters
        ----------
        data
            event_prospective_patient data to update the selected event_prospective_patient records to
        where
            Filter to select the event_prospective_patient records to update

        Returns
        -------
        int
            The total number of event_prospective_patient records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all event_prospective_patient records
        total = await event_prospective_patient.prisma().update_many(
            data={
                'prospective_patient_id': 2034942613
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.event_prospective_patientWhereInput] = None,
        cursor: Optional[types.event_prospective_patientWhereUniqueInput] = None,
    ) -> int:
        """Count the number of event_prospective_patient records present in the database

        Parameters
        ----------
        select
            Select the event_prospective_patient fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            event_prospective_patient filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.event_prospective_patientCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await event_prospective_patient.prisma().count()

        # results: prisma.types.event_prospective_patientCountAggregateOutput
        results = await event_prospective_patient.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.event_prospective_patientCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.event_prospective_patientWhereInput] = None,
        cursor: Optional[types.event_prospective_patientWhereUniqueInput] = None,
    ) -> types.event_prospective_patientCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.event_prospective_patientCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.event_prospective_patientWhereInput] = None,
        cursor: Optional[types.event_prospective_patientWhereUniqueInput] = None,
    ) -> Union[int, types.event_prospective_patientCountAggregateOutput]:
        """Count the number of event_prospective_patient records present in the database

        Parameters
        ----------
        select
            Select the event_prospective_patient fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            event_prospective_patient filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.event_prospective_patientCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await event_prospective_patient.prisma().count()

        # results: prisma.types.event_prospective_patientCountAggregateOutput
        results = await event_prospective_patient.prisma().count(
            select={
                '_all': True,
                'event_id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.event_prospective_patientCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.event_prospective_patientWhereInput] = None
    ) -> int:
        """Delete multiple event_prospective_patient records.

        Parameters
        ----------
        where
            Optional event_prospective_patient filter to find the records to be deleted

        Returns
        -------
        int
            The total number of event_prospective_patient records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all event_prospective_patient records
        total = await event_prospective_patient.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.event_prospective_patientScalarFieldKeys'],
        *,
        where: Optional['types.event_prospective_patientWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.event_prospective_patientAvgAggregateInput'] = None,
        sum: Optional['types.event_prospective_patientSumAggregateInput'] = None,
        min: Optional['types.event_prospective_patientMinAggregateInput'] = None,
        max: Optional['types.event_prospective_patientMaxAggregateInput'] = None,
        having: Optional['types.event_prospective_patientScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.event_prospective_patientCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.event_prospective_patientScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.event_prospective_patientScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.event_prospective_patientGroupByOutput']:
        """Group event_prospective_patient records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar event_prospective_patient fields to group records by
        where
            event_prospective_patient filter to select records
        take
            Limit the maximum number of event_prospective_patient records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.event_prospective_patientGroupByOutput]
            A list of dictionaries representing the event_prospective_patient record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group event_prospective_patient records by prospective_patient_id values
        # and count how many records are in each group
        results = await event_prospective_patient.prisma().group_by(
            ['prospective_patient_id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class eventsActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.events]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await events.prisma().query_raw(
            'SELECT * FROM events WHERE id = ?',
            'bahjhjjhcc',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.events
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await events.prisma().query_first(
            'SELECT * FROM events WHERE user_id = ?',
            'ebhbhbdff',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.eventsCreateInput,
        include: Optional[types.eventsInclude] = None
    ) -> _PrismaModelT:
        """Create a new events record.

        Parameters
        ----------
        data
            events record data
        include
            Specifies which relations should be loaded on the returned events model

        Returns
        -------
        prisma.models.events
            The created events record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a events record from just the required fields
        events = await events.prisma().create(
            data={
                # data to create a events record
                'id': 'bdiefcdfhg',
                'user_id': 'cheifeghd',
                'date': datetime.datetime.utcnow(),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.eventsCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple events records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of events record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await events.prisma().create_many(
            data=[
                {
                    # data to create a events record
                    'id': 'fgijheefe',
                    'user_id': 'hcbgbhfch',
                    'date': datetime.datetime.utcnow(),
                },
                {
                    # data to create a events record
                    'id': 'bfbbbgbfhc',
                    'user_id': 'ibijjdeb',
                    'date': datetime.datetime.utcnow(),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.eventsWhereUniqueInput,
        include: Optional[types.eventsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single events record.

        Parameters
        ----------
        where
            events filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned events model

        Returns
        -------
        prisma.models.events
            The deleted events record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        events = await events.prisma().delete(
            where={
                'id': 'caehiccddi',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.eventsWhereUniqueInput,
        include: Optional[types.eventsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique events record.

        Parameters
        ----------
        where
            events filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned events model

        Returns
        -------
        prisma.models.events
            The found events record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        events = await events.prisma().find_unique(
            where={
                'id': 'bgcahjbafj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.eventsWhereUniqueInput,
        include: Optional[types.eventsInclude] = None
    ) -> _PrismaModelT:
        """Find a unique events record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            events filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned events model

        Returns
        -------
        prisma.models.events
            The found events record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        events = await events.prisma().find_unique_or_raise(
            where={
                'id': 'bihhgeihca',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.eventsWhereInput] = None,
        cursor: Optional[types.eventsWhereUniqueInput] = None,
        include: Optional[types.eventsInclude] = None,
        order: Optional[Union[types.eventsOrderByInput, List[types.eventsOrderByInput]]] = None,
        distinct: Optional[List[types.eventsScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple events records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of events records returned
        skip
            Ignore the first N results
        where
            events filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned events model
        order
            Order the returned events records by any field
        distinct
            Filter events records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.events]
            The list of all events records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 events records
        events = await events.prisma().find_many(take=10)

        # find the first 5 events records ordered by the asocciate_patient field
        events = await events.prisma().find_many(
            take=5,
            order={
                'asocciate_patient': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.eventsWhereInput] = None,
        cursor: Optional[types.eventsWhereUniqueInput] = None,
        include: Optional[types.eventsInclude] = None,
        order: Optional[Union[types.eventsOrderByInput, List[types.eventsOrderByInput]]] = None,
        distinct: Optional[List[types.eventsScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single events record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            events filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned events model
        order
            Order the returned events records by any field
        distinct
            Filter events records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.events
            The first events record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second events record ordered by the date field
        events = await events.prisma().find_first(
            skip=1,
            order={
                'date': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.eventsWhereInput] = None,
        cursor: Optional[types.eventsWhereUniqueInput] = None,
        include: Optional[types.eventsInclude] = None,
        order: Optional[Union[types.eventsOrderByInput, List[types.eventsOrderByInput]]] = None,
        distinct: Optional[List[types.eventsScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single events record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            events filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned events model
        order
            Order the returned events records by any field
        distinct
            Filter events records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.events
            The first events record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second events record ordered by the hour field
        events = await events.prisma().find_first_or_raise(
            skip=1,
            order={
                'hour': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.eventsUpdateInput,
        where: types.eventsWhereUniqueInput,
        include: Optional[types.eventsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single events record.

        Parameters
        ----------
        data
            events record data specifying what to update
        where
            events filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned events model

        Returns
        -------
        prisma.models.events
            The updated events record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        events = await events.prisma().update(
            where={
                'id': 'bdgbfahbef',
            },
            data={
                # data to update the events record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.eventsWhereUniqueInput,
        data: types.eventsUpsertInput,
        include: Optional[types.eventsInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            events filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned events model

        Returns
        -------
        prisma.models.events
            The created or updated events record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        events = await events.prisma().upsert(
            where={
                'id': 'fccjhidic',
            },
            data={
                'create': {
                    'id': 'fccjhidic',
                    'user_id': 'ibijjdeb',
                    'date': datetime.datetime.utcnow(),
                },
                'update': {
                    'user_id': 'ibijjdeb',
                    'date': datetime.datetime.utcnow(),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.eventsUpdateManyMutationInput,
        where: types.eventsWhereInput,
    ) -> int:
        """Update multiple events records

        Parameters
        ----------
        data
            events data to update the selected events records to
        where
            Filter to select the events records to update

        Returns
        -------
        int
            The total number of events records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all events records
        total = await events.prisma().update_many(
            data={
                'id': 'bdgfdgdaff'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.eventsWhereInput] = None,
        cursor: Optional[types.eventsWhereUniqueInput] = None,
    ) -> int:
        """Count the number of events records present in the database

        Parameters
        ----------
        select
            Select the events fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            events filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.eventsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await events.prisma().count()

        # results: prisma.types.eventsCountAggregateOutput
        results = await events.prisma().count(
            select={
                '_all': True,
                'user_id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.eventsCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.eventsWhereInput] = None,
        cursor: Optional[types.eventsWhereUniqueInput] = None,
    ) -> types.eventsCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.eventsCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.eventsWhereInput] = None,
        cursor: Optional[types.eventsWhereUniqueInput] = None,
    ) -> Union[int, types.eventsCountAggregateOutput]:
        """Count the number of events records present in the database

        Parameters
        ----------
        select
            Select the events fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            events filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.eventsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await events.prisma().count()

        # results: prisma.types.eventsCountAggregateOutput
        results = await events.prisma().count(
            select={
                '_all': True,
                'asocciate_patient': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.eventsCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.eventsWhereInput] = None
    ) -> int:
        """Delete multiple events records.

        Parameters
        ----------
        where
            Optional events filter to find the records to be deleted

        Returns
        -------
        int
            The total number of events records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all events records
        total = await events.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.eventsScalarFieldKeys'],
        *,
        where: Optional['types.eventsWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.eventsAvgAggregateInput'] = None,
        sum: Optional['types.eventsSumAggregateInput'] = None,
        min: Optional['types.eventsMinAggregateInput'] = None,
        max: Optional['types.eventsMaxAggregateInput'] = None,
        having: Optional['types.eventsScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.eventsCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.eventsScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.eventsScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.eventsGroupByOutput']:
        """Group events records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar events fields to group records by
        where
            events filter to select records
        take
            Limit the maximum number of events records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.eventsGroupByOutput]
            A list of dictionaries representing the events record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group events records by date values
        # and count how many records are in each group
        results = await events.prisma().group_by(
            ['date'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class prospective_patientsActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.prospective_patients]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await prospective_patients.prisma().query_raw(
            'SELECT * FROM prospective_patients WHERE id = ?',
            1826408060,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.prospective_patients
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await prospective_patients.prisma().query_first(
            'SELECT * FROM prospective_patients WHERE name = ?',
            'fajhhafab',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.prospective_patientsCreateInput,
        include: Optional[types.prospective_patientsInclude] = None
    ) -> _PrismaModelT:
        """Create a new prospective_patients record.

        Parameters
        ----------
        data
            prospective_patients record data
        include
            Specifies which relations should be loaded on the returned prospective_patients model

        Returns
        -------
        prisma.models.prospective_patients
            The created prospective_patients record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a prospective_patients record from just the required fields
        prospective_patients = await prospective_patients.prisma().create(
            data={
                # data to create a prospective_patients record
                'name': 'bfeiccieec',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.prospective_patientsCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple prospective_patients records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of prospective_patients record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await prospective_patients.prisma().create_many(
            data=[
                {
                    # data to create a prospective_patients record
                    'name': 'hciegiihf',
                },
                {
                    # data to create a prospective_patients record
                    'name': 'bahifjfga',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.prospective_patientsWhereUniqueInput,
        include: Optional[types.prospective_patientsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single prospective_patients record.

        Parameters
        ----------
        where
            prospective_patients filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned prospective_patients model

        Returns
        -------
        prisma.models.prospective_patients
            The deleted prospective_patients record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        prospective_patients = await prospective_patients.prisma().delete(
            where={
                'id': 1041547905,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.prospective_patientsWhereUniqueInput,
        include: Optional[types.prospective_patientsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique prospective_patients record.

        Parameters
        ----------
        where
            prospective_patients filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned prospective_patients model

        Returns
        -------
        prisma.models.prospective_patients
            The found prospective_patients record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        prospective_patients = await prospective_patients.prisma().find_unique(
            where={
                'id': 1927302950,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.prospective_patientsWhereUniqueInput,
        include: Optional[types.prospective_patientsInclude] = None
    ) -> _PrismaModelT:
        """Find a unique prospective_patients record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            prospective_patients filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned prospective_patients model

        Returns
        -------
        prisma.models.prospective_patients
            The found prospective_patients record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        prospective_patients = await prospective_patients.prisma().find_unique_or_raise(
            where={
                'id': 520320871,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.prospective_patientsWhereInput] = None,
        cursor: Optional[types.prospective_patientsWhereUniqueInput] = None,
        include: Optional[types.prospective_patientsInclude] = None,
        order: Optional[Union[types.prospective_patientsOrderByInput, List[types.prospective_patientsOrderByInput]]] = None,
        distinct: Optional[List[types.prospective_patientsScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple prospective_patients records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of prospective_patients records returned
        skip
            Ignore the first N results
        where
            prospective_patients filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned prospective_patients model
        order
            Order the returned prospective_patients records by any field
        distinct
            Filter prospective_patients records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.prospective_patients]
            The list of all prospective_patients records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 prospective_patients records
        prospective_patients = await prospective_patients.prisma().find_many(take=10)

        # find the first 5 prospective_patients records ordered by the last_name field
        prospective_patients = await prospective_patients.prisma().find_many(
            take=5,
            order={
                'last_name': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.prospective_patientsWhereInput] = None,
        cursor: Optional[types.prospective_patientsWhereUniqueInput] = None,
        include: Optional[types.prospective_patientsInclude] = None,
        order: Optional[Union[types.prospective_patientsOrderByInput, List[types.prospective_patientsOrderByInput]]] = None,
        distinct: Optional[List[types.prospective_patientsScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single prospective_patients record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            prospective_patients filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned prospective_patients model
        order
            Order the returned prospective_patients records by any field
        distinct
            Filter prospective_patients records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.prospective_patients
            The first prospective_patients record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second prospective_patients record ordered by the contact_number field
        prospective_patients = await prospective_patients.prisma().find_first(
            skip=1,
            order={
                'contact_number': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.prospective_patientsWhereInput] = None,
        cursor: Optional[types.prospective_patientsWhereUniqueInput] = None,
        include: Optional[types.prospective_patientsInclude] = None,
        order: Optional[Union[types.prospective_patientsOrderByInput, List[types.prospective_patientsOrderByInput]]] = None,
        distinct: Optional[List[types.prospective_patientsScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single prospective_patients record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            prospective_patients filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned prospective_patients model
        order
            Order the returned prospective_patients records by any field
        distinct
            Filter prospective_patients records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.prospective_patients
            The first prospective_patients record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second prospective_patients record ordered by the email field
        prospective_patients = await prospective_patients.prisma().find_first_or_raise(
            skip=1,
            order={
                'email': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.prospective_patientsUpdateInput,
        where: types.prospective_patientsWhereUniqueInput,
        include: Optional[types.prospective_patientsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single prospective_patients record.

        Parameters
        ----------
        data
            prospective_patients record data specifying what to update
        where
            prospective_patients filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned prospective_patients model

        Returns
        -------
        prisma.models.prospective_patients
            The updated prospective_patients record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        prospective_patients = await prospective_patients.prisma().update(
            where={
                'id': 1132816660,
            },
            data={
                # data to update the prospective_patients record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.prospective_patientsWhereUniqueInput,
        data: types.prospective_patientsUpsertInput,
        include: Optional[types.prospective_patientsInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            prospective_patients filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned prospective_patients model

        Returns
        -------
        prisma.models.prospective_patients
            The created or updated prospective_patients record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        prospective_patients = await prospective_patients.prisma().upsert(
            where={
                'id': 1061815741,
            },
            data={
                'create': {
                    'id': 1061815741,
                    'name': 'bahifjfga',
                },
                'update': {
                    'name': 'bahifjfga',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.prospective_patientsUpdateManyMutationInput,
        where: types.prospective_patientsWhereInput,
    ) -> int:
        """Update multiple prospective_patients records

        Parameters
        ----------
        data
            prospective_patients data to update the selected prospective_patients records to
        where
            Filter to select the prospective_patients records to update

        Returns
        -------
        int
            The total number of prospective_patients records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all prospective_patients records
        total = await prospective_patients.prisma().update_many(
            data={
                'id': 1836201906
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.prospective_patientsWhereInput] = None,
        cursor: Optional[types.prospective_patientsWhereUniqueInput] = None,
    ) -> int:
        """Count the number of prospective_patients records present in the database

        Parameters
        ----------
        select
            Select the prospective_patients fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            prospective_patients filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.prospective_patientsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await prospective_patients.prisma().count()

        # results: prisma.types.prospective_patientsCountAggregateOutput
        results = await prospective_patients.prisma().count(
            select={
                '_all': True,
                'name': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.prospective_patientsCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.prospective_patientsWhereInput] = None,
        cursor: Optional[types.prospective_patientsWhereUniqueInput] = None,
    ) -> types.prospective_patientsCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.prospective_patientsCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.prospective_patientsWhereInput] = None,
        cursor: Optional[types.prospective_patientsWhereUniqueInput] = None,
    ) -> Union[int, types.prospective_patientsCountAggregateOutput]:
        """Count the number of prospective_patients records present in the database

        Parameters
        ----------
        select
            Select the prospective_patients fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            prospective_patients filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.prospective_patientsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await prospective_patients.prisma().count()

        # results: prisma.types.prospective_patientsCountAggregateOutput
        results = await prospective_patients.prisma().count(
            select={
                '_all': True,
                'last_name': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.prospective_patientsCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.prospective_patientsWhereInput] = None
    ) -> int:
        """Delete multiple prospective_patients records.

        Parameters
        ----------
        where
            Optional prospective_patients filter to find the records to be deleted

        Returns
        -------
        int
            The total number of prospective_patients records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all prospective_patients records
        total = await prospective_patients.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.prospective_patientsScalarFieldKeys'],
        *,
        where: Optional['types.prospective_patientsWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.prospective_patientsAvgAggregateInput'] = None,
        sum: Optional['types.prospective_patientsSumAggregateInput'] = None,
        min: Optional['types.prospective_patientsMinAggregateInput'] = None,
        max: Optional['types.prospective_patientsMaxAggregateInput'] = None,
        having: Optional['types.prospective_patientsScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.prospective_patientsCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.prospective_patientsScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.prospective_patientsScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.prospective_patientsGroupByOutput']:
        """Group prospective_patients records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar prospective_patients fields to group records by
        where
            prospective_patients filter to select records
        take
            Limit the maximum number of prospective_patients records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.prospective_patientsGroupByOutput]
            A list of dictionaries representing the prospective_patients record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group prospective_patients records by contact_number values
        # and count how many records are in each group
        results = await prospective_patients.prisma().group_by(
            ['contact_number'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]



def _select_fields(root: str, select: Mapping[str, Any]) -> str:
    """Helper to build a GraphQL selection string

    This is a work around until field selection is added to the query builder.
    """

    return root + ' {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))


from . import models